
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model PayslipRequest
 * 
 */
export type PayslipRequest = $Result.DefaultSelection<Prisma.$PayslipRequestPayload>
/**
 * Model Payslip
 * 
 */
export type Payslip = $Result.DefaultSelection<Prisma.$PayslipPayload>
/**
 * Model RecommendedAppointment
 * 
 */
export type RecommendedAppointment = $Result.DefaultSelection<Prisma.$RecommendedAppointmentPayload>
/**
 * Model DiscountRule
 * 
 */
export type DiscountRule = $Result.DefaultSelection<Prisma.$DiscountRulePayload>
/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model ServiceSet
 * 
 */
export type ServiceSet = $Result.DefaultSelection<Prisma.$ServiceSetPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Voucher
 * 
 */
export type Voucher = $Result.DefaultSelection<Prisma.$VoucherPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model AvailedService
 * 
 */
export type AvailedService = $Result.DefaultSelection<Prisma.$AvailedServicePayload>
/**
 * Model GiftCertificate
 * 
 */
export type GiftCertificate = $Result.DefaultSelection<Prisma.$GiftCertificatePayload>
/**
 * Model ManualSale
 * 
 */
export type ManualSale = $Result.DefaultSelection<Prisma.$ManualSalePayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model EmailTemplate
 * 
 */
export type EmailTemplate = $Result.DefaultSelection<Prisma.$EmailTemplatePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AvailedItemType: {
  SERVICE: 'SERVICE',
  SET: 'SET'
};

export type AvailedItemType = (typeof AvailedItemType)[keyof typeof AvailedItemType]


export const Role: {
  OWNER: 'OWNER',
  CASHIER: 'CASHIER',
  WORKER: 'WORKER',
  ATTENDANCE_CHECKER: 'ATTENDANCE_CHECKER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const DiscountType: {
  PERCENTAGE: 'PERCENTAGE',
  FIXED_AMOUNT: 'FIXED_AMOUNT'
};

export type DiscountType = (typeof DiscountType)[keyof typeof DiscountType]


export const Status: {
  PENDING: 'PENDING',
  DONE: 'DONE',
  CANCELLED: 'CANCELLED'
};

export type Status = (typeof Status)[keyof typeof Status]


export const PaymentMethod: {
  ewallet: 'ewallet',
  cash: 'cash',
  bank: 'bank',
  GIFT_CERTIFICATE: 'GIFT_CERTIFICATE'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PayslipStatus: {
  PENDING: 'PENDING',
  RELEASED: 'RELEASED'
};

export type PayslipStatus = (typeof PayslipStatus)[keyof typeof PayslipStatus]


export const FollowUpPolicy: {
  NONE: 'NONE',
  ONCE: 'ONCE',
  EVERY_TIME: 'EVERY_TIME'
};

export type FollowUpPolicy = (typeof FollowUpPolicy)[keyof typeof FollowUpPolicy]


export const PayslipRequestStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  PROCESSED: 'PROCESSED',
  FAILED: 'FAILED'
};

export type PayslipRequestStatus = (typeof PayslipRequestStatus)[keyof typeof PayslipRequestStatus]


export const RecommendedAppointmentStatus: {
  RECOMMENDED: 'RECOMMENDED',
  SCHEDULED: 'SCHEDULED',
  ATTENDED: 'ATTENDED',
  CANCELLED: 'CANCELLED',
  MISSED: 'MISSED'
};

export type RecommendedAppointmentStatus = (typeof RecommendedAppointmentStatus)[keyof typeof RecommendedAppointmentStatus]


export const ExpenseCategory: {
  RENT: 'RENT',
  UTILITIES: 'UTILITIES',
  SALARIES: 'SALARIES',
  SUPPLIES: 'SUPPLIES',
  MARKETING: 'MARKETING',
  MAINTENANCE: 'MAINTENANCE',
  OTHER: 'OTHER'
};

export type ExpenseCategory = (typeof ExpenseCategory)[keyof typeof ExpenseCategory]

}

export type AvailedItemType = $Enums.AvailedItemType

export const AvailedItemType: typeof $Enums.AvailedItemType

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type DiscountType = $Enums.DiscountType

export const DiscountType: typeof $Enums.DiscountType

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PayslipStatus = $Enums.PayslipStatus

export const PayslipStatus: typeof $Enums.PayslipStatus

export type FollowUpPolicy = $Enums.FollowUpPolicy

export const FollowUpPolicy: typeof $Enums.FollowUpPolicy

export type PayslipRequestStatus = $Enums.PayslipRequestStatus

export const PayslipRequestStatus: typeof $Enums.PayslipRequestStatus

export type RecommendedAppointmentStatus = $Enums.RecommendedAppointmentStatus

export const RecommendedAppointmentStatus: typeof $Enums.RecommendedAppointmentStatus

export type ExpenseCategory = $Enums.ExpenseCategory

export const ExpenseCategory: typeof $Enums.ExpenseCategory

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more PayslipRequests
 * const payslipRequests = await prisma.payslipRequest.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more PayslipRequests
   * const payslipRequests = await prisma.payslipRequest.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.payslipRequest`: Exposes CRUD operations for the **PayslipRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayslipRequests
    * const payslipRequests = await prisma.payslipRequest.findMany()
    * ```
    */
  get payslipRequest(): Prisma.PayslipRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payslip`: Exposes CRUD operations for the **Payslip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payslips
    * const payslips = await prisma.payslip.findMany()
    * ```
    */
  get payslip(): Prisma.PayslipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recommendedAppointment`: Exposes CRUD operations for the **RecommendedAppointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecommendedAppointments
    * const recommendedAppointments = await prisma.recommendedAppointment.findMany()
    * ```
    */
  get recommendedAppointment(): Prisma.RecommendedAppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discountRule`: Exposes CRUD operations for the **DiscountRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiscountRules
    * const discountRules = await prisma.discountRule.findMany()
    * ```
    */
  get discountRule(): Prisma.DiscountRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceSet`: Exposes CRUD operations for the **ServiceSet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceSets
    * const serviceSets = await prisma.serviceSet.findMany()
    * ```
    */
  get serviceSet(): Prisma.ServiceSetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voucher`: Exposes CRUD operations for the **Voucher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vouchers
    * const vouchers = await prisma.voucher.findMany()
    * ```
    */
  get voucher(): Prisma.VoucherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.availedService`: Exposes CRUD operations for the **AvailedService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AvailedServices
    * const availedServices = await prisma.availedService.findMany()
    * ```
    */
  get availedService(): Prisma.AvailedServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.giftCertificate`: Exposes CRUD operations for the **GiftCertificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GiftCertificates
    * const giftCertificates = await prisma.giftCertificate.findMany()
    * ```
    */
  get giftCertificate(): Prisma.GiftCertificateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manualSale`: Exposes CRUD operations for the **ManualSale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ManualSales
    * const manualSales = await prisma.manualSale.findMany()
    * ```
    */
  get manualSale(): Prisma.ManualSaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailTemplate`: Exposes CRUD operations for the **EmailTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTemplates
    * const emailTemplates = await prisma.emailTemplate.findMany()
    * ```
    */
  get emailTemplate(): Prisma.EmailTemplateDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    PayslipRequest: 'PayslipRequest',
    Payslip: 'Payslip',
    RecommendedAppointment: 'RecommendedAppointment',
    DiscountRule: 'DiscountRule',
    Branch: 'Branch',
    Attendance: 'Attendance',
    Account: 'Account',
    Service: 'Service',
    ServiceSet: 'ServiceSet',
    Customer: 'Customer',
    Voucher: 'Voucher',
    Transaction: 'Transaction',
    AvailedService: 'AvailedService',
    GiftCertificate: 'GiftCertificate',
    ManualSale: 'ManualSale',
    Expense: 'Expense',
    EmailTemplate: 'EmailTemplate'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "payslipRequest" | "payslip" | "recommendedAppointment" | "discountRule" | "branch" | "attendance" | "account" | "service" | "serviceSet" | "customer" | "voucher" | "transaction" | "availedService" | "giftCertificate" | "manualSale" | "expense" | "emailTemplate"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      PayslipRequest: {
        payload: Prisma.$PayslipRequestPayload<ExtArgs>
        fields: Prisma.PayslipRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayslipRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayslipRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipRequestPayload>
          }
          findFirst: {
            args: Prisma.PayslipRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayslipRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipRequestPayload>
          }
          findMany: {
            args: Prisma.PayslipRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipRequestPayload>[]
          }
          create: {
            args: Prisma.PayslipRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipRequestPayload>
          }
          createMany: {
            args: Prisma.PayslipRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayslipRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipRequestPayload>[]
          }
          delete: {
            args: Prisma.PayslipRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipRequestPayload>
          }
          update: {
            args: Prisma.PayslipRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipRequestPayload>
          }
          deleteMany: {
            args: Prisma.PayslipRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayslipRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayslipRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipRequestPayload>[]
          }
          upsert: {
            args: Prisma.PayslipRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipRequestPayload>
          }
          aggregate: {
            args: Prisma.PayslipRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayslipRequest>
          }
          groupBy: {
            args: Prisma.PayslipRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayslipRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayslipRequestCountArgs<ExtArgs>
            result: $Utils.Optional<PayslipRequestCountAggregateOutputType> | number
          }
        }
      }
      Payslip: {
        payload: Prisma.$PayslipPayload<ExtArgs>
        fields: Prisma.PayslipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayslipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayslipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipPayload>
          }
          findFirst: {
            args: Prisma.PayslipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayslipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipPayload>
          }
          findMany: {
            args: Prisma.PayslipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipPayload>[]
          }
          create: {
            args: Prisma.PayslipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipPayload>
          }
          createMany: {
            args: Prisma.PayslipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayslipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipPayload>[]
          }
          delete: {
            args: Prisma.PayslipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipPayload>
          }
          update: {
            args: Prisma.PayslipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipPayload>
          }
          deleteMany: {
            args: Prisma.PayslipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayslipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayslipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipPayload>[]
          }
          upsert: {
            args: Prisma.PayslipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayslipPayload>
          }
          aggregate: {
            args: Prisma.PayslipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayslip>
          }
          groupBy: {
            args: Prisma.PayslipGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayslipGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayslipCountArgs<ExtArgs>
            result: $Utils.Optional<PayslipCountAggregateOutputType> | number
          }
        }
      }
      RecommendedAppointment: {
        payload: Prisma.$RecommendedAppointmentPayload<ExtArgs>
        fields: Prisma.RecommendedAppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecommendedAppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecommendedAppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAppointmentPayload>
          }
          findFirst: {
            args: Prisma.RecommendedAppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecommendedAppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAppointmentPayload>
          }
          findMany: {
            args: Prisma.RecommendedAppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAppointmentPayload>[]
          }
          create: {
            args: Prisma.RecommendedAppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAppointmentPayload>
          }
          createMany: {
            args: Prisma.RecommendedAppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecommendedAppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAppointmentPayload>[]
          }
          delete: {
            args: Prisma.RecommendedAppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAppointmentPayload>
          }
          update: {
            args: Prisma.RecommendedAppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAppointmentPayload>
          }
          deleteMany: {
            args: Prisma.RecommendedAppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecommendedAppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecommendedAppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAppointmentPayload>[]
          }
          upsert: {
            args: Prisma.RecommendedAppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAppointmentPayload>
          }
          aggregate: {
            args: Prisma.RecommendedAppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecommendedAppointment>
          }
          groupBy: {
            args: Prisma.RecommendedAppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecommendedAppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecommendedAppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<RecommendedAppointmentCountAggregateOutputType> | number
          }
        }
      }
      DiscountRule: {
        payload: Prisma.$DiscountRulePayload<ExtArgs>
        fields: Prisma.DiscountRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscountRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscountRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          findFirst: {
            args: Prisma.DiscountRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscountRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          findMany: {
            args: Prisma.DiscountRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>[]
          }
          create: {
            args: Prisma.DiscountRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          createMany: {
            args: Prisma.DiscountRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiscountRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>[]
          }
          delete: {
            args: Prisma.DiscountRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          update: {
            args: Prisma.DiscountRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          deleteMany: {
            args: Prisma.DiscountRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscountRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DiscountRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>[]
          }
          upsert: {
            args: Prisma.DiscountRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          aggregate: {
            args: Prisma.DiscountRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscountRule>
          }
          groupBy: {
            args: Prisma.DiscountRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscountRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiscountRuleCountArgs<ExtArgs>
            result: $Utils.Optional<DiscountRuleCountAggregateOutputType> | number
          }
        }
      }
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BranchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      ServiceSet: {
        payload: Prisma.$ServiceSetPayload<ExtArgs>
        fields: Prisma.ServiceSetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceSetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceSetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSetPayload>
          }
          findFirst: {
            args: Prisma.ServiceSetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceSetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSetPayload>
          }
          findMany: {
            args: Prisma.ServiceSetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSetPayload>[]
          }
          create: {
            args: Prisma.ServiceSetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSetPayload>
          }
          createMany: {
            args: Prisma.ServiceSetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceSetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSetPayload>[]
          }
          delete: {
            args: Prisma.ServiceSetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSetPayload>
          }
          update: {
            args: Prisma.ServiceSetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSetPayload>
          }
          deleteMany: {
            args: Prisma.ServiceSetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceSetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceSetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSetPayload>[]
          }
          upsert: {
            args: Prisma.ServiceSetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSetPayload>
          }
          aggregate: {
            args: Prisma.ServiceSetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceSet>
          }
          groupBy: {
            args: Prisma.ServiceSetGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceSetGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceSetCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceSetCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Voucher: {
        payload: Prisma.$VoucherPayload<ExtArgs>
        fields: Prisma.VoucherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoucherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoucherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findFirst: {
            args: Prisma.VoucherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoucherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findMany: {
            args: Prisma.VoucherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          create: {
            args: Prisma.VoucherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          createMany: {
            args: Prisma.VoucherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoucherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          delete: {
            args: Prisma.VoucherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          update: {
            args: Prisma.VoucherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          deleteMany: {
            args: Prisma.VoucherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoucherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoucherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          upsert: {
            args: Prisma.VoucherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          aggregate: {
            args: Prisma.VoucherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoucher>
          }
          groupBy: {
            args: Prisma.VoucherGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoucherGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoucherCountArgs<ExtArgs>
            result: $Utils.Optional<VoucherCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      AvailedService: {
        payload: Prisma.$AvailedServicePayload<ExtArgs>
        fields: Prisma.AvailedServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvailedServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailedServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvailedServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailedServicePayload>
          }
          findFirst: {
            args: Prisma.AvailedServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailedServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvailedServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailedServicePayload>
          }
          findMany: {
            args: Prisma.AvailedServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailedServicePayload>[]
          }
          create: {
            args: Prisma.AvailedServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailedServicePayload>
          }
          createMany: {
            args: Prisma.AvailedServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AvailedServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailedServicePayload>[]
          }
          delete: {
            args: Prisma.AvailedServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailedServicePayload>
          }
          update: {
            args: Prisma.AvailedServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailedServicePayload>
          }
          deleteMany: {
            args: Prisma.AvailedServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvailedServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AvailedServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailedServicePayload>[]
          }
          upsert: {
            args: Prisma.AvailedServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailedServicePayload>
          }
          aggregate: {
            args: Prisma.AvailedServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvailedService>
          }
          groupBy: {
            args: Prisma.AvailedServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvailedServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvailedServiceCountArgs<ExtArgs>
            result: $Utils.Optional<AvailedServiceCountAggregateOutputType> | number
          }
        }
      }
      GiftCertificate: {
        payload: Prisma.$GiftCertificatePayload<ExtArgs>
        fields: Prisma.GiftCertificateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GiftCertificateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCertificatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GiftCertificateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCertificatePayload>
          }
          findFirst: {
            args: Prisma.GiftCertificateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCertificatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GiftCertificateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCertificatePayload>
          }
          findMany: {
            args: Prisma.GiftCertificateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCertificatePayload>[]
          }
          create: {
            args: Prisma.GiftCertificateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCertificatePayload>
          }
          createMany: {
            args: Prisma.GiftCertificateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GiftCertificateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCertificatePayload>[]
          }
          delete: {
            args: Prisma.GiftCertificateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCertificatePayload>
          }
          update: {
            args: Prisma.GiftCertificateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCertificatePayload>
          }
          deleteMany: {
            args: Prisma.GiftCertificateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GiftCertificateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GiftCertificateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCertificatePayload>[]
          }
          upsert: {
            args: Prisma.GiftCertificateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCertificatePayload>
          }
          aggregate: {
            args: Prisma.GiftCertificateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGiftCertificate>
          }
          groupBy: {
            args: Prisma.GiftCertificateGroupByArgs<ExtArgs>
            result: $Utils.Optional<GiftCertificateGroupByOutputType>[]
          }
          count: {
            args: Prisma.GiftCertificateCountArgs<ExtArgs>
            result: $Utils.Optional<GiftCertificateCountAggregateOutputType> | number
          }
        }
      }
      ManualSale: {
        payload: Prisma.$ManualSalePayload<ExtArgs>
        fields: Prisma.ManualSaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManualSaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualSalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManualSaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualSalePayload>
          }
          findFirst: {
            args: Prisma.ManualSaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualSalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManualSaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualSalePayload>
          }
          findMany: {
            args: Prisma.ManualSaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualSalePayload>[]
          }
          create: {
            args: Prisma.ManualSaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualSalePayload>
          }
          createMany: {
            args: Prisma.ManualSaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ManualSaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualSalePayload>[]
          }
          delete: {
            args: Prisma.ManualSaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualSalePayload>
          }
          update: {
            args: Prisma.ManualSaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualSalePayload>
          }
          deleteMany: {
            args: Prisma.ManualSaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManualSaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ManualSaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualSalePayload>[]
          }
          upsert: {
            args: Prisma.ManualSaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualSalePayload>
          }
          aggregate: {
            args: Prisma.ManualSaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManualSale>
          }
          groupBy: {
            args: Prisma.ManualSaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManualSaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManualSaleCountArgs<ExtArgs>
            result: $Utils.Optional<ManualSaleCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      EmailTemplate: {
        payload: Prisma.$EmailTemplatePayload<ExtArgs>
        fields: Prisma.EmailTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findFirst: {
            args: Prisma.EmailTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findMany: {
            args: Prisma.EmailTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          create: {
            args: Prisma.EmailTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          createMany: {
            args: Prisma.EmailTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          delete: {
            args: Prisma.EmailTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          update: {
            args: Prisma.EmailTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          deleteMany: {
            args: Prisma.EmailTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          upsert: {
            args: Prisma.EmailTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          aggregate: {
            args: Prisma.EmailTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailTemplate>
          }
          groupBy: {
            args: Prisma.EmailTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    payslipRequest?: PayslipRequestOmit
    payslip?: PayslipOmit
    recommendedAppointment?: RecommendedAppointmentOmit
    discountRule?: DiscountRuleOmit
    branch?: BranchOmit
    attendance?: AttendanceOmit
    account?: AccountOmit
    service?: ServiceOmit
    serviceSet?: ServiceSetOmit
    customer?: CustomerOmit
    voucher?: VoucherOmit
    transaction?: TransactionOmit
    availedService?: AvailedServiceOmit
    giftCertificate?: GiftCertificateOmit
    manualSale?: ManualSaleOmit
    expense?: ExpenseOmit
    emailTemplate?: EmailTemplateOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type DiscountRuleCountOutputType
   */

  export type DiscountRuleCountOutputType = {
    services: number
  }

  export type DiscountRuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | DiscountRuleCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * DiscountRuleCountOutputType without action
   */
  export type DiscountRuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRuleCountOutputType
     */
    select?: DiscountRuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DiscountRuleCountOutputType without action
   */
  export type DiscountRuleCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    services: number
    accounts: number
    manualSales: number
    expenses: number
    Transaction: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | BranchCountOutputTypeCountServicesArgs
    accounts?: boolean | BranchCountOutputTypeCountAccountsArgs
    manualSales?: boolean | BranchCountOutputTypeCountManualSalesArgs
    expenses?: boolean | BranchCountOutputTypeCountExpensesArgs
    Transaction?: boolean | BranchCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountManualSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManualSaleWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    servicesServed: number
    servicesChecked: number
    attendances: number
    attendancesChecked: number
    payslips: number
    payslipRequests: number
    managedPayslipRequests: number
    manualSales: number
    expenses: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicesServed?: boolean | AccountCountOutputTypeCountServicesServedArgs
    servicesChecked?: boolean | AccountCountOutputTypeCountServicesCheckedArgs
    attendances?: boolean | AccountCountOutputTypeCountAttendancesArgs
    attendancesChecked?: boolean | AccountCountOutputTypeCountAttendancesCheckedArgs
    payslips?: boolean | AccountCountOutputTypeCountPayslipsArgs
    payslipRequests?: boolean | AccountCountOutputTypeCountPayslipRequestsArgs
    managedPayslipRequests?: boolean | AccountCountOutputTypeCountManagedPayslipRequestsArgs
    manualSales?: boolean | AccountCountOutputTypeCountManualSalesArgs
    expenses?: boolean | AccountCountOutputTypeCountExpensesArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountServicesServedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailedServiceWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountServicesCheckedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailedServiceWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountAttendancesCheckedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountPayslipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayslipWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountPayslipRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayslipRequestWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountManagedPayslipRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayslipRequestWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountManualSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManualSaleWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    AvailedService: number
    serviceSets: number
    giftCertificates: number
    discountRules: number
    recommendedAppointments: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AvailedService?: boolean | ServiceCountOutputTypeCountAvailedServiceArgs
    serviceSets?: boolean | ServiceCountOutputTypeCountServiceSetsArgs
    giftCertificates?: boolean | ServiceCountOutputTypeCountGiftCertificatesArgs
    discountRules?: boolean | ServiceCountOutputTypeCountDiscountRulesArgs
    recommendedAppointments?: boolean | ServiceCountOutputTypeCountRecommendedAppointmentsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountAvailedServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailedServiceWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountServiceSetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceSetWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountGiftCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GiftCertificateWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountDiscountRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountRuleWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountRecommendedAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecommendedAppointmentWhereInput
  }


  /**
   * Count Type ServiceSetCountOutputType
   */

  export type ServiceSetCountOutputType = {
    services: number
    giftCertificates: number
    AvailedService: number
  }

  export type ServiceSetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceSetCountOutputTypeCountServicesArgs
    giftCertificates?: boolean | ServiceSetCountOutputTypeCountGiftCertificatesArgs
    AvailedService?: boolean | ServiceSetCountOutputTypeCountAvailedServiceArgs
  }

  // Custom InputTypes
  /**
   * ServiceSetCountOutputType without action
   */
  export type ServiceSetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSetCountOutputType
     */
    select?: ServiceSetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceSetCountOutputType without action
   */
  export type ServiceSetCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * ServiceSetCountOutputType without action
   */
  export type ServiceSetCountOutputTypeCountGiftCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GiftCertificateWhereInput
  }

  /**
   * ServiceSetCountOutputType without action
   */
  export type ServiceSetCountOutputTypeCountAvailedServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailedServiceWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    recommendedAppointments: number
    transactionHistory: number
    purchasedGiftCertificates: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recommendedAppointments?: boolean | CustomerCountOutputTypeCountRecommendedAppointmentsArgs
    transactionHistory?: boolean | CustomerCountOutputTypeCountTransactionHistoryArgs
    purchasedGiftCertificates?: boolean | CustomerCountOutputTypeCountPurchasedGiftCertificatesArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountRecommendedAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecommendedAppointmentWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountTransactionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPurchasedGiftCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GiftCertificateWhereInput
  }


  /**
   * Count Type VoucherCountOutputType
   */

  export type VoucherCountOutputType = {
    Transaction: number
  }

  export type VoucherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Transaction?: boolean | VoucherCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherCountOutputType
     */
    select?: VoucherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type TransactionCountOutputType
   */

  export type TransactionCountOutputType = {
    availedServices: number
    originatingRecommendations: number
  }

  export type TransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    availedServices?: boolean | TransactionCountOutputTypeCountAvailedServicesArgs
    originatingRecommendations?: boolean | TransactionCountOutputTypeCountOriginatingRecommendationsArgs
  }

  // Custom InputTypes
  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCountOutputType
     */
    select?: TransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountAvailedServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailedServiceWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountOriginatingRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecommendedAppointmentWhereInput
  }


  /**
   * Count Type GiftCertificateCountOutputType
   */

  export type GiftCertificateCountOutputType = {
    services: number
    serviceSets: number
    transactions: number
  }

  export type GiftCertificateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | GiftCertificateCountOutputTypeCountServicesArgs
    serviceSets?: boolean | GiftCertificateCountOutputTypeCountServiceSetsArgs
    transactions?: boolean | GiftCertificateCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * GiftCertificateCountOutputType without action
   */
  export type GiftCertificateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCertificateCountOutputType
     */
    select?: GiftCertificateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GiftCertificateCountOutputType without action
   */
  export type GiftCertificateCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * GiftCertificateCountOutputType without action
   */
  export type GiftCertificateCountOutputTypeCountServiceSetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceSetWhereInput
  }

  /**
   * GiftCertificateCountOutputType without action
   */
  export type GiftCertificateCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model PayslipRequest
   */

  export type AggregatePayslipRequest = {
    _count: PayslipRequestCountAggregateOutputType | null
    _min: PayslipRequestMinAggregateOutputType | null
    _max: PayslipRequestMaxAggregateOutputType | null
  }

  export type PayslipRequestMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    requestTimestamp: Date | null
    periodStartDate: Date | null
    periodEndDate: Date | null
    status: $Enums.PayslipRequestStatus | null
    notes: string | null
    processedById: string | null
    processedTimestamp: Date | null
    relatedPayslipId: string | null
  }

  export type PayslipRequestMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    requestTimestamp: Date | null
    periodStartDate: Date | null
    periodEndDate: Date | null
    status: $Enums.PayslipRequestStatus | null
    notes: string | null
    processedById: string | null
    processedTimestamp: Date | null
    relatedPayslipId: string | null
  }

  export type PayslipRequestCountAggregateOutputType = {
    id: number
    accountId: number
    requestTimestamp: number
    periodStartDate: number
    periodEndDate: number
    status: number
    notes: number
    processedById: number
    processedTimestamp: number
    relatedPayslipId: number
    _all: number
  }


  export type PayslipRequestMinAggregateInputType = {
    id?: true
    accountId?: true
    requestTimestamp?: true
    periodStartDate?: true
    periodEndDate?: true
    status?: true
    notes?: true
    processedById?: true
    processedTimestamp?: true
    relatedPayslipId?: true
  }

  export type PayslipRequestMaxAggregateInputType = {
    id?: true
    accountId?: true
    requestTimestamp?: true
    periodStartDate?: true
    periodEndDate?: true
    status?: true
    notes?: true
    processedById?: true
    processedTimestamp?: true
    relatedPayslipId?: true
  }

  export type PayslipRequestCountAggregateInputType = {
    id?: true
    accountId?: true
    requestTimestamp?: true
    periodStartDate?: true
    periodEndDate?: true
    status?: true
    notes?: true
    processedById?: true
    processedTimestamp?: true
    relatedPayslipId?: true
    _all?: true
  }

  export type PayslipRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayslipRequest to aggregate.
     */
    where?: PayslipRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayslipRequests to fetch.
     */
    orderBy?: PayslipRequestOrderByWithRelationInput | PayslipRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayslipRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayslipRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayslipRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayslipRequests
    **/
    _count?: true | PayslipRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayslipRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayslipRequestMaxAggregateInputType
  }

  export type GetPayslipRequestAggregateType<T extends PayslipRequestAggregateArgs> = {
        [P in keyof T & keyof AggregatePayslipRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayslipRequest[P]>
      : GetScalarType<T[P], AggregatePayslipRequest[P]>
  }




  export type PayslipRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayslipRequestWhereInput
    orderBy?: PayslipRequestOrderByWithAggregationInput | PayslipRequestOrderByWithAggregationInput[]
    by: PayslipRequestScalarFieldEnum[] | PayslipRequestScalarFieldEnum
    having?: PayslipRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayslipRequestCountAggregateInputType | true
    _min?: PayslipRequestMinAggregateInputType
    _max?: PayslipRequestMaxAggregateInputType
  }

  export type PayslipRequestGroupByOutputType = {
    id: string
    accountId: string
    requestTimestamp: Date
    periodStartDate: Date
    periodEndDate: Date
    status: $Enums.PayslipRequestStatus
    notes: string | null
    processedById: string | null
    processedTimestamp: Date | null
    relatedPayslipId: string | null
    _count: PayslipRequestCountAggregateOutputType | null
    _min: PayslipRequestMinAggregateOutputType | null
    _max: PayslipRequestMaxAggregateOutputType | null
  }

  type GetPayslipRequestGroupByPayload<T extends PayslipRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayslipRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayslipRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayslipRequestGroupByOutputType[P]>
            : GetScalarType<T[P], PayslipRequestGroupByOutputType[P]>
        }
      >
    >


  export type PayslipRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    requestTimestamp?: boolean
    periodStartDate?: boolean
    periodEndDate?: boolean
    status?: boolean
    notes?: boolean
    processedById?: boolean
    processedTimestamp?: boolean
    relatedPayslipId?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    processedBy?: boolean | PayslipRequest$processedByArgs<ExtArgs>
    relatedPayslip?: boolean | PayslipRequest$relatedPayslipArgs<ExtArgs>
  }, ExtArgs["result"]["payslipRequest"]>

  export type PayslipRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    requestTimestamp?: boolean
    periodStartDate?: boolean
    periodEndDate?: boolean
    status?: boolean
    notes?: boolean
    processedById?: boolean
    processedTimestamp?: boolean
    relatedPayslipId?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    processedBy?: boolean | PayslipRequest$processedByArgs<ExtArgs>
    relatedPayslip?: boolean | PayslipRequest$relatedPayslipArgs<ExtArgs>
  }, ExtArgs["result"]["payslipRequest"]>

  export type PayslipRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    requestTimestamp?: boolean
    periodStartDate?: boolean
    periodEndDate?: boolean
    status?: boolean
    notes?: boolean
    processedById?: boolean
    processedTimestamp?: boolean
    relatedPayslipId?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    processedBy?: boolean | PayslipRequest$processedByArgs<ExtArgs>
    relatedPayslip?: boolean | PayslipRequest$relatedPayslipArgs<ExtArgs>
  }, ExtArgs["result"]["payslipRequest"]>

  export type PayslipRequestSelectScalar = {
    id?: boolean
    accountId?: boolean
    requestTimestamp?: boolean
    periodStartDate?: boolean
    periodEndDate?: boolean
    status?: boolean
    notes?: boolean
    processedById?: boolean
    processedTimestamp?: boolean
    relatedPayslipId?: boolean
  }

  export type PayslipRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "requestTimestamp" | "periodStartDate" | "periodEndDate" | "status" | "notes" | "processedById" | "processedTimestamp" | "relatedPayslipId", ExtArgs["result"]["payslipRequest"]>
  export type PayslipRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    processedBy?: boolean | PayslipRequest$processedByArgs<ExtArgs>
    relatedPayslip?: boolean | PayslipRequest$relatedPayslipArgs<ExtArgs>
  }
  export type PayslipRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    processedBy?: boolean | PayslipRequest$processedByArgs<ExtArgs>
    relatedPayslip?: boolean | PayslipRequest$relatedPayslipArgs<ExtArgs>
  }
  export type PayslipRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    processedBy?: boolean | PayslipRequest$processedByArgs<ExtArgs>
    relatedPayslip?: boolean | PayslipRequest$relatedPayslipArgs<ExtArgs>
  }

  export type $PayslipRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PayslipRequest"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      processedBy: Prisma.$AccountPayload<ExtArgs> | null
      relatedPayslip: Prisma.$PayslipPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      requestTimestamp: Date
      periodStartDate: Date
      periodEndDate: Date
      status: $Enums.PayslipRequestStatus
      notes: string | null
      processedById: string | null
      processedTimestamp: Date | null
      relatedPayslipId: string | null
    }, ExtArgs["result"]["payslipRequest"]>
    composites: {}
  }

  type PayslipRequestGetPayload<S extends boolean | null | undefined | PayslipRequestDefaultArgs> = $Result.GetResult<Prisma.$PayslipRequestPayload, S>

  type PayslipRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayslipRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayslipRequestCountAggregateInputType | true
    }

  export interface PayslipRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PayslipRequest'], meta: { name: 'PayslipRequest' } }
    /**
     * Find zero or one PayslipRequest that matches the filter.
     * @param {PayslipRequestFindUniqueArgs} args - Arguments to find a PayslipRequest
     * @example
     * // Get one PayslipRequest
     * const payslipRequest = await prisma.payslipRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayslipRequestFindUniqueArgs>(args: SelectSubset<T, PayslipRequestFindUniqueArgs<ExtArgs>>): Prisma__PayslipRequestClient<$Result.GetResult<Prisma.$PayslipRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PayslipRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayslipRequestFindUniqueOrThrowArgs} args - Arguments to find a PayslipRequest
     * @example
     * // Get one PayslipRequest
     * const payslipRequest = await prisma.payslipRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayslipRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, PayslipRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayslipRequestClient<$Result.GetResult<Prisma.$PayslipRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayslipRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayslipRequestFindFirstArgs} args - Arguments to find a PayslipRequest
     * @example
     * // Get one PayslipRequest
     * const payslipRequest = await prisma.payslipRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayslipRequestFindFirstArgs>(args?: SelectSubset<T, PayslipRequestFindFirstArgs<ExtArgs>>): Prisma__PayslipRequestClient<$Result.GetResult<Prisma.$PayslipRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayslipRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayslipRequestFindFirstOrThrowArgs} args - Arguments to find a PayslipRequest
     * @example
     * // Get one PayslipRequest
     * const payslipRequest = await prisma.payslipRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayslipRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, PayslipRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayslipRequestClient<$Result.GetResult<Prisma.$PayslipRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PayslipRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayslipRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayslipRequests
     * const payslipRequests = await prisma.payslipRequest.findMany()
     * 
     * // Get first 10 PayslipRequests
     * const payslipRequests = await prisma.payslipRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payslipRequestWithIdOnly = await prisma.payslipRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayslipRequestFindManyArgs>(args?: SelectSubset<T, PayslipRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayslipRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PayslipRequest.
     * @param {PayslipRequestCreateArgs} args - Arguments to create a PayslipRequest.
     * @example
     * // Create one PayslipRequest
     * const PayslipRequest = await prisma.payslipRequest.create({
     *   data: {
     *     // ... data to create a PayslipRequest
     *   }
     * })
     * 
     */
    create<T extends PayslipRequestCreateArgs>(args: SelectSubset<T, PayslipRequestCreateArgs<ExtArgs>>): Prisma__PayslipRequestClient<$Result.GetResult<Prisma.$PayslipRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PayslipRequests.
     * @param {PayslipRequestCreateManyArgs} args - Arguments to create many PayslipRequests.
     * @example
     * // Create many PayslipRequests
     * const payslipRequest = await prisma.payslipRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayslipRequestCreateManyArgs>(args?: SelectSubset<T, PayslipRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PayslipRequests and returns the data saved in the database.
     * @param {PayslipRequestCreateManyAndReturnArgs} args - Arguments to create many PayslipRequests.
     * @example
     * // Create many PayslipRequests
     * const payslipRequest = await prisma.payslipRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PayslipRequests and only return the `id`
     * const payslipRequestWithIdOnly = await prisma.payslipRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayslipRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, PayslipRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayslipRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PayslipRequest.
     * @param {PayslipRequestDeleteArgs} args - Arguments to delete one PayslipRequest.
     * @example
     * // Delete one PayslipRequest
     * const PayslipRequest = await prisma.payslipRequest.delete({
     *   where: {
     *     // ... filter to delete one PayslipRequest
     *   }
     * })
     * 
     */
    delete<T extends PayslipRequestDeleteArgs>(args: SelectSubset<T, PayslipRequestDeleteArgs<ExtArgs>>): Prisma__PayslipRequestClient<$Result.GetResult<Prisma.$PayslipRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PayslipRequest.
     * @param {PayslipRequestUpdateArgs} args - Arguments to update one PayslipRequest.
     * @example
     * // Update one PayslipRequest
     * const payslipRequest = await prisma.payslipRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayslipRequestUpdateArgs>(args: SelectSubset<T, PayslipRequestUpdateArgs<ExtArgs>>): Prisma__PayslipRequestClient<$Result.GetResult<Prisma.$PayslipRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PayslipRequests.
     * @param {PayslipRequestDeleteManyArgs} args - Arguments to filter PayslipRequests to delete.
     * @example
     * // Delete a few PayslipRequests
     * const { count } = await prisma.payslipRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayslipRequestDeleteManyArgs>(args?: SelectSubset<T, PayslipRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayslipRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayslipRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayslipRequests
     * const payslipRequest = await prisma.payslipRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayslipRequestUpdateManyArgs>(args: SelectSubset<T, PayslipRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayslipRequests and returns the data updated in the database.
     * @param {PayslipRequestUpdateManyAndReturnArgs} args - Arguments to update many PayslipRequests.
     * @example
     * // Update many PayslipRequests
     * const payslipRequest = await prisma.payslipRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PayslipRequests and only return the `id`
     * const payslipRequestWithIdOnly = await prisma.payslipRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayslipRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, PayslipRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayslipRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PayslipRequest.
     * @param {PayslipRequestUpsertArgs} args - Arguments to update or create a PayslipRequest.
     * @example
     * // Update or create a PayslipRequest
     * const payslipRequest = await prisma.payslipRequest.upsert({
     *   create: {
     *     // ... data to create a PayslipRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayslipRequest we want to update
     *   }
     * })
     */
    upsert<T extends PayslipRequestUpsertArgs>(args: SelectSubset<T, PayslipRequestUpsertArgs<ExtArgs>>): Prisma__PayslipRequestClient<$Result.GetResult<Prisma.$PayslipRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PayslipRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayslipRequestCountArgs} args - Arguments to filter PayslipRequests to count.
     * @example
     * // Count the number of PayslipRequests
     * const count = await prisma.payslipRequest.count({
     *   where: {
     *     // ... the filter for the PayslipRequests we want to count
     *   }
     * })
    **/
    count<T extends PayslipRequestCountArgs>(
      args?: Subset<T, PayslipRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayslipRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayslipRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayslipRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayslipRequestAggregateArgs>(args: Subset<T, PayslipRequestAggregateArgs>): Prisma.PrismaPromise<GetPayslipRequestAggregateType<T>>

    /**
     * Group by PayslipRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayslipRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayslipRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayslipRequestGroupByArgs['orderBy'] }
        : { orderBy?: PayslipRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayslipRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayslipRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PayslipRequest model
   */
  readonly fields: PayslipRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PayslipRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayslipRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    processedBy<T extends PayslipRequest$processedByArgs<ExtArgs> = {}>(args?: Subset<T, PayslipRequest$processedByArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    relatedPayslip<T extends PayslipRequest$relatedPayslipArgs<ExtArgs> = {}>(args?: Subset<T, PayslipRequest$relatedPayslipArgs<ExtArgs>>): Prisma__PayslipClient<$Result.GetResult<Prisma.$PayslipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PayslipRequest model
   */
  interface PayslipRequestFieldRefs {
    readonly id: FieldRef<"PayslipRequest", 'String'>
    readonly accountId: FieldRef<"PayslipRequest", 'String'>
    readonly requestTimestamp: FieldRef<"PayslipRequest", 'DateTime'>
    readonly periodStartDate: FieldRef<"PayslipRequest", 'DateTime'>
    readonly periodEndDate: FieldRef<"PayslipRequest", 'DateTime'>
    readonly status: FieldRef<"PayslipRequest", 'PayslipRequestStatus'>
    readonly notes: FieldRef<"PayslipRequest", 'String'>
    readonly processedById: FieldRef<"PayslipRequest", 'String'>
    readonly processedTimestamp: FieldRef<"PayslipRequest", 'DateTime'>
    readonly relatedPayslipId: FieldRef<"PayslipRequest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PayslipRequest findUnique
   */
  export type PayslipRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayslipRequest
     */
    select?: PayslipRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayslipRequest
     */
    omit?: PayslipRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipRequestInclude<ExtArgs> | null
    /**
     * Filter, which PayslipRequest to fetch.
     */
    where: PayslipRequestWhereUniqueInput
  }

  /**
   * PayslipRequest findUniqueOrThrow
   */
  export type PayslipRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayslipRequest
     */
    select?: PayslipRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayslipRequest
     */
    omit?: PayslipRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipRequestInclude<ExtArgs> | null
    /**
     * Filter, which PayslipRequest to fetch.
     */
    where: PayslipRequestWhereUniqueInput
  }

  /**
   * PayslipRequest findFirst
   */
  export type PayslipRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayslipRequest
     */
    select?: PayslipRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayslipRequest
     */
    omit?: PayslipRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipRequestInclude<ExtArgs> | null
    /**
     * Filter, which PayslipRequest to fetch.
     */
    where?: PayslipRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayslipRequests to fetch.
     */
    orderBy?: PayslipRequestOrderByWithRelationInput | PayslipRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayslipRequests.
     */
    cursor?: PayslipRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayslipRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayslipRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayslipRequests.
     */
    distinct?: PayslipRequestScalarFieldEnum | PayslipRequestScalarFieldEnum[]
  }

  /**
   * PayslipRequest findFirstOrThrow
   */
  export type PayslipRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayslipRequest
     */
    select?: PayslipRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayslipRequest
     */
    omit?: PayslipRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipRequestInclude<ExtArgs> | null
    /**
     * Filter, which PayslipRequest to fetch.
     */
    where?: PayslipRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayslipRequests to fetch.
     */
    orderBy?: PayslipRequestOrderByWithRelationInput | PayslipRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayslipRequests.
     */
    cursor?: PayslipRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayslipRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayslipRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayslipRequests.
     */
    distinct?: PayslipRequestScalarFieldEnum | PayslipRequestScalarFieldEnum[]
  }

  /**
   * PayslipRequest findMany
   */
  export type PayslipRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayslipRequest
     */
    select?: PayslipRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayslipRequest
     */
    omit?: PayslipRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipRequestInclude<ExtArgs> | null
    /**
     * Filter, which PayslipRequests to fetch.
     */
    where?: PayslipRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayslipRequests to fetch.
     */
    orderBy?: PayslipRequestOrderByWithRelationInput | PayslipRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayslipRequests.
     */
    cursor?: PayslipRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayslipRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayslipRequests.
     */
    skip?: number
    distinct?: PayslipRequestScalarFieldEnum | PayslipRequestScalarFieldEnum[]
  }

  /**
   * PayslipRequest create
   */
  export type PayslipRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayslipRequest
     */
    select?: PayslipRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayslipRequest
     */
    omit?: PayslipRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a PayslipRequest.
     */
    data: XOR<PayslipRequestCreateInput, PayslipRequestUncheckedCreateInput>
  }

  /**
   * PayslipRequest createMany
   */
  export type PayslipRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PayslipRequests.
     */
    data: PayslipRequestCreateManyInput | PayslipRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PayslipRequest createManyAndReturn
   */
  export type PayslipRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayslipRequest
     */
    select?: PayslipRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayslipRequest
     */
    omit?: PayslipRequestOmit<ExtArgs> | null
    /**
     * The data used to create many PayslipRequests.
     */
    data: PayslipRequestCreateManyInput | PayslipRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayslipRequest update
   */
  export type PayslipRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayslipRequest
     */
    select?: PayslipRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayslipRequest
     */
    omit?: PayslipRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a PayslipRequest.
     */
    data: XOR<PayslipRequestUpdateInput, PayslipRequestUncheckedUpdateInput>
    /**
     * Choose, which PayslipRequest to update.
     */
    where: PayslipRequestWhereUniqueInput
  }

  /**
   * PayslipRequest updateMany
   */
  export type PayslipRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PayslipRequests.
     */
    data: XOR<PayslipRequestUpdateManyMutationInput, PayslipRequestUncheckedUpdateManyInput>
    /**
     * Filter which PayslipRequests to update
     */
    where?: PayslipRequestWhereInput
    /**
     * Limit how many PayslipRequests to update.
     */
    limit?: number
  }

  /**
   * PayslipRequest updateManyAndReturn
   */
  export type PayslipRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayslipRequest
     */
    select?: PayslipRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayslipRequest
     */
    omit?: PayslipRequestOmit<ExtArgs> | null
    /**
     * The data used to update PayslipRequests.
     */
    data: XOR<PayslipRequestUpdateManyMutationInput, PayslipRequestUncheckedUpdateManyInput>
    /**
     * Filter which PayslipRequests to update
     */
    where?: PayslipRequestWhereInput
    /**
     * Limit how many PayslipRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayslipRequest upsert
   */
  export type PayslipRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayslipRequest
     */
    select?: PayslipRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayslipRequest
     */
    omit?: PayslipRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the PayslipRequest to update in case it exists.
     */
    where: PayslipRequestWhereUniqueInput
    /**
     * In case the PayslipRequest found by the `where` argument doesn't exist, create a new PayslipRequest with this data.
     */
    create: XOR<PayslipRequestCreateInput, PayslipRequestUncheckedCreateInput>
    /**
     * In case the PayslipRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayslipRequestUpdateInput, PayslipRequestUncheckedUpdateInput>
  }

  /**
   * PayslipRequest delete
   */
  export type PayslipRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayslipRequest
     */
    select?: PayslipRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayslipRequest
     */
    omit?: PayslipRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipRequestInclude<ExtArgs> | null
    /**
     * Filter which PayslipRequest to delete.
     */
    where: PayslipRequestWhereUniqueInput
  }

  /**
   * PayslipRequest deleteMany
   */
  export type PayslipRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayslipRequests to delete
     */
    where?: PayslipRequestWhereInput
    /**
     * Limit how many PayslipRequests to delete.
     */
    limit?: number
  }

  /**
   * PayslipRequest.processedBy
   */
  export type PayslipRequest$processedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * PayslipRequest.relatedPayslip
   */
  export type PayslipRequest$relatedPayslipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payslip
     */
    select?: PayslipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payslip
     */
    omit?: PayslipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipInclude<ExtArgs> | null
    where?: PayslipWhereInput
  }

  /**
   * PayslipRequest without action
   */
  export type PayslipRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayslipRequest
     */
    select?: PayslipRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayslipRequest
     */
    omit?: PayslipRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipRequestInclude<ExtArgs> | null
  }


  /**
   * Model Payslip
   */

  export type AggregatePayslip = {
    _count: PayslipCountAggregateOutputType | null
    _avg: PayslipAvgAggregateOutputType | null
    _sum: PayslipSumAggregateOutputType | null
    _min: PayslipMinAggregateOutputType | null
    _max: PayslipMaxAggregateOutputType | null
  }

  export type PayslipAvgAggregateOutputType = {
    baseSalary: number | null
    totalCommissions: number | null
    totalDeductions: number | null
    totalBonuses: number | null
    netPay: number | null
  }

  export type PayslipSumAggregateOutputType = {
    baseSalary: number | null
    totalCommissions: number | null
    totalDeductions: number | null
    totalBonuses: number | null
    netPay: number | null
  }

  export type PayslipMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    periodStartDate: Date | null
    periodEndDate: Date | null
    baseSalary: number | null
    totalCommissions: number | null
    totalDeductions: number | null
    totalBonuses: number | null
    netPay: number | null
    status: $Enums.PayslipStatus | null
    releasedDate: Date | null
    generatedAt: Date | null
  }

  export type PayslipMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    periodStartDate: Date | null
    periodEndDate: Date | null
    baseSalary: number | null
    totalCommissions: number | null
    totalDeductions: number | null
    totalBonuses: number | null
    netPay: number | null
    status: $Enums.PayslipStatus | null
    releasedDate: Date | null
    generatedAt: Date | null
  }

  export type PayslipCountAggregateOutputType = {
    id: number
    accountId: number
    periodStartDate: number
    periodEndDate: number
    baseSalary: number
    totalCommissions: number
    totalDeductions: number
    totalBonuses: number
    netPay: number
    status: number
    releasedDate: number
    generatedAt: number
    _all: number
  }


  export type PayslipAvgAggregateInputType = {
    baseSalary?: true
    totalCommissions?: true
    totalDeductions?: true
    totalBonuses?: true
    netPay?: true
  }

  export type PayslipSumAggregateInputType = {
    baseSalary?: true
    totalCommissions?: true
    totalDeductions?: true
    totalBonuses?: true
    netPay?: true
  }

  export type PayslipMinAggregateInputType = {
    id?: true
    accountId?: true
    periodStartDate?: true
    periodEndDate?: true
    baseSalary?: true
    totalCommissions?: true
    totalDeductions?: true
    totalBonuses?: true
    netPay?: true
    status?: true
    releasedDate?: true
    generatedAt?: true
  }

  export type PayslipMaxAggregateInputType = {
    id?: true
    accountId?: true
    periodStartDate?: true
    periodEndDate?: true
    baseSalary?: true
    totalCommissions?: true
    totalDeductions?: true
    totalBonuses?: true
    netPay?: true
    status?: true
    releasedDate?: true
    generatedAt?: true
  }

  export type PayslipCountAggregateInputType = {
    id?: true
    accountId?: true
    periodStartDate?: true
    periodEndDate?: true
    baseSalary?: true
    totalCommissions?: true
    totalDeductions?: true
    totalBonuses?: true
    netPay?: true
    status?: true
    releasedDate?: true
    generatedAt?: true
    _all?: true
  }

  export type PayslipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payslip to aggregate.
     */
    where?: PayslipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payslips to fetch.
     */
    orderBy?: PayslipOrderByWithRelationInput | PayslipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayslipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payslips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payslips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payslips
    **/
    _count?: true | PayslipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayslipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayslipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayslipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayslipMaxAggregateInputType
  }

  export type GetPayslipAggregateType<T extends PayslipAggregateArgs> = {
        [P in keyof T & keyof AggregatePayslip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayslip[P]>
      : GetScalarType<T[P], AggregatePayslip[P]>
  }




  export type PayslipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayslipWhereInput
    orderBy?: PayslipOrderByWithAggregationInput | PayslipOrderByWithAggregationInput[]
    by: PayslipScalarFieldEnum[] | PayslipScalarFieldEnum
    having?: PayslipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayslipCountAggregateInputType | true
    _avg?: PayslipAvgAggregateInputType
    _sum?: PayslipSumAggregateInputType
    _min?: PayslipMinAggregateInputType
    _max?: PayslipMaxAggregateInputType
  }

  export type PayslipGroupByOutputType = {
    id: string
    accountId: string
    periodStartDate: Date
    periodEndDate: Date
    baseSalary: number
    totalCommissions: number
    totalDeductions: number
    totalBonuses: number
    netPay: number
    status: $Enums.PayslipStatus
    releasedDate: Date | null
    generatedAt: Date
    _count: PayslipCountAggregateOutputType | null
    _avg: PayslipAvgAggregateOutputType | null
    _sum: PayslipSumAggregateOutputType | null
    _min: PayslipMinAggregateOutputType | null
    _max: PayslipMaxAggregateOutputType | null
  }

  type GetPayslipGroupByPayload<T extends PayslipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayslipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayslipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayslipGroupByOutputType[P]>
            : GetScalarType<T[P], PayslipGroupByOutputType[P]>
        }
      >
    >


  export type PayslipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    periodStartDate?: boolean
    periodEndDate?: boolean
    baseSalary?: boolean
    totalCommissions?: boolean
    totalDeductions?: boolean
    totalBonuses?: boolean
    netPay?: boolean
    status?: boolean
    releasedDate?: boolean
    generatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    payslipRequest?: boolean | Payslip$payslipRequestArgs<ExtArgs>
  }, ExtArgs["result"]["payslip"]>

  export type PayslipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    periodStartDate?: boolean
    periodEndDate?: boolean
    baseSalary?: boolean
    totalCommissions?: boolean
    totalDeductions?: boolean
    totalBonuses?: boolean
    netPay?: boolean
    status?: boolean
    releasedDate?: boolean
    generatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payslip"]>

  export type PayslipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    periodStartDate?: boolean
    periodEndDate?: boolean
    baseSalary?: boolean
    totalCommissions?: boolean
    totalDeductions?: boolean
    totalBonuses?: boolean
    netPay?: boolean
    status?: boolean
    releasedDate?: boolean
    generatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payslip"]>

  export type PayslipSelectScalar = {
    id?: boolean
    accountId?: boolean
    periodStartDate?: boolean
    periodEndDate?: boolean
    baseSalary?: boolean
    totalCommissions?: boolean
    totalDeductions?: boolean
    totalBonuses?: boolean
    netPay?: boolean
    status?: boolean
    releasedDate?: boolean
    generatedAt?: boolean
  }

  export type PayslipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "periodStartDate" | "periodEndDate" | "baseSalary" | "totalCommissions" | "totalDeductions" | "totalBonuses" | "netPay" | "status" | "releasedDate" | "generatedAt", ExtArgs["result"]["payslip"]>
  export type PayslipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    payslipRequest?: boolean | Payslip$payslipRequestArgs<ExtArgs>
  }
  export type PayslipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type PayslipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $PayslipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payslip"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      payslipRequest: Prisma.$PayslipRequestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      periodStartDate: Date
      periodEndDate: Date
      baseSalary: number
      totalCommissions: number
      totalDeductions: number
      totalBonuses: number
      netPay: number
      status: $Enums.PayslipStatus
      releasedDate: Date | null
      generatedAt: Date
    }, ExtArgs["result"]["payslip"]>
    composites: {}
  }

  type PayslipGetPayload<S extends boolean | null | undefined | PayslipDefaultArgs> = $Result.GetResult<Prisma.$PayslipPayload, S>

  type PayslipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayslipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayslipCountAggregateInputType | true
    }

  export interface PayslipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payslip'], meta: { name: 'Payslip' } }
    /**
     * Find zero or one Payslip that matches the filter.
     * @param {PayslipFindUniqueArgs} args - Arguments to find a Payslip
     * @example
     * // Get one Payslip
     * const payslip = await prisma.payslip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayslipFindUniqueArgs>(args: SelectSubset<T, PayslipFindUniqueArgs<ExtArgs>>): Prisma__PayslipClient<$Result.GetResult<Prisma.$PayslipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payslip that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayslipFindUniqueOrThrowArgs} args - Arguments to find a Payslip
     * @example
     * // Get one Payslip
     * const payslip = await prisma.payslip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayslipFindUniqueOrThrowArgs>(args: SelectSubset<T, PayslipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayslipClient<$Result.GetResult<Prisma.$PayslipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payslip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayslipFindFirstArgs} args - Arguments to find a Payslip
     * @example
     * // Get one Payslip
     * const payslip = await prisma.payslip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayslipFindFirstArgs>(args?: SelectSubset<T, PayslipFindFirstArgs<ExtArgs>>): Prisma__PayslipClient<$Result.GetResult<Prisma.$PayslipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payslip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayslipFindFirstOrThrowArgs} args - Arguments to find a Payslip
     * @example
     * // Get one Payslip
     * const payslip = await prisma.payslip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayslipFindFirstOrThrowArgs>(args?: SelectSubset<T, PayslipFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayslipClient<$Result.GetResult<Prisma.$PayslipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payslips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayslipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payslips
     * const payslips = await prisma.payslip.findMany()
     * 
     * // Get first 10 Payslips
     * const payslips = await prisma.payslip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payslipWithIdOnly = await prisma.payslip.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayslipFindManyArgs>(args?: SelectSubset<T, PayslipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayslipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payslip.
     * @param {PayslipCreateArgs} args - Arguments to create a Payslip.
     * @example
     * // Create one Payslip
     * const Payslip = await prisma.payslip.create({
     *   data: {
     *     // ... data to create a Payslip
     *   }
     * })
     * 
     */
    create<T extends PayslipCreateArgs>(args: SelectSubset<T, PayslipCreateArgs<ExtArgs>>): Prisma__PayslipClient<$Result.GetResult<Prisma.$PayslipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payslips.
     * @param {PayslipCreateManyArgs} args - Arguments to create many Payslips.
     * @example
     * // Create many Payslips
     * const payslip = await prisma.payslip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayslipCreateManyArgs>(args?: SelectSubset<T, PayslipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payslips and returns the data saved in the database.
     * @param {PayslipCreateManyAndReturnArgs} args - Arguments to create many Payslips.
     * @example
     * // Create many Payslips
     * const payslip = await prisma.payslip.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payslips and only return the `id`
     * const payslipWithIdOnly = await prisma.payslip.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayslipCreateManyAndReturnArgs>(args?: SelectSubset<T, PayslipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayslipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payslip.
     * @param {PayslipDeleteArgs} args - Arguments to delete one Payslip.
     * @example
     * // Delete one Payslip
     * const Payslip = await prisma.payslip.delete({
     *   where: {
     *     // ... filter to delete one Payslip
     *   }
     * })
     * 
     */
    delete<T extends PayslipDeleteArgs>(args: SelectSubset<T, PayslipDeleteArgs<ExtArgs>>): Prisma__PayslipClient<$Result.GetResult<Prisma.$PayslipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payslip.
     * @param {PayslipUpdateArgs} args - Arguments to update one Payslip.
     * @example
     * // Update one Payslip
     * const payslip = await prisma.payslip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayslipUpdateArgs>(args: SelectSubset<T, PayslipUpdateArgs<ExtArgs>>): Prisma__PayslipClient<$Result.GetResult<Prisma.$PayslipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payslips.
     * @param {PayslipDeleteManyArgs} args - Arguments to filter Payslips to delete.
     * @example
     * // Delete a few Payslips
     * const { count } = await prisma.payslip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayslipDeleteManyArgs>(args?: SelectSubset<T, PayslipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payslips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayslipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payslips
     * const payslip = await prisma.payslip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayslipUpdateManyArgs>(args: SelectSubset<T, PayslipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payslips and returns the data updated in the database.
     * @param {PayslipUpdateManyAndReturnArgs} args - Arguments to update many Payslips.
     * @example
     * // Update many Payslips
     * const payslip = await prisma.payslip.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payslips and only return the `id`
     * const payslipWithIdOnly = await prisma.payslip.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayslipUpdateManyAndReturnArgs>(args: SelectSubset<T, PayslipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayslipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payslip.
     * @param {PayslipUpsertArgs} args - Arguments to update or create a Payslip.
     * @example
     * // Update or create a Payslip
     * const payslip = await prisma.payslip.upsert({
     *   create: {
     *     // ... data to create a Payslip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payslip we want to update
     *   }
     * })
     */
    upsert<T extends PayslipUpsertArgs>(args: SelectSubset<T, PayslipUpsertArgs<ExtArgs>>): Prisma__PayslipClient<$Result.GetResult<Prisma.$PayslipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payslips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayslipCountArgs} args - Arguments to filter Payslips to count.
     * @example
     * // Count the number of Payslips
     * const count = await prisma.payslip.count({
     *   where: {
     *     // ... the filter for the Payslips we want to count
     *   }
     * })
    **/
    count<T extends PayslipCountArgs>(
      args?: Subset<T, PayslipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayslipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payslip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayslipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayslipAggregateArgs>(args: Subset<T, PayslipAggregateArgs>): Prisma.PrismaPromise<GetPayslipAggregateType<T>>

    /**
     * Group by Payslip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayslipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayslipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayslipGroupByArgs['orderBy'] }
        : { orderBy?: PayslipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayslipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayslipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payslip model
   */
  readonly fields: PayslipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payslip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayslipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payslipRequest<T extends Payslip$payslipRequestArgs<ExtArgs> = {}>(args?: Subset<T, Payslip$payslipRequestArgs<ExtArgs>>): Prisma__PayslipRequestClient<$Result.GetResult<Prisma.$PayslipRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payslip model
   */
  interface PayslipFieldRefs {
    readonly id: FieldRef<"Payslip", 'String'>
    readonly accountId: FieldRef<"Payslip", 'String'>
    readonly periodStartDate: FieldRef<"Payslip", 'DateTime'>
    readonly periodEndDate: FieldRef<"Payslip", 'DateTime'>
    readonly baseSalary: FieldRef<"Payslip", 'Int'>
    readonly totalCommissions: FieldRef<"Payslip", 'Int'>
    readonly totalDeductions: FieldRef<"Payslip", 'Int'>
    readonly totalBonuses: FieldRef<"Payslip", 'Int'>
    readonly netPay: FieldRef<"Payslip", 'Int'>
    readonly status: FieldRef<"Payslip", 'PayslipStatus'>
    readonly releasedDate: FieldRef<"Payslip", 'DateTime'>
    readonly generatedAt: FieldRef<"Payslip", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payslip findUnique
   */
  export type PayslipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payslip
     */
    select?: PayslipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payslip
     */
    omit?: PayslipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipInclude<ExtArgs> | null
    /**
     * Filter, which Payslip to fetch.
     */
    where: PayslipWhereUniqueInput
  }

  /**
   * Payslip findUniqueOrThrow
   */
  export type PayslipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payslip
     */
    select?: PayslipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payslip
     */
    omit?: PayslipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipInclude<ExtArgs> | null
    /**
     * Filter, which Payslip to fetch.
     */
    where: PayslipWhereUniqueInput
  }

  /**
   * Payslip findFirst
   */
  export type PayslipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payslip
     */
    select?: PayslipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payslip
     */
    omit?: PayslipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipInclude<ExtArgs> | null
    /**
     * Filter, which Payslip to fetch.
     */
    where?: PayslipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payslips to fetch.
     */
    orderBy?: PayslipOrderByWithRelationInput | PayslipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payslips.
     */
    cursor?: PayslipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payslips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payslips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payslips.
     */
    distinct?: PayslipScalarFieldEnum | PayslipScalarFieldEnum[]
  }

  /**
   * Payslip findFirstOrThrow
   */
  export type PayslipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payslip
     */
    select?: PayslipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payslip
     */
    omit?: PayslipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipInclude<ExtArgs> | null
    /**
     * Filter, which Payslip to fetch.
     */
    where?: PayslipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payslips to fetch.
     */
    orderBy?: PayslipOrderByWithRelationInput | PayslipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payslips.
     */
    cursor?: PayslipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payslips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payslips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payslips.
     */
    distinct?: PayslipScalarFieldEnum | PayslipScalarFieldEnum[]
  }

  /**
   * Payslip findMany
   */
  export type PayslipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payslip
     */
    select?: PayslipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payslip
     */
    omit?: PayslipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipInclude<ExtArgs> | null
    /**
     * Filter, which Payslips to fetch.
     */
    where?: PayslipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payslips to fetch.
     */
    orderBy?: PayslipOrderByWithRelationInput | PayslipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payslips.
     */
    cursor?: PayslipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payslips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payslips.
     */
    skip?: number
    distinct?: PayslipScalarFieldEnum | PayslipScalarFieldEnum[]
  }

  /**
   * Payslip create
   */
  export type PayslipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payslip
     */
    select?: PayslipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payslip
     */
    omit?: PayslipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipInclude<ExtArgs> | null
    /**
     * The data needed to create a Payslip.
     */
    data: XOR<PayslipCreateInput, PayslipUncheckedCreateInput>
  }

  /**
   * Payslip createMany
   */
  export type PayslipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payslips.
     */
    data: PayslipCreateManyInput | PayslipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payslip createManyAndReturn
   */
  export type PayslipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payslip
     */
    select?: PayslipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payslip
     */
    omit?: PayslipOmit<ExtArgs> | null
    /**
     * The data used to create many Payslips.
     */
    data: PayslipCreateManyInput | PayslipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payslip update
   */
  export type PayslipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payslip
     */
    select?: PayslipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payslip
     */
    omit?: PayslipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipInclude<ExtArgs> | null
    /**
     * The data needed to update a Payslip.
     */
    data: XOR<PayslipUpdateInput, PayslipUncheckedUpdateInput>
    /**
     * Choose, which Payslip to update.
     */
    where: PayslipWhereUniqueInput
  }

  /**
   * Payslip updateMany
   */
  export type PayslipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payslips.
     */
    data: XOR<PayslipUpdateManyMutationInput, PayslipUncheckedUpdateManyInput>
    /**
     * Filter which Payslips to update
     */
    where?: PayslipWhereInput
    /**
     * Limit how many Payslips to update.
     */
    limit?: number
  }

  /**
   * Payslip updateManyAndReturn
   */
  export type PayslipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payslip
     */
    select?: PayslipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payslip
     */
    omit?: PayslipOmit<ExtArgs> | null
    /**
     * The data used to update Payslips.
     */
    data: XOR<PayslipUpdateManyMutationInput, PayslipUncheckedUpdateManyInput>
    /**
     * Filter which Payslips to update
     */
    where?: PayslipWhereInput
    /**
     * Limit how many Payslips to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payslip upsert
   */
  export type PayslipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payslip
     */
    select?: PayslipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payslip
     */
    omit?: PayslipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipInclude<ExtArgs> | null
    /**
     * The filter to search for the Payslip to update in case it exists.
     */
    where: PayslipWhereUniqueInput
    /**
     * In case the Payslip found by the `where` argument doesn't exist, create a new Payslip with this data.
     */
    create: XOR<PayslipCreateInput, PayslipUncheckedCreateInput>
    /**
     * In case the Payslip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayslipUpdateInput, PayslipUncheckedUpdateInput>
  }

  /**
   * Payslip delete
   */
  export type PayslipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payslip
     */
    select?: PayslipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payslip
     */
    omit?: PayslipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipInclude<ExtArgs> | null
    /**
     * Filter which Payslip to delete.
     */
    where: PayslipWhereUniqueInput
  }

  /**
   * Payslip deleteMany
   */
  export type PayslipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payslips to delete
     */
    where?: PayslipWhereInput
    /**
     * Limit how many Payslips to delete.
     */
    limit?: number
  }

  /**
   * Payslip.payslipRequest
   */
  export type Payslip$payslipRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayslipRequest
     */
    select?: PayslipRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayslipRequest
     */
    omit?: PayslipRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipRequestInclude<ExtArgs> | null
    where?: PayslipRequestWhereInput
  }

  /**
   * Payslip without action
   */
  export type PayslipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payslip
     */
    select?: PayslipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payslip
     */
    omit?: PayslipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipInclude<ExtArgs> | null
  }


  /**
   * Model RecommendedAppointment
   */

  export type AggregateRecommendedAppointment = {
    _count: RecommendedAppointmentCountAggregateOutputType | null
    _min: RecommendedAppointmentMinAggregateOutputType | null
    _max: RecommendedAppointmentMaxAggregateOutputType | null
  }

  export type RecommendedAppointmentMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    recommendedDate: Date | null
    originatingTransactionId: string | null
    originatingAvailedServiceId: string | null
    originatingServiceId: string | null
    status: $Enums.RecommendedAppointmentStatus | null
    attendedTransactionId: string | null
    suppressNextFollowUpGeneration: boolean | null
    reminder3DaySentAt: Date | null
    reminder2DaySentAt: Date | null
    reminder1DaySentAt: Date | null
    reminderTodaySentAt: Date | null
    reminder1DayAfterSentAt: Date | null
    reminder7DaySentAt: Date | null
    reminder7DayAfterSentAt: Date | null
    reminder14DayAfterSentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecommendedAppointmentMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    recommendedDate: Date | null
    originatingTransactionId: string | null
    originatingAvailedServiceId: string | null
    originatingServiceId: string | null
    status: $Enums.RecommendedAppointmentStatus | null
    attendedTransactionId: string | null
    suppressNextFollowUpGeneration: boolean | null
    reminder3DaySentAt: Date | null
    reminder2DaySentAt: Date | null
    reminder1DaySentAt: Date | null
    reminderTodaySentAt: Date | null
    reminder1DayAfterSentAt: Date | null
    reminder7DaySentAt: Date | null
    reminder7DayAfterSentAt: Date | null
    reminder14DayAfterSentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecommendedAppointmentCountAggregateOutputType = {
    id: number
    customerId: number
    recommendedDate: number
    originatingTransactionId: number
    originatingAvailedServiceId: number
    originatingServiceId: number
    status: number
    attendedTransactionId: number
    suppressNextFollowUpGeneration: number
    reminder3DaySentAt: number
    reminder2DaySentAt: number
    reminder1DaySentAt: number
    reminderTodaySentAt: number
    reminder1DayAfterSentAt: number
    reminder7DaySentAt: number
    reminder7DayAfterSentAt: number
    reminder14DayAfterSentAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecommendedAppointmentMinAggregateInputType = {
    id?: true
    customerId?: true
    recommendedDate?: true
    originatingTransactionId?: true
    originatingAvailedServiceId?: true
    originatingServiceId?: true
    status?: true
    attendedTransactionId?: true
    suppressNextFollowUpGeneration?: true
    reminder3DaySentAt?: true
    reminder2DaySentAt?: true
    reminder1DaySentAt?: true
    reminderTodaySentAt?: true
    reminder1DayAfterSentAt?: true
    reminder7DaySentAt?: true
    reminder7DayAfterSentAt?: true
    reminder14DayAfterSentAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecommendedAppointmentMaxAggregateInputType = {
    id?: true
    customerId?: true
    recommendedDate?: true
    originatingTransactionId?: true
    originatingAvailedServiceId?: true
    originatingServiceId?: true
    status?: true
    attendedTransactionId?: true
    suppressNextFollowUpGeneration?: true
    reminder3DaySentAt?: true
    reminder2DaySentAt?: true
    reminder1DaySentAt?: true
    reminderTodaySentAt?: true
    reminder1DayAfterSentAt?: true
    reminder7DaySentAt?: true
    reminder7DayAfterSentAt?: true
    reminder14DayAfterSentAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecommendedAppointmentCountAggregateInputType = {
    id?: true
    customerId?: true
    recommendedDate?: true
    originatingTransactionId?: true
    originatingAvailedServiceId?: true
    originatingServiceId?: true
    status?: true
    attendedTransactionId?: true
    suppressNextFollowUpGeneration?: true
    reminder3DaySentAt?: true
    reminder2DaySentAt?: true
    reminder1DaySentAt?: true
    reminderTodaySentAt?: true
    reminder1DayAfterSentAt?: true
    reminder7DaySentAt?: true
    reminder7DayAfterSentAt?: true
    reminder14DayAfterSentAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecommendedAppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecommendedAppointment to aggregate.
     */
    where?: RecommendedAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecommendedAppointments to fetch.
     */
    orderBy?: RecommendedAppointmentOrderByWithRelationInput | RecommendedAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecommendedAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecommendedAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecommendedAppointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecommendedAppointments
    **/
    _count?: true | RecommendedAppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecommendedAppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecommendedAppointmentMaxAggregateInputType
  }

  export type GetRecommendedAppointmentAggregateType<T extends RecommendedAppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateRecommendedAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecommendedAppointment[P]>
      : GetScalarType<T[P], AggregateRecommendedAppointment[P]>
  }




  export type RecommendedAppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecommendedAppointmentWhereInput
    orderBy?: RecommendedAppointmentOrderByWithAggregationInput | RecommendedAppointmentOrderByWithAggregationInput[]
    by: RecommendedAppointmentScalarFieldEnum[] | RecommendedAppointmentScalarFieldEnum
    having?: RecommendedAppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecommendedAppointmentCountAggregateInputType | true
    _min?: RecommendedAppointmentMinAggregateInputType
    _max?: RecommendedAppointmentMaxAggregateInputType
  }

  export type RecommendedAppointmentGroupByOutputType = {
    id: string
    customerId: string
    recommendedDate: Date
    originatingTransactionId: string | null
    originatingAvailedServiceId: string
    originatingServiceId: string
    status: $Enums.RecommendedAppointmentStatus
    attendedTransactionId: string | null
    suppressNextFollowUpGeneration: boolean
    reminder3DaySentAt: Date | null
    reminder2DaySentAt: Date | null
    reminder1DaySentAt: Date | null
    reminderTodaySentAt: Date | null
    reminder1DayAfterSentAt: Date | null
    reminder7DaySentAt: Date | null
    reminder7DayAfterSentAt: Date | null
    reminder14DayAfterSentAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RecommendedAppointmentCountAggregateOutputType | null
    _min: RecommendedAppointmentMinAggregateOutputType | null
    _max: RecommendedAppointmentMaxAggregateOutputType | null
  }

  type GetRecommendedAppointmentGroupByPayload<T extends RecommendedAppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecommendedAppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecommendedAppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecommendedAppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], RecommendedAppointmentGroupByOutputType[P]>
        }
      >
    >


  export type RecommendedAppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    recommendedDate?: boolean
    originatingTransactionId?: boolean
    originatingAvailedServiceId?: boolean
    originatingServiceId?: boolean
    status?: boolean
    attendedTransactionId?: boolean
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: boolean
    reminder2DaySentAt?: boolean
    reminder1DaySentAt?: boolean
    reminderTodaySentAt?: boolean
    reminder1DayAfterSentAt?: boolean
    reminder7DaySentAt?: boolean
    reminder7DayAfterSentAt?: boolean
    reminder14DayAfterSentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    originatingTransaction?: boolean | RecommendedAppointment$originatingTransactionArgs<ExtArgs>
    originatingAvailedService?: boolean | AvailedServiceDefaultArgs<ExtArgs>
    originatingService?: boolean | ServiceDefaultArgs<ExtArgs>
    attendedTransaction?: boolean | RecommendedAppointment$attendedTransactionArgs<ExtArgs>
  }, ExtArgs["result"]["recommendedAppointment"]>

  export type RecommendedAppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    recommendedDate?: boolean
    originatingTransactionId?: boolean
    originatingAvailedServiceId?: boolean
    originatingServiceId?: boolean
    status?: boolean
    attendedTransactionId?: boolean
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: boolean
    reminder2DaySentAt?: boolean
    reminder1DaySentAt?: boolean
    reminderTodaySentAt?: boolean
    reminder1DayAfterSentAt?: boolean
    reminder7DaySentAt?: boolean
    reminder7DayAfterSentAt?: boolean
    reminder14DayAfterSentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    originatingTransaction?: boolean | RecommendedAppointment$originatingTransactionArgs<ExtArgs>
    originatingAvailedService?: boolean | AvailedServiceDefaultArgs<ExtArgs>
    originatingService?: boolean | ServiceDefaultArgs<ExtArgs>
    attendedTransaction?: boolean | RecommendedAppointment$attendedTransactionArgs<ExtArgs>
  }, ExtArgs["result"]["recommendedAppointment"]>

  export type RecommendedAppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    recommendedDate?: boolean
    originatingTransactionId?: boolean
    originatingAvailedServiceId?: boolean
    originatingServiceId?: boolean
    status?: boolean
    attendedTransactionId?: boolean
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: boolean
    reminder2DaySentAt?: boolean
    reminder1DaySentAt?: boolean
    reminderTodaySentAt?: boolean
    reminder1DayAfterSentAt?: boolean
    reminder7DaySentAt?: boolean
    reminder7DayAfterSentAt?: boolean
    reminder14DayAfterSentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    originatingTransaction?: boolean | RecommendedAppointment$originatingTransactionArgs<ExtArgs>
    originatingAvailedService?: boolean | AvailedServiceDefaultArgs<ExtArgs>
    originatingService?: boolean | ServiceDefaultArgs<ExtArgs>
    attendedTransaction?: boolean | RecommendedAppointment$attendedTransactionArgs<ExtArgs>
  }, ExtArgs["result"]["recommendedAppointment"]>

  export type RecommendedAppointmentSelectScalar = {
    id?: boolean
    customerId?: boolean
    recommendedDate?: boolean
    originatingTransactionId?: boolean
    originatingAvailedServiceId?: boolean
    originatingServiceId?: boolean
    status?: boolean
    attendedTransactionId?: boolean
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: boolean
    reminder2DaySentAt?: boolean
    reminder1DaySentAt?: boolean
    reminderTodaySentAt?: boolean
    reminder1DayAfterSentAt?: boolean
    reminder7DaySentAt?: boolean
    reminder7DayAfterSentAt?: boolean
    reminder14DayAfterSentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecommendedAppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "recommendedDate" | "originatingTransactionId" | "originatingAvailedServiceId" | "originatingServiceId" | "status" | "attendedTransactionId" | "suppressNextFollowUpGeneration" | "reminder3DaySentAt" | "reminder2DaySentAt" | "reminder1DaySentAt" | "reminderTodaySentAt" | "reminder1DayAfterSentAt" | "reminder7DaySentAt" | "reminder7DayAfterSentAt" | "reminder14DayAfterSentAt" | "createdAt" | "updatedAt", ExtArgs["result"]["recommendedAppointment"]>
  export type RecommendedAppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    originatingTransaction?: boolean | RecommendedAppointment$originatingTransactionArgs<ExtArgs>
    originatingAvailedService?: boolean | AvailedServiceDefaultArgs<ExtArgs>
    originatingService?: boolean | ServiceDefaultArgs<ExtArgs>
    attendedTransaction?: boolean | RecommendedAppointment$attendedTransactionArgs<ExtArgs>
  }
  export type RecommendedAppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    originatingTransaction?: boolean | RecommendedAppointment$originatingTransactionArgs<ExtArgs>
    originatingAvailedService?: boolean | AvailedServiceDefaultArgs<ExtArgs>
    originatingService?: boolean | ServiceDefaultArgs<ExtArgs>
    attendedTransaction?: boolean | RecommendedAppointment$attendedTransactionArgs<ExtArgs>
  }
  export type RecommendedAppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    originatingTransaction?: boolean | RecommendedAppointment$originatingTransactionArgs<ExtArgs>
    originatingAvailedService?: boolean | AvailedServiceDefaultArgs<ExtArgs>
    originatingService?: boolean | ServiceDefaultArgs<ExtArgs>
    attendedTransaction?: boolean | RecommendedAppointment$attendedTransactionArgs<ExtArgs>
  }

  export type $RecommendedAppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecommendedAppointment"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      originatingTransaction: Prisma.$TransactionPayload<ExtArgs> | null
      originatingAvailedService: Prisma.$AvailedServicePayload<ExtArgs>
      originatingService: Prisma.$ServicePayload<ExtArgs>
      attendedTransaction: Prisma.$TransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      recommendedDate: Date
      originatingTransactionId: string | null
      originatingAvailedServiceId: string
      originatingServiceId: string
      status: $Enums.RecommendedAppointmentStatus
      attendedTransactionId: string | null
      suppressNextFollowUpGeneration: boolean
      reminder3DaySentAt: Date | null
      reminder2DaySentAt: Date | null
      reminder1DaySentAt: Date | null
      reminderTodaySentAt: Date | null
      reminder1DayAfterSentAt: Date | null
      reminder7DaySentAt: Date | null
      reminder7DayAfterSentAt: Date | null
      reminder14DayAfterSentAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recommendedAppointment"]>
    composites: {}
  }

  type RecommendedAppointmentGetPayload<S extends boolean | null | undefined | RecommendedAppointmentDefaultArgs> = $Result.GetResult<Prisma.$RecommendedAppointmentPayload, S>

  type RecommendedAppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecommendedAppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecommendedAppointmentCountAggregateInputType | true
    }

  export interface RecommendedAppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecommendedAppointment'], meta: { name: 'RecommendedAppointment' } }
    /**
     * Find zero or one RecommendedAppointment that matches the filter.
     * @param {RecommendedAppointmentFindUniqueArgs} args - Arguments to find a RecommendedAppointment
     * @example
     * // Get one RecommendedAppointment
     * const recommendedAppointment = await prisma.recommendedAppointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecommendedAppointmentFindUniqueArgs>(args: SelectSubset<T, RecommendedAppointmentFindUniqueArgs<ExtArgs>>): Prisma__RecommendedAppointmentClient<$Result.GetResult<Prisma.$RecommendedAppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecommendedAppointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecommendedAppointmentFindUniqueOrThrowArgs} args - Arguments to find a RecommendedAppointment
     * @example
     * // Get one RecommendedAppointment
     * const recommendedAppointment = await prisma.recommendedAppointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecommendedAppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, RecommendedAppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecommendedAppointmentClient<$Result.GetResult<Prisma.$RecommendedAppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecommendedAppointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedAppointmentFindFirstArgs} args - Arguments to find a RecommendedAppointment
     * @example
     * // Get one RecommendedAppointment
     * const recommendedAppointment = await prisma.recommendedAppointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecommendedAppointmentFindFirstArgs>(args?: SelectSubset<T, RecommendedAppointmentFindFirstArgs<ExtArgs>>): Prisma__RecommendedAppointmentClient<$Result.GetResult<Prisma.$RecommendedAppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecommendedAppointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedAppointmentFindFirstOrThrowArgs} args - Arguments to find a RecommendedAppointment
     * @example
     * // Get one RecommendedAppointment
     * const recommendedAppointment = await prisma.recommendedAppointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecommendedAppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, RecommendedAppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecommendedAppointmentClient<$Result.GetResult<Prisma.$RecommendedAppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecommendedAppointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedAppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecommendedAppointments
     * const recommendedAppointments = await prisma.recommendedAppointment.findMany()
     * 
     * // Get first 10 RecommendedAppointments
     * const recommendedAppointments = await prisma.recommendedAppointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recommendedAppointmentWithIdOnly = await prisma.recommendedAppointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecommendedAppointmentFindManyArgs>(args?: SelectSubset<T, RecommendedAppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendedAppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecommendedAppointment.
     * @param {RecommendedAppointmentCreateArgs} args - Arguments to create a RecommendedAppointment.
     * @example
     * // Create one RecommendedAppointment
     * const RecommendedAppointment = await prisma.recommendedAppointment.create({
     *   data: {
     *     // ... data to create a RecommendedAppointment
     *   }
     * })
     * 
     */
    create<T extends RecommendedAppointmentCreateArgs>(args: SelectSubset<T, RecommendedAppointmentCreateArgs<ExtArgs>>): Prisma__RecommendedAppointmentClient<$Result.GetResult<Prisma.$RecommendedAppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecommendedAppointments.
     * @param {RecommendedAppointmentCreateManyArgs} args - Arguments to create many RecommendedAppointments.
     * @example
     * // Create many RecommendedAppointments
     * const recommendedAppointment = await prisma.recommendedAppointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecommendedAppointmentCreateManyArgs>(args?: SelectSubset<T, RecommendedAppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecommendedAppointments and returns the data saved in the database.
     * @param {RecommendedAppointmentCreateManyAndReturnArgs} args - Arguments to create many RecommendedAppointments.
     * @example
     * // Create many RecommendedAppointments
     * const recommendedAppointment = await prisma.recommendedAppointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecommendedAppointments and only return the `id`
     * const recommendedAppointmentWithIdOnly = await prisma.recommendedAppointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecommendedAppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, RecommendedAppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendedAppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecommendedAppointment.
     * @param {RecommendedAppointmentDeleteArgs} args - Arguments to delete one RecommendedAppointment.
     * @example
     * // Delete one RecommendedAppointment
     * const RecommendedAppointment = await prisma.recommendedAppointment.delete({
     *   where: {
     *     // ... filter to delete one RecommendedAppointment
     *   }
     * })
     * 
     */
    delete<T extends RecommendedAppointmentDeleteArgs>(args: SelectSubset<T, RecommendedAppointmentDeleteArgs<ExtArgs>>): Prisma__RecommendedAppointmentClient<$Result.GetResult<Prisma.$RecommendedAppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecommendedAppointment.
     * @param {RecommendedAppointmentUpdateArgs} args - Arguments to update one RecommendedAppointment.
     * @example
     * // Update one RecommendedAppointment
     * const recommendedAppointment = await prisma.recommendedAppointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecommendedAppointmentUpdateArgs>(args: SelectSubset<T, RecommendedAppointmentUpdateArgs<ExtArgs>>): Prisma__RecommendedAppointmentClient<$Result.GetResult<Prisma.$RecommendedAppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecommendedAppointments.
     * @param {RecommendedAppointmentDeleteManyArgs} args - Arguments to filter RecommendedAppointments to delete.
     * @example
     * // Delete a few RecommendedAppointments
     * const { count } = await prisma.recommendedAppointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecommendedAppointmentDeleteManyArgs>(args?: SelectSubset<T, RecommendedAppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecommendedAppointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedAppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecommendedAppointments
     * const recommendedAppointment = await prisma.recommendedAppointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecommendedAppointmentUpdateManyArgs>(args: SelectSubset<T, RecommendedAppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecommendedAppointments and returns the data updated in the database.
     * @param {RecommendedAppointmentUpdateManyAndReturnArgs} args - Arguments to update many RecommendedAppointments.
     * @example
     * // Update many RecommendedAppointments
     * const recommendedAppointment = await prisma.recommendedAppointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecommendedAppointments and only return the `id`
     * const recommendedAppointmentWithIdOnly = await prisma.recommendedAppointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecommendedAppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, RecommendedAppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendedAppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecommendedAppointment.
     * @param {RecommendedAppointmentUpsertArgs} args - Arguments to update or create a RecommendedAppointment.
     * @example
     * // Update or create a RecommendedAppointment
     * const recommendedAppointment = await prisma.recommendedAppointment.upsert({
     *   create: {
     *     // ... data to create a RecommendedAppointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecommendedAppointment we want to update
     *   }
     * })
     */
    upsert<T extends RecommendedAppointmentUpsertArgs>(args: SelectSubset<T, RecommendedAppointmentUpsertArgs<ExtArgs>>): Prisma__RecommendedAppointmentClient<$Result.GetResult<Prisma.$RecommendedAppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecommendedAppointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedAppointmentCountArgs} args - Arguments to filter RecommendedAppointments to count.
     * @example
     * // Count the number of RecommendedAppointments
     * const count = await prisma.recommendedAppointment.count({
     *   where: {
     *     // ... the filter for the RecommendedAppointments we want to count
     *   }
     * })
    **/
    count<T extends RecommendedAppointmentCountArgs>(
      args?: Subset<T, RecommendedAppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecommendedAppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecommendedAppointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedAppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecommendedAppointmentAggregateArgs>(args: Subset<T, RecommendedAppointmentAggregateArgs>): Prisma.PrismaPromise<GetRecommendedAppointmentAggregateType<T>>

    /**
     * Group by RecommendedAppointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedAppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecommendedAppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecommendedAppointmentGroupByArgs['orderBy'] }
        : { orderBy?: RecommendedAppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecommendedAppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecommendedAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecommendedAppointment model
   */
  readonly fields: RecommendedAppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecommendedAppointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecommendedAppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    originatingTransaction<T extends RecommendedAppointment$originatingTransactionArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedAppointment$originatingTransactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    originatingAvailedService<T extends AvailedServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AvailedServiceDefaultArgs<ExtArgs>>): Prisma__AvailedServiceClient<$Result.GetResult<Prisma.$AvailedServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    originatingService<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attendedTransaction<T extends RecommendedAppointment$attendedTransactionArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedAppointment$attendedTransactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecommendedAppointment model
   */
  interface RecommendedAppointmentFieldRefs {
    readonly id: FieldRef<"RecommendedAppointment", 'String'>
    readonly customerId: FieldRef<"RecommendedAppointment", 'String'>
    readonly recommendedDate: FieldRef<"RecommendedAppointment", 'DateTime'>
    readonly originatingTransactionId: FieldRef<"RecommendedAppointment", 'String'>
    readonly originatingAvailedServiceId: FieldRef<"RecommendedAppointment", 'String'>
    readonly originatingServiceId: FieldRef<"RecommendedAppointment", 'String'>
    readonly status: FieldRef<"RecommendedAppointment", 'RecommendedAppointmentStatus'>
    readonly attendedTransactionId: FieldRef<"RecommendedAppointment", 'String'>
    readonly suppressNextFollowUpGeneration: FieldRef<"RecommendedAppointment", 'Boolean'>
    readonly reminder3DaySentAt: FieldRef<"RecommendedAppointment", 'DateTime'>
    readonly reminder2DaySentAt: FieldRef<"RecommendedAppointment", 'DateTime'>
    readonly reminder1DaySentAt: FieldRef<"RecommendedAppointment", 'DateTime'>
    readonly reminderTodaySentAt: FieldRef<"RecommendedAppointment", 'DateTime'>
    readonly reminder1DayAfterSentAt: FieldRef<"RecommendedAppointment", 'DateTime'>
    readonly reminder7DaySentAt: FieldRef<"RecommendedAppointment", 'DateTime'>
    readonly reminder7DayAfterSentAt: FieldRef<"RecommendedAppointment", 'DateTime'>
    readonly reminder14DayAfterSentAt: FieldRef<"RecommendedAppointment", 'DateTime'>
    readonly createdAt: FieldRef<"RecommendedAppointment", 'DateTime'>
    readonly updatedAt: FieldRef<"RecommendedAppointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecommendedAppointment findUnique
   */
  export type RecommendedAppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedAppointment
     */
    select?: RecommendedAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedAppointment
     */
    omit?: RecommendedAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which RecommendedAppointment to fetch.
     */
    where: RecommendedAppointmentWhereUniqueInput
  }

  /**
   * RecommendedAppointment findUniqueOrThrow
   */
  export type RecommendedAppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedAppointment
     */
    select?: RecommendedAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedAppointment
     */
    omit?: RecommendedAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which RecommendedAppointment to fetch.
     */
    where: RecommendedAppointmentWhereUniqueInput
  }

  /**
   * RecommendedAppointment findFirst
   */
  export type RecommendedAppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedAppointment
     */
    select?: RecommendedAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedAppointment
     */
    omit?: RecommendedAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which RecommendedAppointment to fetch.
     */
    where?: RecommendedAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecommendedAppointments to fetch.
     */
    orderBy?: RecommendedAppointmentOrderByWithRelationInput | RecommendedAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecommendedAppointments.
     */
    cursor?: RecommendedAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecommendedAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecommendedAppointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecommendedAppointments.
     */
    distinct?: RecommendedAppointmentScalarFieldEnum | RecommendedAppointmentScalarFieldEnum[]
  }

  /**
   * RecommendedAppointment findFirstOrThrow
   */
  export type RecommendedAppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedAppointment
     */
    select?: RecommendedAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedAppointment
     */
    omit?: RecommendedAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which RecommendedAppointment to fetch.
     */
    where?: RecommendedAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecommendedAppointments to fetch.
     */
    orderBy?: RecommendedAppointmentOrderByWithRelationInput | RecommendedAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecommendedAppointments.
     */
    cursor?: RecommendedAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecommendedAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecommendedAppointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecommendedAppointments.
     */
    distinct?: RecommendedAppointmentScalarFieldEnum | RecommendedAppointmentScalarFieldEnum[]
  }

  /**
   * RecommendedAppointment findMany
   */
  export type RecommendedAppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedAppointment
     */
    select?: RecommendedAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedAppointment
     */
    omit?: RecommendedAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which RecommendedAppointments to fetch.
     */
    where?: RecommendedAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecommendedAppointments to fetch.
     */
    orderBy?: RecommendedAppointmentOrderByWithRelationInput | RecommendedAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecommendedAppointments.
     */
    cursor?: RecommendedAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecommendedAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecommendedAppointments.
     */
    skip?: number
    distinct?: RecommendedAppointmentScalarFieldEnum | RecommendedAppointmentScalarFieldEnum[]
  }

  /**
   * RecommendedAppointment create
   */
  export type RecommendedAppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedAppointment
     */
    select?: RecommendedAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedAppointment
     */
    omit?: RecommendedAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a RecommendedAppointment.
     */
    data: XOR<RecommendedAppointmentCreateInput, RecommendedAppointmentUncheckedCreateInput>
  }

  /**
   * RecommendedAppointment createMany
   */
  export type RecommendedAppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecommendedAppointments.
     */
    data: RecommendedAppointmentCreateManyInput | RecommendedAppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecommendedAppointment createManyAndReturn
   */
  export type RecommendedAppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedAppointment
     */
    select?: RecommendedAppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedAppointment
     */
    omit?: RecommendedAppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many RecommendedAppointments.
     */
    data: RecommendedAppointmentCreateManyInput | RecommendedAppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecommendedAppointment update
   */
  export type RecommendedAppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedAppointment
     */
    select?: RecommendedAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedAppointment
     */
    omit?: RecommendedAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a RecommendedAppointment.
     */
    data: XOR<RecommendedAppointmentUpdateInput, RecommendedAppointmentUncheckedUpdateInput>
    /**
     * Choose, which RecommendedAppointment to update.
     */
    where: RecommendedAppointmentWhereUniqueInput
  }

  /**
   * RecommendedAppointment updateMany
   */
  export type RecommendedAppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecommendedAppointments.
     */
    data: XOR<RecommendedAppointmentUpdateManyMutationInput, RecommendedAppointmentUncheckedUpdateManyInput>
    /**
     * Filter which RecommendedAppointments to update
     */
    where?: RecommendedAppointmentWhereInput
    /**
     * Limit how many RecommendedAppointments to update.
     */
    limit?: number
  }

  /**
   * RecommendedAppointment updateManyAndReturn
   */
  export type RecommendedAppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedAppointment
     */
    select?: RecommendedAppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedAppointment
     */
    omit?: RecommendedAppointmentOmit<ExtArgs> | null
    /**
     * The data used to update RecommendedAppointments.
     */
    data: XOR<RecommendedAppointmentUpdateManyMutationInput, RecommendedAppointmentUncheckedUpdateManyInput>
    /**
     * Filter which RecommendedAppointments to update
     */
    where?: RecommendedAppointmentWhereInput
    /**
     * Limit how many RecommendedAppointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecommendedAppointment upsert
   */
  export type RecommendedAppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedAppointment
     */
    select?: RecommendedAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedAppointment
     */
    omit?: RecommendedAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the RecommendedAppointment to update in case it exists.
     */
    where: RecommendedAppointmentWhereUniqueInput
    /**
     * In case the RecommendedAppointment found by the `where` argument doesn't exist, create a new RecommendedAppointment with this data.
     */
    create: XOR<RecommendedAppointmentCreateInput, RecommendedAppointmentUncheckedCreateInput>
    /**
     * In case the RecommendedAppointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecommendedAppointmentUpdateInput, RecommendedAppointmentUncheckedUpdateInput>
  }

  /**
   * RecommendedAppointment delete
   */
  export type RecommendedAppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedAppointment
     */
    select?: RecommendedAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedAppointment
     */
    omit?: RecommendedAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAppointmentInclude<ExtArgs> | null
    /**
     * Filter which RecommendedAppointment to delete.
     */
    where: RecommendedAppointmentWhereUniqueInput
  }

  /**
   * RecommendedAppointment deleteMany
   */
  export type RecommendedAppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecommendedAppointments to delete
     */
    where?: RecommendedAppointmentWhereInput
    /**
     * Limit how many RecommendedAppointments to delete.
     */
    limit?: number
  }

  /**
   * RecommendedAppointment.originatingTransaction
   */
  export type RecommendedAppointment$originatingTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * RecommendedAppointment.attendedTransaction
   */
  export type RecommendedAppointment$attendedTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * RecommendedAppointment without action
   */
  export type RecommendedAppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedAppointment
     */
    select?: RecommendedAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedAppointment
     */
    omit?: RecommendedAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAppointmentInclude<ExtArgs> | null
  }


  /**
   * Model DiscountRule
   */

  export type AggregateDiscountRule = {
    _count: DiscountRuleCountAggregateOutputType | null
    _avg: DiscountRuleAvgAggregateOutputType | null
    _sum: DiscountRuleSumAggregateOutputType | null
    _min: DiscountRuleMinAggregateOutputType | null
    _max: DiscountRuleMaxAggregateOutputType | null
  }

  export type DiscountRuleAvgAggregateOutputType = {
    discountValue: number | null
  }

  export type DiscountRuleSumAggregateOutputType = {
    discountValue: number | null
  }

  export type DiscountRuleMinAggregateOutputType = {
    id: string | null
    description: string | null
    discountType: $Enums.DiscountType | null
    discountValue: number | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    applyToAll: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiscountRuleMaxAggregateOutputType = {
    id: string | null
    description: string | null
    discountType: $Enums.DiscountType | null
    discountValue: number | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    applyToAll: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiscountRuleCountAggregateOutputType = {
    id: number
    description: number
    discountType: number
    discountValue: number
    startDate: number
    endDate: number
    isActive: number
    applyToAll: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DiscountRuleAvgAggregateInputType = {
    discountValue?: true
  }

  export type DiscountRuleSumAggregateInputType = {
    discountValue?: true
  }

  export type DiscountRuleMinAggregateInputType = {
    id?: true
    description?: true
    discountType?: true
    discountValue?: true
    startDate?: true
    endDate?: true
    isActive?: true
    applyToAll?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiscountRuleMaxAggregateInputType = {
    id?: true
    description?: true
    discountType?: true
    discountValue?: true
    startDate?: true
    endDate?: true
    isActive?: true
    applyToAll?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiscountRuleCountAggregateInputType = {
    id?: true
    description?: true
    discountType?: true
    discountValue?: true
    startDate?: true
    endDate?: true
    isActive?: true
    applyToAll?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DiscountRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscountRule to aggregate.
     */
    where?: DiscountRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountRules to fetch.
     */
    orderBy?: DiscountRuleOrderByWithRelationInput | DiscountRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscountRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiscountRules
    **/
    _count?: true | DiscountRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscountRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscountRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountRuleMaxAggregateInputType
  }

  export type GetDiscountRuleAggregateType<T extends DiscountRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscountRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscountRule[P]>
      : GetScalarType<T[P], AggregateDiscountRule[P]>
  }




  export type DiscountRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountRuleWhereInput
    orderBy?: DiscountRuleOrderByWithAggregationInput | DiscountRuleOrderByWithAggregationInput[]
    by: DiscountRuleScalarFieldEnum[] | DiscountRuleScalarFieldEnum
    having?: DiscountRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountRuleCountAggregateInputType | true
    _avg?: DiscountRuleAvgAggregateInputType
    _sum?: DiscountRuleSumAggregateInputType
    _min?: DiscountRuleMinAggregateInputType
    _max?: DiscountRuleMaxAggregateInputType
  }

  export type DiscountRuleGroupByOutputType = {
    id: string
    description: string | null
    discountType: $Enums.DiscountType
    discountValue: number
    startDate: Date
    endDate: Date
    isActive: boolean
    applyToAll: boolean
    createdAt: Date
    updatedAt: Date
    _count: DiscountRuleCountAggregateOutputType | null
    _avg: DiscountRuleAvgAggregateOutputType | null
    _sum: DiscountRuleSumAggregateOutputType | null
    _min: DiscountRuleMinAggregateOutputType | null
    _max: DiscountRuleMaxAggregateOutputType | null
  }

  type GetDiscountRuleGroupByPayload<T extends DiscountRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscountRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountRuleGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountRuleGroupByOutputType[P]>
        }
      >
    >


  export type DiscountRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    applyToAll?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    services?: boolean | DiscountRule$servicesArgs<ExtArgs>
    _count?: boolean | DiscountRuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discountRule"]>

  export type DiscountRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    applyToAll?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["discountRule"]>

  export type DiscountRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    applyToAll?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["discountRule"]>

  export type DiscountRuleSelectScalar = {
    id?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    applyToAll?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DiscountRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "discountType" | "discountValue" | "startDate" | "endDate" | "isActive" | "applyToAll" | "createdAt" | "updatedAt", ExtArgs["result"]["discountRule"]>
  export type DiscountRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | DiscountRule$servicesArgs<ExtArgs>
    _count?: boolean | DiscountRuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DiscountRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DiscountRuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DiscountRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DiscountRule"
    objects: {
      services: Prisma.$ServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string | null
      discountType: $Enums.DiscountType
      discountValue: number
      startDate: Date
      endDate: Date
      isActive: boolean
      applyToAll: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["discountRule"]>
    composites: {}
  }

  type DiscountRuleGetPayload<S extends boolean | null | undefined | DiscountRuleDefaultArgs> = $Result.GetResult<Prisma.$DiscountRulePayload, S>

  type DiscountRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiscountRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiscountRuleCountAggregateInputType | true
    }

  export interface DiscountRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DiscountRule'], meta: { name: 'DiscountRule' } }
    /**
     * Find zero or one DiscountRule that matches the filter.
     * @param {DiscountRuleFindUniqueArgs} args - Arguments to find a DiscountRule
     * @example
     * // Get one DiscountRule
     * const discountRule = await prisma.discountRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscountRuleFindUniqueArgs>(args: SelectSubset<T, DiscountRuleFindUniqueArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DiscountRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiscountRuleFindUniqueOrThrowArgs} args - Arguments to find a DiscountRule
     * @example
     * // Get one DiscountRule
     * const discountRule = await prisma.discountRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscountRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscountRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscountRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleFindFirstArgs} args - Arguments to find a DiscountRule
     * @example
     * // Get one DiscountRule
     * const discountRule = await prisma.discountRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscountRuleFindFirstArgs>(args?: SelectSubset<T, DiscountRuleFindFirstArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscountRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleFindFirstOrThrowArgs} args - Arguments to find a DiscountRule
     * @example
     * // Get one DiscountRule
     * const discountRule = await prisma.discountRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscountRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscountRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DiscountRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiscountRules
     * const discountRules = await prisma.discountRule.findMany()
     * 
     * // Get first 10 DiscountRules
     * const discountRules = await prisma.discountRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discountRuleWithIdOnly = await prisma.discountRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiscountRuleFindManyArgs>(args?: SelectSubset<T, DiscountRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DiscountRule.
     * @param {DiscountRuleCreateArgs} args - Arguments to create a DiscountRule.
     * @example
     * // Create one DiscountRule
     * const DiscountRule = await prisma.discountRule.create({
     *   data: {
     *     // ... data to create a DiscountRule
     *   }
     * })
     * 
     */
    create<T extends DiscountRuleCreateArgs>(args: SelectSubset<T, DiscountRuleCreateArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DiscountRules.
     * @param {DiscountRuleCreateManyArgs} args - Arguments to create many DiscountRules.
     * @example
     * // Create many DiscountRules
     * const discountRule = await prisma.discountRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscountRuleCreateManyArgs>(args?: SelectSubset<T, DiscountRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DiscountRules and returns the data saved in the database.
     * @param {DiscountRuleCreateManyAndReturnArgs} args - Arguments to create many DiscountRules.
     * @example
     * // Create many DiscountRules
     * const discountRule = await prisma.discountRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DiscountRules and only return the `id`
     * const discountRuleWithIdOnly = await prisma.discountRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiscountRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, DiscountRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DiscountRule.
     * @param {DiscountRuleDeleteArgs} args - Arguments to delete one DiscountRule.
     * @example
     * // Delete one DiscountRule
     * const DiscountRule = await prisma.discountRule.delete({
     *   where: {
     *     // ... filter to delete one DiscountRule
     *   }
     * })
     * 
     */
    delete<T extends DiscountRuleDeleteArgs>(args: SelectSubset<T, DiscountRuleDeleteArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DiscountRule.
     * @param {DiscountRuleUpdateArgs} args - Arguments to update one DiscountRule.
     * @example
     * // Update one DiscountRule
     * const discountRule = await prisma.discountRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscountRuleUpdateArgs>(args: SelectSubset<T, DiscountRuleUpdateArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DiscountRules.
     * @param {DiscountRuleDeleteManyArgs} args - Arguments to filter DiscountRules to delete.
     * @example
     * // Delete a few DiscountRules
     * const { count } = await prisma.discountRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscountRuleDeleteManyArgs>(args?: SelectSubset<T, DiscountRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscountRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiscountRules
     * const discountRule = await prisma.discountRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscountRuleUpdateManyArgs>(args: SelectSubset<T, DiscountRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscountRules and returns the data updated in the database.
     * @param {DiscountRuleUpdateManyAndReturnArgs} args - Arguments to update many DiscountRules.
     * @example
     * // Update many DiscountRules
     * const discountRule = await prisma.discountRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DiscountRules and only return the `id`
     * const discountRuleWithIdOnly = await prisma.discountRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DiscountRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, DiscountRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DiscountRule.
     * @param {DiscountRuleUpsertArgs} args - Arguments to update or create a DiscountRule.
     * @example
     * // Update or create a DiscountRule
     * const discountRule = await prisma.discountRule.upsert({
     *   create: {
     *     // ... data to create a DiscountRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiscountRule we want to update
     *   }
     * })
     */
    upsert<T extends DiscountRuleUpsertArgs>(args: SelectSubset<T, DiscountRuleUpsertArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DiscountRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleCountArgs} args - Arguments to filter DiscountRules to count.
     * @example
     * // Count the number of DiscountRules
     * const count = await prisma.discountRule.count({
     *   where: {
     *     // ... the filter for the DiscountRules we want to count
     *   }
     * })
    **/
    count<T extends DiscountRuleCountArgs>(
      args?: Subset<T, DiscountRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiscountRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountRuleAggregateArgs>(args: Subset<T, DiscountRuleAggregateArgs>): Prisma.PrismaPromise<GetDiscountRuleAggregateType<T>>

    /**
     * Group by DiscountRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscountRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscountRuleGroupByArgs['orderBy'] }
        : { orderBy?: DiscountRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscountRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DiscountRule model
   */
  readonly fields: DiscountRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiscountRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscountRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends DiscountRule$servicesArgs<ExtArgs> = {}>(args?: Subset<T, DiscountRule$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DiscountRule model
   */
  interface DiscountRuleFieldRefs {
    readonly id: FieldRef<"DiscountRule", 'String'>
    readonly description: FieldRef<"DiscountRule", 'String'>
    readonly discountType: FieldRef<"DiscountRule", 'DiscountType'>
    readonly discountValue: FieldRef<"DiscountRule", 'Float'>
    readonly startDate: FieldRef<"DiscountRule", 'DateTime'>
    readonly endDate: FieldRef<"DiscountRule", 'DateTime'>
    readonly isActive: FieldRef<"DiscountRule", 'Boolean'>
    readonly applyToAll: FieldRef<"DiscountRule", 'Boolean'>
    readonly createdAt: FieldRef<"DiscountRule", 'DateTime'>
    readonly updatedAt: FieldRef<"DiscountRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DiscountRule findUnique
   */
  export type DiscountRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRule to fetch.
     */
    where: DiscountRuleWhereUniqueInput
  }

  /**
   * DiscountRule findUniqueOrThrow
   */
  export type DiscountRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRule to fetch.
     */
    where: DiscountRuleWhereUniqueInput
  }

  /**
   * DiscountRule findFirst
   */
  export type DiscountRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRule to fetch.
     */
    where?: DiscountRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountRules to fetch.
     */
    orderBy?: DiscountRuleOrderByWithRelationInput | DiscountRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscountRules.
     */
    cursor?: DiscountRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscountRules.
     */
    distinct?: DiscountRuleScalarFieldEnum | DiscountRuleScalarFieldEnum[]
  }

  /**
   * DiscountRule findFirstOrThrow
   */
  export type DiscountRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRule to fetch.
     */
    where?: DiscountRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountRules to fetch.
     */
    orderBy?: DiscountRuleOrderByWithRelationInput | DiscountRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscountRules.
     */
    cursor?: DiscountRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscountRules.
     */
    distinct?: DiscountRuleScalarFieldEnum | DiscountRuleScalarFieldEnum[]
  }

  /**
   * DiscountRule findMany
   */
  export type DiscountRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRules to fetch.
     */
    where?: DiscountRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountRules to fetch.
     */
    orderBy?: DiscountRuleOrderByWithRelationInput | DiscountRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiscountRules.
     */
    cursor?: DiscountRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountRules.
     */
    skip?: number
    distinct?: DiscountRuleScalarFieldEnum | DiscountRuleScalarFieldEnum[]
  }

  /**
   * DiscountRule create
   */
  export type DiscountRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a DiscountRule.
     */
    data: XOR<DiscountRuleCreateInput, DiscountRuleUncheckedCreateInput>
  }

  /**
   * DiscountRule createMany
   */
  export type DiscountRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DiscountRules.
     */
    data: DiscountRuleCreateManyInput | DiscountRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DiscountRule createManyAndReturn
   */
  export type DiscountRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * The data used to create many DiscountRules.
     */
    data: DiscountRuleCreateManyInput | DiscountRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DiscountRule update
   */
  export type DiscountRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a DiscountRule.
     */
    data: XOR<DiscountRuleUpdateInput, DiscountRuleUncheckedUpdateInput>
    /**
     * Choose, which DiscountRule to update.
     */
    where: DiscountRuleWhereUniqueInput
  }

  /**
   * DiscountRule updateMany
   */
  export type DiscountRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DiscountRules.
     */
    data: XOR<DiscountRuleUpdateManyMutationInput, DiscountRuleUncheckedUpdateManyInput>
    /**
     * Filter which DiscountRules to update
     */
    where?: DiscountRuleWhereInput
    /**
     * Limit how many DiscountRules to update.
     */
    limit?: number
  }

  /**
   * DiscountRule updateManyAndReturn
   */
  export type DiscountRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * The data used to update DiscountRules.
     */
    data: XOR<DiscountRuleUpdateManyMutationInput, DiscountRuleUncheckedUpdateManyInput>
    /**
     * Filter which DiscountRules to update
     */
    where?: DiscountRuleWhereInput
    /**
     * Limit how many DiscountRules to update.
     */
    limit?: number
  }

  /**
   * DiscountRule upsert
   */
  export type DiscountRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the DiscountRule to update in case it exists.
     */
    where: DiscountRuleWhereUniqueInput
    /**
     * In case the DiscountRule found by the `where` argument doesn't exist, create a new DiscountRule with this data.
     */
    create: XOR<DiscountRuleCreateInput, DiscountRuleUncheckedCreateInput>
    /**
     * In case the DiscountRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscountRuleUpdateInput, DiscountRuleUncheckedUpdateInput>
  }

  /**
   * DiscountRule delete
   */
  export type DiscountRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter which DiscountRule to delete.
     */
    where: DiscountRuleWhereUniqueInput
  }

  /**
   * DiscountRule deleteMany
   */
  export type DiscountRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscountRules to delete
     */
    where?: DiscountRuleWhereInput
    /**
     * Limit how many DiscountRules to delete.
     */
    limit?: number
  }

  /**
   * DiscountRule.services
   */
  export type DiscountRule$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * DiscountRule without action
   */
  export type DiscountRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
  }


  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchAvgAggregateOutputType = {
    totalSales: number | null
  }

  export type BranchSumAggregateOutputType = {
    totalSales: number | null
  }

  export type BranchMinAggregateOutputType = {
    id: string | null
    title: string | null
    code: string | null
    totalSales: number | null
  }

  export type BranchMaxAggregateOutputType = {
    id: string | null
    title: string | null
    code: string | null
    totalSales: number | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    title: number
    code: number
    totalSales: number
    _all: number
  }


  export type BranchAvgAggregateInputType = {
    totalSales?: true
  }

  export type BranchSumAggregateInputType = {
    totalSales?: true
  }

  export type BranchMinAggregateInputType = {
    id?: true
    title?: true
    code?: true
    totalSales?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    title?: true
    code?: true
    totalSales?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    title?: true
    code?: true
    totalSales?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _avg?: BranchAvgAggregateInputType
    _sum?: BranchSumAggregateInputType
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: string
    title: string
    code: string
    totalSales: number
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    code?: boolean
    totalSales?: boolean
    services?: boolean | Branch$servicesArgs<ExtArgs>
    accounts?: boolean | Branch$accountsArgs<ExtArgs>
    manualSales?: boolean | Branch$manualSalesArgs<ExtArgs>
    expenses?: boolean | Branch$expensesArgs<ExtArgs>
    Transaction?: boolean | Branch$TransactionArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    code?: boolean
    totalSales?: boolean
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    code?: boolean
    totalSales?: boolean
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    title?: boolean
    code?: boolean
    totalSales?: boolean
  }

  export type BranchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "code" | "totalSales", ExtArgs["result"]["branch"]>
  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | Branch$servicesArgs<ExtArgs>
    accounts?: boolean | Branch$accountsArgs<ExtArgs>
    manualSales?: boolean | Branch$manualSalesArgs<ExtArgs>
    expenses?: boolean | Branch$expensesArgs<ExtArgs>
    Transaction?: boolean | Branch$TransactionArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BranchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      services: Prisma.$ServicePayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      manualSales: Prisma.$ManualSalePayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      code: string
      totalSales: number
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {BranchCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches and returns the data updated in the database.
     * @param {BranchUpdateManyAndReturnArgs} args - Arguments to update many Branches.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BranchUpdateManyAndReturnArgs>(args: SelectSubset<T, BranchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends Branch$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends Branch$accountsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    manualSales<T extends Branch$manualSalesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$manualSalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualSalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expenses<T extends Branch$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transaction<T extends Branch$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, Branch$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'String'>
    readonly title: FieldRef<"Branch", 'String'>
    readonly code: FieldRef<"Branch", 'String'>
    readonly totalSales: FieldRef<"Branch", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch createManyAndReturn
   */
  export type BranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
  }

  /**
   * Branch updateManyAndReturn
   */
  export type BranchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to delete.
     */
    limit?: number
  }

  /**
   * Branch.services
   */
  export type Branch$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Branch.accounts
   */
  export type Branch$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Branch.manualSales
   */
  export type Branch$manualSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualSale
     */
    select?: ManualSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualSale
     */
    omit?: ManualSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualSaleInclude<ExtArgs> | null
    where?: ManualSaleWhereInput
    orderBy?: ManualSaleOrderByWithRelationInput | ManualSaleOrderByWithRelationInput[]
    cursor?: ManualSaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ManualSaleScalarFieldEnum | ManualSaleScalarFieldEnum[]
  }

  /**
   * Branch.expenses
   */
  export type Branch$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Branch.Transaction
   */
  export type Branch$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    date: Date | null
    accountId: string | null
    isPresent: boolean | null
    notes: string | null
    checkedById: string | null
    checkedAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    accountId: string | null
    isPresent: boolean | null
    notes: string | null
    checkedById: string | null
    checkedAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    date: number
    accountId: number
    isPresent: number
    notes: number
    checkedById: number
    checkedAt: number
    _all: number
  }


  export type AttendanceMinAggregateInputType = {
    id?: true
    date?: true
    accountId?: true
    isPresent?: true
    notes?: true
    checkedById?: true
    checkedAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    date?: true
    accountId?: true
    isPresent?: true
    notes?: true
    checkedById?: true
    checkedAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    date?: true
    accountId?: true
    isPresent?: true
    notes?: true
    checkedById?: true
    checkedAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    date: Date
    accountId: string
    isPresent: boolean
    notes: string | null
    checkedById: string
    checkedAt: Date
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    accountId?: boolean
    isPresent?: boolean
    notes?: boolean
    checkedById?: boolean
    checkedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    checkedBy?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    accountId?: boolean
    isPresent?: boolean
    notes?: boolean
    checkedById?: boolean
    checkedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    checkedBy?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    accountId?: boolean
    isPresent?: boolean
    notes?: boolean
    checkedById?: boolean
    checkedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    checkedBy?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    date?: boolean
    accountId?: boolean
    isPresent?: boolean
    notes?: boolean
    checkedById?: boolean
    checkedAt?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "accountId" | "isPresent" | "notes" | "checkedById" | "checkedAt", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    checkedBy?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    checkedBy?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    checkedBy?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      checkedBy: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      accountId: string
      isPresent: boolean
      notes: string | null
      checkedById: string
      checkedAt: Date
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    checkedBy<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly date: FieldRef<"Attendance", 'DateTime'>
    readonly accountId: FieldRef<"Attendance", 'String'>
    readonly isPresent: FieldRef<"Attendance", 'Boolean'>
    readonly notes: FieldRef<"Attendance", 'String'>
    readonly checkedById: FieldRef<"Attendance", 'String'>
    readonly checkedAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    salary: number | null
    dailyRate: number | null
  }

  export type AccountSumAggregateOutputType = {
    salary: number | null
    dailyRate: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    name: string | null
    email: string | null
    salary: number | null
    dailyRate: number | null
    branchId: string | null
    canRequestPayslip: boolean | null
    mustChangePassword: boolean | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    name: string | null
    email: string | null
    salary: number | null
    dailyRate: number | null
    branchId: string | null
    canRequestPayslip: boolean | null
    mustChangePassword: boolean | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    username: number
    password: number
    name: number
    email: number
    role: number
    salary: number
    dailyRate: number
    branchId: number
    canRequestPayslip: number
    mustChangePassword: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    salary?: true
    dailyRate?: true
  }

  export type AccountSumAggregateInputType = {
    salary?: true
    dailyRate?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    name?: true
    email?: true
    salary?: true
    dailyRate?: true
    branchId?: true
    canRequestPayslip?: true
    mustChangePassword?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    name?: true
    email?: true
    salary?: true
    dailyRate?: true
    branchId?: true
    canRequestPayslip?: true
    mustChangePassword?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    name?: true
    email?: true
    role?: true
    salary?: true
    dailyRate?: true
    branchId?: true
    canRequestPayslip?: true
    mustChangePassword?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    username: string
    password: string
    name: string
    email: string | null
    role: $Enums.Role[]
    salary: number
    dailyRate: number
    branchId: string | null
    canRequestPayslip: boolean
    mustChangePassword: boolean
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    salary?: boolean
    dailyRate?: boolean
    branchId?: boolean
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    branch?: boolean | Account$branchArgs<ExtArgs>
    servicesServed?: boolean | Account$servicesServedArgs<ExtArgs>
    servicesChecked?: boolean | Account$servicesCheckedArgs<ExtArgs>
    attendances?: boolean | Account$attendancesArgs<ExtArgs>
    attendancesChecked?: boolean | Account$attendancesCheckedArgs<ExtArgs>
    payslips?: boolean | Account$payslipsArgs<ExtArgs>
    payslipRequests?: boolean | Account$payslipRequestsArgs<ExtArgs>
    managedPayslipRequests?: boolean | Account$managedPayslipRequestsArgs<ExtArgs>
    manualSales?: boolean | Account$manualSalesArgs<ExtArgs>
    expenses?: boolean | Account$expensesArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    salary?: boolean
    dailyRate?: boolean
    branchId?: boolean
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    branch?: boolean | Account$branchArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    salary?: boolean
    dailyRate?: boolean
    branchId?: boolean
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    branch?: boolean | Account$branchArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    salary?: boolean
    dailyRate?: boolean
    branchId?: boolean
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "name" | "email" | "role" | "salary" | "dailyRate" | "branchId" | "canRequestPayslip" | "mustChangePassword", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Account$branchArgs<ExtArgs>
    servicesServed?: boolean | Account$servicesServedArgs<ExtArgs>
    servicesChecked?: boolean | Account$servicesCheckedArgs<ExtArgs>
    attendances?: boolean | Account$attendancesArgs<ExtArgs>
    attendancesChecked?: boolean | Account$attendancesCheckedArgs<ExtArgs>
    payslips?: boolean | Account$payslipsArgs<ExtArgs>
    payslipRequests?: boolean | Account$payslipRequestsArgs<ExtArgs>
    managedPayslipRequests?: boolean | Account$managedPayslipRequestsArgs<ExtArgs>
    manualSales?: boolean | Account$manualSalesArgs<ExtArgs>
    expenses?: boolean | Account$expensesArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Account$branchArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Account$branchArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      servicesServed: Prisma.$AvailedServicePayload<ExtArgs>[]
      servicesChecked: Prisma.$AvailedServicePayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      attendancesChecked: Prisma.$AttendancePayload<ExtArgs>[]
      payslips: Prisma.$PayslipPayload<ExtArgs>[]
      payslipRequests: Prisma.$PayslipRequestPayload<ExtArgs>[]
      managedPayslipRequests: Prisma.$PayslipRequestPayload<ExtArgs>[]
      manualSales: Prisma.$ManualSalePayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      password: string
      name: string
      email: string | null
      role: $Enums.Role[]
      salary: number
      dailyRate: number
      branchId: string | null
      canRequestPayslip: boolean
      mustChangePassword: boolean
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends Account$branchArgs<ExtArgs> = {}>(args?: Subset<T, Account$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    servicesServed<T extends Account$servicesServedArgs<ExtArgs> = {}>(args?: Subset<T, Account$servicesServedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailedServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    servicesChecked<T extends Account$servicesCheckedArgs<ExtArgs> = {}>(args?: Subset<T, Account$servicesCheckedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailedServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends Account$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Account$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendancesChecked<T extends Account$attendancesCheckedArgs<ExtArgs> = {}>(args?: Subset<T, Account$attendancesCheckedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payslips<T extends Account$payslipsArgs<ExtArgs> = {}>(args?: Subset<T, Account$payslipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayslipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payslipRequests<T extends Account$payslipRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Account$payslipRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayslipRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    managedPayslipRequests<T extends Account$managedPayslipRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Account$managedPayslipRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayslipRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    manualSales<T extends Account$manualSalesArgs<ExtArgs> = {}>(args?: Subset<T, Account$manualSalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualSalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expenses<T extends Account$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Account$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly username: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly name: FieldRef<"Account", 'String'>
    readonly email: FieldRef<"Account", 'String'>
    readonly role: FieldRef<"Account", 'Role[]'>
    readonly salary: FieldRef<"Account", 'Int'>
    readonly dailyRate: FieldRef<"Account", 'Int'>
    readonly branchId: FieldRef<"Account", 'String'>
    readonly canRequestPayslip: FieldRef<"Account", 'Boolean'>
    readonly mustChangePassword: FieldRef<"Account", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account.branch
   */
  export type Account$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Account.servicesServed
   */
  export type Account$servicesServedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailedService
     */
    select?: AvailedServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailedService
     */
    omit?: AvailedServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailedServiceInclude<ExtArgs> | null
    where?: AvailedServiceWhereInput
    orderBy?: AvailedServiceOrderByWithRelationInput | AvailedServiceOrderByWithRelationInput[]
    cursor?: AvailedServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvailedServiceScalarFieldEnum | AvailedServiceScalarFieldEnum[]
  }

  /**
   * Account.servicesChecked
   */
  export type Account$servicesCheckedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailedService
     */
    select?: AvailedServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailedService
     */
    omit?: AvailedServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailedServiceInclude<ExtArgs> | null
    where?: AvailedServiceWhereInput
    orderBy?: AvailedServiceOrderByWithRelationInput | AvailedServiceOrderByWithRelationInput[]
    cursor?: AvailedServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvailedServiceScalarFieldEnum | AvailedServiceScalarFieldEnum[]
  }

  /**
   * Account.attendances
   */
  export type Account$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Account.attendancesChecked
   */
  export type Account$attendancesCheckedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Account.payslips
   */
  export type Account$payslipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payslip
     */
    select?: PayslipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payslip
     */
    omit?: PayslipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipInclude<ExtArgs> | null
    where?: PayslipWhereInput
    orderBy?: PayslipOrderByWithRelationInput | PayslipOrderByWithRelationInput[]
    cursor?: PayslipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayslipScalarFieldEnum | PayslipScalarFieldEnum[]
  }

  /**
   * Account.payslipRequests
   */
  export type Account$payslipRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayslipRequest
     */
    select?: PayslipRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayslipRequest
     */
    omit?: PayslipRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipRequestInclude<ExtArgs> | null
    where?: PayslipRequestWhereInput
    orderBy?: PayslipRequestOrderByWithRelationInput | PayslipRequestOrderByWithRelationInput[]
    cursor?: PayslipRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayslipRequestScalarFieldEnum | PayslipRequestScalarFieldEnum[]
  }

  /**
   * Account.managedPayslipRequests
   */
  export type Account$managedPayslipRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayslipRequest
     */
    select?: PayslipRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayslipRequest
     */
    omit?: PayslipRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayslipRequestInclude<ExtArgs> | null
    where?: PayslipRequestWhereInput
    orderBy?: PayslipRequestOrderByWithRelationInput | PayslipRequestOrderByWithRelationInput[]
    cursor?: PayslipRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayslipRequestScalarFieldEnum | PayslipRequestScalarFieldEnum[]
  }

  /**
   * Account.manualSales
   */
  export type Account$manualSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualSale
     */
    select?: ManualSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualSale
     */
    omit?: ManualSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualSaleInclude<ExtArgs> | null
    where?: ManualSaleWhereInput
    orderBy?: ManualSaleOrderByWithRelationInput | ManualSaleOrderByWithRelationInput[]
    cursor?: ManualSaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ManualSaleScalarFieldEnum | ManualSaleScalarFieldEnum[]
  }

  /**
   * Account.expenses
   */
  export type Account$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    price: number | null
    totalSales: number | null
    recommendedFollowUpDays: number | null
  }

  export type ServiceSumAggregateOutputType = {
    price: number | null
    totalSales: number | null
    recommendedFollowUpDays: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    price: number | null
    branchId: string | null
    totalSales: number | null
    recommendFollowUp: boolean | null
    recommendedFollowUpDays: number | null
    followUpPolicy: $Enums.FollowUpPolicy | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    price: number | null
    branchId: string | null
    totalSales: number | null
    recommendFollowUp: boolean | null
    recommendedFollowUpDays: number | null
    followUpPolicy: $Enums.FollowUpPolicy | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    title: number
    description: number
    price: number
    branchId: number
    totalSales: number
    recommendFollowUp: number
    recommendedFollowUpDays: number
    followUpPolicy: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    price?: true
    totalSales?: true
    recommendedFollowUpDays?: true
  }

  export type ServiceSumAggregateInputType = {
    price?: true
    totalSales?: true
    recommendedFollowUpDays?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    branchId?: true
    totalSales?: true
    recommendFollowUp?: true
    recommendedFollowUpDays?: true
    followUpPolicy?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    branchId?: true
    totalSales?: true
    recommendFollowUp?: true
    recommendedFollowUpDays?: true
    followUpPolicy?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    branchId?: true
    totalSales?: true
    recommendFollowUp?: true
    recommendedFollowUpDays?: true
    followUpPolicy?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    title: string
    description: string | null
    price: number
    branchId: string
    totalSales: number
    recommendFollowUp: boolean
    recommendedFollowUpDays: number | null
    followUpPolicy: $Enums.FollowUpPolicy
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    branchId?: boolean
    totalSales?: boolean
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: boolean
    followUpPolicy?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    AvailedService?: boolean | Service$AvailedServiceArgs<ExtArgs>
    serviceSets?: boolean | Service$serviceSetsArgs<ExtArgs>
    giftCertificates?: boolean | Service$giftCertificatesArgs<ExtArgs>
    discountRules?: boolean | Service$discountRulesArgs<ExtArgs>
    recommendedAppointments?: boolean | Service$recommendedAppointmentsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    branchId?: boolean
    totalSales?: boolean
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: boolean
    followUpPolicy?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    branchId?: boolean
    totalSales?: boolean
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: boolean
    followUpPolicy?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    branchId?: boolean
    totalSales?: boolean
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: boolean
    followUpPolicy?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "price" | "branchId" | "totalSales" | "recommendFollowUp" | "recommendedFollowUpDays" | "followUpPolicy", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    AvailedService?: boolean | Service$AvailedServiceArgs<ExtArgs>
    serviceSets?: boolean | Service$serviceSetsArgs<ExtArgs>
    giftCertificates?: boolean | Service$giftCertificatesArgs<ExtArgs>
    discountRules?: boolean | Service$discountRulesArgs<ExtArgs>
    recommendedAppointments?: boolean | Service$recommendedAppointmentsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      AvailedService: Prisma.$AvailedServicePayload<ExtArgs>[]
      serviceSets: Prisma.$ServiceSetPayload<ExtArgs>[]
      giftCertificates: Prisma.$GiftCertificatePayload<ExtArgs>[]
      discountRules: Prisma.$DiscountRulePayload<ExtArgs>[]
      recommendedAppointments: Prisma.$RecommendedAppointmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      price: number
      branchId: string
      totalSales: number
      recommendFollowUp: boolean
      recommendedFollowUpDays: number | null
      followUpPolicy: $Enums.FollowUpPolicy
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    AvailedService<T extends Service$AvailedServiceArgs<ExtArgs> = {}>(args?: Subset<T, Service$AvailedServiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailedServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceSets<T extends Service$serviceSetsArgs<ExtArgs> = {}>(args?: Subset<T, Service$serviceSetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceSetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    giftCertificates<T extends Service$giftCertificatesArgs<ExtArgs> = {}>(args?: Subset<T, Service$giftCertificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiftCertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    discountRules<T extends Service$discountRulesArgs<ExtArgs> = {}>(args?: Subset<T, Service$discountRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recommendedAppointments<T extends Service$recommendedAppointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Service$recommendedAppointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendedAppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly title: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly price: FieldRef<"Service", 'Int'>
    readonly branchId: FieldRef<"Service", 'String'>
    readonly totalSales: FieldRef<"Service", 'Int'>
    readonly recommendFollowUp: FieldRef<"Service", 'Boolean'>
    readonly recommendedFollowUpDays: FieldRef<"Service", 'Int'>
    readonly followUpPolicy: FieldRef<"Service", 'FollowUpPolicy'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.AvailedService
   */
  export type Service$AvailedServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailedService
     */
    select?: AvailedServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailedService
     */
    omit?: AvailedServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailedServiceInclude<ExtArgs> | null
    where?: AvailedServiceWhereInput
    orderBy?: AvailedServiceOrderByWithRelationInput | AvailedServiceOrderByWithRelationInput[]
    cursor?: AvailedServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvailedServiceScalarFieldEnum | AvailedServiceScalarFieldEnum[]
  }

  /**
   * Service.serviceSets
   */
  export type Service$serviceSetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSet
     */
    select?: ServiceSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSet
     */
    omit?: ServiceSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSetInclude<ExtArgs> | null
    where?: ServiceSetWhereInput
    orderBy?: ServiceSetOrderByWithRelationInput | ServiceSetOrderByWithRelationInput[]
    cursor?: ServiceSetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceSetScalarFieldEnum | ServiceSetScalarFieldEnum[]
  }

  /**
   * Service.giftCertificates
   */
  export type Service$giftCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCertificate
     */
    select?: GiftCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GiftCertificate
     */
    omit?: GiftCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCertificateInclude<ExtArgs> | null
    where?: GiftCertificateWhereInput
    orderBy?: GiftCertificateOrderByWithRelationInput | GiftCertificateOrderByWithRelationInput[]
    cursor?: GiftCertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GiftCertificateScalarFieldEnum | GiftCertificateScalarFieldEnum[]
  }

  /**
   * Service.discountRules
   */
  export type Service$discountRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    where?: DiscountRuleWhereInput
    orderBy?: DiscountRuleOrderByWithRelationInput | DiscountRuleOrderByWithRelationInput[]
    cursor?: DiscountRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiscountRuleScalarFieldEnum | DiscountRuleScalarFieldEnum[]
  }

  /**
   * Service.recommendedAppointments
   */
  export type Service$recommendedAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedAppointment
     */
    select?: RecommendedAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedAppointment
     */
    omit?: RecommendedAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAppointmentInclude<ExtArgs> | null
    where?: RecommendedAppointmentWhereInput
    orderBy?: RecommendedAppointmentOrderByWithRelationInput | RecommendedAppointmentOrderByWithRelationInput[]
    cursor?: RecommendedAppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecommendedAppointmentScalarFieldEnum | RecommendedAppointmentScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model ServiceSet
   */

  export type AggregateServiceSet = {
    _count: ServiceSetCountAggregateOutputType | null
    _avg: ServiceSetAvgAggregateOutputType | null
    _sum: ServiceSetSumAggregateOutputType | null
    _min: ServiceSetMinAggregateOutputType | null
    _max: ServiceSetMaxAggregateOutputType | null
  }

  export type ServiceSetAvgAggregateOutputType = {
    price: number | null
  }

  export type ServiceSetSumAggregateOutputType = {
    price: number | null
  }

  export type ServiceSetMinAggregateOutputType = {
    id: string | null
    title: string | null
    price: number | null
  }

  export type ServiceSetMaxAggregateOutputType = {
    id: string | null
    title: string | null
    price: number | null
  }

  export type ServiceSetCountAggregateOutputType = {
    id: number
    title: number
    price: number
    _all: number
  }


  export type ServiceSetAvgAggregateInputType = {
    price?: true
  }

  export type ServiceSetSumAggregateInputType = {
    price?: true
  }

  export type ServiceSetMinAggregateInputType = {
    id?: true
    title?: true
    price?: true
  }

  export type ServiceSetMaxAggregateInputType = {
    id?: true
    title?: true
    price?: true
  }

  export type ServiceSetCountAggregateInputType = {
    id?: true
    title?: true
    price?: true
    _all?: true
  }

  export type ServiceSetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceSet to aggregate.
     */
    where?: ServiceSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSets to fetch.
     */
    orderBy?: ServiceSetOrderByWithRelationInput | ServiceSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceSets
    **/
    _count?: true | ServiceSetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceSetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceSetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceSetMaxAggregateInputType
  }

  export type GetServiceSetAggregateType<T extends ServiceSetAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceSet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceSet[P]>
      : GetScalarType<T[P], AggregateServiceSet[P]>
  }




  export type ServiceSetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceSetWhereInput
    orderBy?: ServiceSetOrderByWithAggregationInput | ServiceSetOrderByWithAggregationInput[]
    by: ServiceSetScalarFieldEnum[] | ServiceSetScalarFieldEnum
    having?: ServiceSetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceSetCountAggregateInputType | true
    _avg?: ServiceSetAvgAggregateInputType
    _sum?: ServiceSetSumAggregateInputType
    _min?: ServiceSetMinAggregateInputType
    _max?: ServiceSetMaxAggregateInputType
  }

  export type ServiceSetGroupByOutputType = {
    id: string
    title: string
    price: number
    _count: ServiceSetCountAggregateOutputType | null
    _avg: ServiceSetAvgAggregateOutputType | null
    _sum: ServiceSetSumAggregateOutputType | null
    _min: ServiceSetMinAggregateOutputType | null
    _max: ServiceSetMaxAggregateOutputType | null
  }

  type GetServiceSetGroupByPayload<T extends ServiceSetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceSetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceSetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceSetGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceSetGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    price?: boolean
    services?: boolean | ServiceSet$servicesArgs<ExtArgs>
    giftCertificates?: boolean | ServiceSet$giftCertificatesArgs<ExtArgs>
    AvailedService?: boolean | ServiceSet$AvailedServiceArgs<ExtArgs>
    _count?: boolean | ServiceSetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceSet"]>

  export type ServiceSetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    price?: boolean
  }, ExtArgs["result"]["serviceSet"]>

  export type ServiceSetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    price?: boolean
  }, ExtArgs["result"]["serviceSet"]>

  export type ServiceSetSelectScalar = {
    id?: boolean
    title?: boolean
    price?: boolean
  }

  export type ServiceSetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "price", ExtArgs["result"]["serviceSet"]>
  export type ServiceSetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceSet$servicesArgs<ExtArgs>
    giftCertificates?: boolean | ServiceSet$giftCertificatesArgs<ExtArgs>
    AvailedService?: boolean | ServiceSet$AvailedServiceArgs<ExtArgs>
    _count?: boolean | ServiceSetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceSetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceSetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceSetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceSet"
    objects: {
      services: Prisma.$ServicePayload<ExtArgs>[]
      giftCertificates: Prisma.$GiftCertificatePayload<ExtArgs>[]
      AvailedService: Prisma.$AvailedServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      price: number
    }, ExtArgs["result"]["serviceSet"]>
    composites: {}
  }

  type ServiceSetGetPayload<S extends boolean | null | undefined | ServiceSetDefaultArgs> = $Result.GetResult<Prisma.$ServiceSetPayload, S>

  type ServiceSetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceSetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceSetCountAggregateInputType | true
    }

  export interface ServiceSetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceSet'], meta: { name: 'ServiceSet' } }
    /**
     * Find zero or one ServiceSet that matches the filter.
     * @param {ServiceSetFindUniqueArgs} args - Arguments to find a ServiceSet
     * @example
     * // Get one ServiceSet
     * const serviceSet = await prisma.serviceSet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceSetFindUniqueArgs>(args: SelectSubset<T, ServiceSetFindUniqueArgs<ExtArgs>>): Prisma__ServiceSetClient<$Result.GetResult<Prisma.$ServiceSetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceSet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceSetFindUniqueOrThrowArgs} args - Arguments to find a ServiceSet
     * @example
     * // Get one ServiceSet
     * const serviceSet = await prisma.serviceSet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceSetFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceSetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceSetClient<$Result.GetResult<Prisma.$ServiceSetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceSet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSetFindFirstArgs} args - Arguments to find a ServiceSet
     * @example
     * // Get one ServiceSet
     * const serviceSet = await prisma.serviceSet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceSetFindFirstArgs>(args?: SelectSubset<T, ServiceSetFindFirstArgs<ExtArgs>>): Prisma__ServiceSetClient<$Result.GetResult<Prisma.$ServiceSetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceSet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSetFindFirstOrThrowArgs} args - Arguments to find a ServiceSet
     * @example
     * // Get one ServiceSet
     * const serviceSet = await prisma.serviceSet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceSetFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceSetFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceSetClient<$Result.GetResult<Prisma.$ServiceSetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceSets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceSets
     * const serviceSets = await prisma.serviceSet.findMany()
     * 
     * // Get first 10 ServiceSets
     * const serviceSets = await prisma.serviceSet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceSetWithIdOnly = await prisma.serviceSet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceSetFindManyArgs>(args?: SelectSubset<T, ServiceSetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceSetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceSet.
     * @param {ServiceSetCreateArgs} args - Arguments to create a ServiceSet.
     * @example
     * // Create one ServiceSet
     * const ServiceSet = await prisma.serviceSet.create({
     *   data: {
     *     // ... data to create a ServiceSet
     *   }
     * })
     * 
     */
    create<T extends ServiceSetCreateArgs>(args: SelectSubset<T, ServiceSetCreateArgs<ExtArgs>>): Prisma__ServiceSetClient<$Result.GetResult<Prisma.$ServiceSetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceSets.
     * @param {ServiceSetCreateManyArgs} args - Arguments to create many ServiceSets.
     * @example
     * // Create many ServiceSets
     * const serviceSet = await prisma.serviceSet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceSetCreateManyArgs>(args?: SelectSubset<T, ServiceSetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceSets and returns the data saved in the database.
     * @param {ServiceSetCreateManyAndReturnArgs} args - Arguments to create many ServiceSets.
     * @example
     * // Create many ServiceSets
     * const serviceSet = await prisma.serviceSet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceSets and only return the `id`
     * const serviceSetWithIdOnly = await prisma.serviceSet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceSetCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceSetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceSetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceSet.
     * @param {ServiceSetDeleteArgs} args - Arguments to delete one ServiceSet.
     * @example
     * // Delete one ServiceSet
     * const ServiceSet = await prisma.serviceSet.delete({
     *   where: {
     *     // ... filter to delete one ServiceSet
     *   }
     * })
     * 
     */
    delete<T extends ServiceSetDeleteArgs>(args: SelectSubset<T, ServiceSetDeleteArgs<ExtArgs>>): Prisma__ServiceSetClient<$Result.GetResult<Prisma.$ServiceSetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceSet.
     * @param {ServiceSetUpdateArgs} args - Arguments to update one ServiceSet.
     * @example
     * // Update one ServiceSet
     * const serviceSet = await prisma.serviceSet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceSetUpdateArgs>(args: SelectSubset<T, ServiceSetUpdateArgs<ExtArgs>>): Prisma__ServiceSetClient<$Result.GetResult<Prisma.$ServiceSetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceSets.
     * @param {ServiceSetDeleteManyArgs} args - Arguments to filter ServiceSets to delete.
     * @example
     * // Delete a few ServiceSets
     * const { count } = await prisma.serviceSet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceSetDeleteManyArgs>(args?: SelectSubset<T, ServiceSetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceSets
     * const serviceSet = await prisma.serviceSet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceSetUpdateManyArgs>(args: SelectSubset<T, ServiceSetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceSets and returns the data updated in the database.
     * @param {ServiceSetUpdateManyAndReturnArgs} args - Arguments to update many ServiceSets.
     * @example
     * // Update many ServiceSets
     * const serviceSet = await prisma.serviceSet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceSets and only return the `id`
     * const serviceSetWithIdOnly = await prisma.serviceSet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceSetUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceSetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceSetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceSet.
     * @param {ServiceSetUpsertArgs} args - Arguments to update or create a ServiceSet.
     * @example
     * // Update or create a ServiceSet
     * const serviceSet = await prisma.serviceSet.upsert({
     *   create: {
     *     // ... data to create a ServiceSet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceSet we want to update
     *   }
     * })
     */
    upsert<T extends ServiceSetUpsertArgs>(args: SelectSubset<T, ServiceSetUpsertArgs<ExtArgs>>): Prisma__ServiceSetClient<$Result.GetResult<Prisma.$ServiceSetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSetCountArgs} args - Arguments to filter ServiceSets to count.
     * @example
     * // Count the number of ServiceSets
     * const count = await prisma.serviceSet.count({
     *   where: {
     *     // ... the filter for the ServiceSets we want to count
     *   }
     * })
    **/
    count<T extends ServiceSetCountArgs>(
      args?: Subset<T, ServiceSetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceSetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceSetAggregateArgs>(args: Subset<T, ServiceSetAggregateArgs>): Prisma.PrismaPromise<GetServiceSetAggregateType<T>>

    /**
     * Group by ServiceSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceSetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceSetGroupByArgs['orderBy'] }
        : { orderBy?: ServiceSetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceSetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceSetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceSet model
   */
  readonly fields: ServiceSetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceSet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceSetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends ServiceSet$servicesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceSet$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    giftCertificates<T extends ServiceSet$giftCertificatesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceSet$giftCertificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiftCertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AvailedService<T extends ServiceSet$AvailedServiceArgs<ExtArgs> = {}>(args?: Subset<T, ServiceSet$AvailedServiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailedServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceSet model
   */
  interface ServiceSetFieldRefs {
    readonly id: FieldRef<"ServiceSet", 'String'>
    readonly title: FieldRef<"ServiceSet", 'String'>
    readonly price: FieldRef<"ServiceSet", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ServiceSet findUnique
   */
  export type ServiceSetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSet
     */
    select?: ServiceSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSet
     */
    omit?: ServiceSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSetInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSet to fetch.
     */
    where: ServiceSetWhereUniqueInput
  }

  /**
   * ServiceSet findUniqueOrThrow
   */
  export type ServiceSetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSet
     */
    select?: ServiceSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSet
     */
    omit?: ServiceSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSetInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSet to fetch.
     */
    where: ServiceSetWhereUniqueInput
  }

  /**
   * ServiceSet findFirst
   */
  export type ServiceSetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSet
     */
    select?: ServiceSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSet
     */
    omit?: ServiceSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSetInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSet to fetch.
     */
    where?: ServiceSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSets to fetch.
     */
    orderBy?: ServiceSetOrderByWithRelationInput | ServiceSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSets.
     */
    cursor?: ServiceSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSets.
     */
    distinct?: ServiceSetScalarFieldEnum | ServiceSetScalarFieldEnum[]
  }

  /**
   * ServiceSet findFirstOrThrow
   */
  export type ServiceSetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSet
     */
    select?: ServiceSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSet
     */
    omit?: ServiceSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSetInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSet to fetch.
     */
    where?: ServiceSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSets to fetch.
     */
    orderBy?: ServiceSetOrderByWithRelationInput | ServiceSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSets.
     */
    cursor?: ServiceSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSets.
     */
    distinct?: ServiceSetScalarFieldEnum | ServiceSetScalarFieldEnum[]
  }

  /**
   * ServiceSet findMany
   */
  export type ServiceSetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSet
     */
    select?: ServiceSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSet
     */
    omit?: ServiceSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSetInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSets to fetch.
     */
    where?: ServiceSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSets to fetch.
     */
    orderBy?: ServiceSetOrderByWithRelationInput | ServiceSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceSets.
     */
    cursor?: ServiceSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSets.
     */
    skip?: number
    distinct?: ServiceSetScalarFieldEnum | ServiceSetScalarFieldEnum[]
  }

  /**
   * ServiceSet create
   */
  export type ServiceSetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSet
     */
    select?: ServiceSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSet
     */
    omit?: ServiceSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSetInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceSet.
     */
    data: XOR<ServiceSetCreateInput, ServiceSetUncheckedCreateInput>
  }

  /**
   * ServiceSet createMany
   */
  export type ServiceSetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceSets.
     */
    data: ServiceSetCreateManyInput | ServiceSetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceSet createManyAndReturn
   */
  export type ServiceSetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSet
     */
    select?: ServiceSetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSet
     */
    omit?: ServiceSetOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceSets.
     */
    data: ServiceSetCreateManyInput | ServiceSetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceSet update
   */
  export type ServiceSetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSet
     */
    select?: ServiceSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSet
     */
    omit?: ServiceSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSetInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceSet.
     */
    data: XOR<ServiceSetUpdateInput, ServiceSetUncheckedUpdateInput>
    /**
     * Choose, which ServiceSet to update.
     */
    where: ServiceSetWhereUniqueInput
  }

  /**
   * ServiceSet updateMany
   */
  export type ServiceSetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceSets.
     */
    data: XOR<ServiceSetUpdateManyMutationInput, ServiceSetUncheckedUpdateManyInput>
    /**
     * Filter which ServiceSets to update
     */
    where?: ServiceSetWhereInput
    /**
     * Limit how many ServiceSets to update.
     */
    limit?: number
  }

  /**
   * ServiceSet updateManyAndReturn
   */
  export type ServiceSetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSet
     */
    select?: ServiceSetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSet
     */
    omit?: ServiceSetOmit<ExtArgs> | null
    /**
     * The data used to update ServiceSets.
     */
    data: XOR<ServiceSetUpdateManyMutationInput, ServiceSetUncheckedUpdateManyInput>
    /**
     * Filter which ServiceSets to update
     */
    where?: ServiceSetWhereInput
    /**
     * Limit how many ServiceSets to update.
     */
    limit?: number
  }

  /**
   * ServiceSet upsert
   */
  export type ServiceSetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSet
     */
    select?: ServiceSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSet
     */
    omit?: ServiceSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSetInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceSet to update in case it exists.
     */
    where: ServiceSetWhereUniqueInput
    /**
     * In case the ServiceSet found by the `where` argument doesn't exist, create a new ServiceSet with this data.
     */
    create: XOR<ServiceSetCreateInput, ServiceSetUncheckedCreateInput>
    /**
     * In case the ServiceSet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceSetUpdateInput, ServiceSetUncheckedUpdateInput>
  }

  /**
   * ServiceSet delete
   */
  export type ServiceSetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSet
     */
    select?: ServiceSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSet
     */
    omit?: ServiceSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSetInclude<ExtArgs> | null
    /**
     * Filter which ServiceSet to delete.
     */
    where: ServiceSetWhereUniqueInput
  }

  /**
   * ServiceSet deleteMany
   */
  export type ServiceSetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceSets to delete
     */
    where?: ServiceSetWhereInput
    /**
     * Limit how many ServiceSets to delete.
     */
    limit?: number
  }

  /**
   * ServiceSet.services
   */
  export type ServiceSet$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * ServiceSet.giftCertificates
   */
  export type ServiceSet$giftCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCertificate
     */
    select?: GiftCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GiftCertificate
     */
    omit?: GiftCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCertificateInclude<ExtArgs> | null
    where?: GiftCertificateWhereInput
    orderBy?: GiftCertificateOrderByWithRelationInput | GiftCertificateOrderByWithRelationInput[]
    cursor?: GiftCertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GiftCertificateScalarFieldEnum | GiftCertificateScalarFieldEnum[]
  }

  /**
   * ServiceSet.AvailedService
   */
  export type ServiceSet$AvailedServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailedService
     */
    select?: AvailedServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailedService
     */
    omit?: AvailedServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailedServiceInclude<ExtArgs> | null
    where?: AvailedServiceWhereInput
    orderBy?: AvailedServiceOrderByWithRelationInput | AvailedServiceOrderByWithRelationInput[]
    cursor?: AvailedServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvailedServiceScalarFieldEnum | AvailedServiceScalarFieldEnum[]
  }

  /**
   * ServiceSet without action
   */
  export type ServiceSetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSet
     */
    select?: ServiceSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSet
     */
    omit?: ServiceSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSetInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    totalPaid: number | null
  }

  export type CustomerSumAggregateOutputType = {
    totalPaid: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    totalPaid: number | null
    nextAppointment: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    totalPaid: number | null
    nextAppointment: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    email: number
    totalPaid: number
    nextAppointment: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    totalPaid?: true
  }

  export type CustomerSumAggregateInputType = {
    totalPaid?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    totalPaid?: true
    nextAppointment?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    totalPaid?: true
    nextAppointment?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    totalPaid?: true
    nextAppointment?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    name: string
    email: string | null
    totalPaid: number
    nextAppointment: Date | null
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    totalPaid?: boolean
    nextAppointment?: boolean
    recommendedAppointments?: boolean | Customer$recommendedAppointmentsArgs<ExtArgs>
    transactionHistory?: boolean | Customer$transactionHistoryArgs<ExtArgs>
    purchasedGiftCertificates?: boolean | Customer$purchasedGiftCertificatesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    totalPaid?: boolean
    nextAppointment?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    totalPaid?: boolean
    nextAppointment?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    totalPaid?: boolean
    nextAppointment?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "totalPaid" | "nextAppointment", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recommendedAppointments?: boolean | Customer$recommendedAppointmentsArgs<ExtArgs>
    transactionHistory?: boolean | Customer$transactionHistoryArgs<ExtArgs>
    purchasedGiftCertificates?: boolean | Customer$purchasedGiftCertificatesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      recommendedAppointments: Prisma.$RecommendedAppointmentPayload<ExtArgs>[]
      transactionHistory: Prisma.$TransactionPayload<ExtArgs>[]
      purchasedGiftCertificates: Prisma.$GiftCertificatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string | null
      totalPaid: number
      nextAppointment: Date | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recommendedAppointments<T extends Customer$recommendedAppointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$recommendedAppointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendedAppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactionHistory<T extends Customer$transactionHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Customer$transactionHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchasedGiftCertificates<T extends Customer$purchasedGiftCertificatesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$purchasedGiftCertificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiftCertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly totalPaid: FieldRef<"Customer", 'Float'>
    readonly nextAppointment: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.recommendedAppointments
   */
  export type Customer$recommendedAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedAppointment
     */
    select?: RecommendedAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedAppointment
     */
    omit?: RecommendedAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAppointmentInclude<ExtArgs> | null
    where?: RecommendedAppointmentWhereInput
    orderBy?: RecommendedAppointmentOrderByWithRelationInput | RecommendedAppointmentOrderByWithRelationInput[]
    cursor?: RecommendedAppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecommendedAppointmentScalarFieldEnum | RecommendedAppointmentScalarFieldEnum[]
  }

  /**
   * Customer.transactionHistory
   */
  export type Customer$transactionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Customer.purchasedGiftCertificates
   */
  export type Customer$purchasedGiftCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCertificate
     */
    select?: GiftCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GiftCertificate
     */
    omit?: GiftCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCertificateInclude<ExtArgs> | null
    where?: GiftCertificateWhereInput
    orderBy?: GiftCertificateOrderByWithRelationInput | GiftCertificateOrderByWithRelationInput[]
    cursor?: GiftCertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GiftCertificateScalarFieldEnum | GiftCertificateScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Voucher
   */

  export type AggregateVoucher = {
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  export type VoucherAvgAggregateOutputType = {
    value: number | null
  }

  export type VoucherSumAggregateOutputType = {
    value: number | null
  }

  export type VoucherMinAggregateOutputType = {
    id: string | null
    code: string | null
    value: number | null
    usedAt: Date | null
  }

  export type VoucherMaxAggregateOutputType = {
    id: string | null
    code: string | null
    value: number | null
    usedAt: Date | null
  }

  export type VoucherCountAggregateOutputType = {
    id: number
    code: number
    value: number
    usedAt: number
    _all: number
  }


  export type VoucherAvgAggregateInputType = {
    value?: true
  }

  export type VoucherSumAggregateInputType = {
    value?: true
  }

  export type VoucherMinAggregateInputType = {
    id?: true
    code?: true
    value?: true
    usedAt?: true
  }

  export type VoucherMaxAggregateInputType = {
    id?: true
    code?: true
    value?: true
    usedAt?: true
  }

  export type VoucherCountAggregateInputType = {
    id?: true
    code?: true
    value?: true
    usedAt?: true
    _all?: true
  }

  export type VoucherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Voucher to aggregate.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vouchers
    **/
    _count?: true | VoucherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoucherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoucherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoucherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoucherMaxAggregateInputType
  }

  export type GetVoucherAggregateType<T extends VoucherAggregateArgs> = {
        [P in keyof T & keyof AggregateVoucher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoucher[P]>
      : GetScalarType<T[P], AggregateVoucher[P]>
  }




  export type VoucherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithAggregationInput | VoucherOrderByWithAggregationInput[]
    by: VoucherScalarFieldEnum[] | VoucherScalarFieldEnum
    having?: VoucherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoucherCountAggregateInputType | true
    _avg?: VoucherAvgAggregateInputType
    _sum?: VoucherSumAggregateInputType
    _min?: VoucherMinAggregateInputType
    _max?: VoucherMaxAggregateInputType
  }

  export type VoucherGroupByOutputType = {
    id: string
    code: string
    value: number
    usedAt: Date | null
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  type GetVoucherGroupByPayload<T extends VoucherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoucherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoucherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoucherGroupByOutputType[P]>
            : GetScalarType<T[P], VoucherGroupByOutputType[P]>
        }
      >
    >


  export type VoucherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    value?: boolean
    usedAt?: boolean
    Transaction?: boolean | Voucher$TransactionArgs<ExtArgs>
    _count?: boolean | VoucherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    value?: boolean
    usedAt?: boolean
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    value?: boolean
    usedAt?: boolean
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectScalar = {
    id?: boolean
    code?: boolean
    value?: boolean
    usedAt?: boolean
  }

  export type VoucherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "value" | "usedAt", ExtArgs["result"]["voucher"]>
  export type VoucherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Transaction?: boolean | Voucher$TransactionArgs<ExtArgs>
    _count?: boolean | VoucherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VoucherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VoucherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VoucherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Voucher"
    objects: {
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      value: number
      usedAt: Date | null
    }, ExtArgs["result"]["voucher"]>
    composites: {}
  }

  type VoucherGetPayload<S extends boolean | null | undefined | VoucherDefaultArgs> = $Result.GetResult<Prisma.$VoucherPayload, S>

  type VoucherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoucherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoucherCountAggregateInputType | true
    }

  export interface VoucherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Voucher'], meta: { name: 'Voucher' } }
    /**
     * Find zero or one Voucher that matches the filter.
     * @param {VoucherFindUniqueArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoucherFindUniqueArgs>(args: SelectSubset<T, VoucherFindUniqueArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Voucher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoucherFindUniqueOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoucherFindUniqueOrThrowArgs>(args: SelectSubset<T, VoucherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voucher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoucherFindFirstArgs>(args?: SelectSubset<T, VoucherFindFirstArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voucher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoucherFindFirstOrThrowArgs>(args?: SelectSubset<T, VoucherFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vouchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vouchers
     * const vouchers = await prisma.voucher.findMany()
     * 
     * // Get first 10 Vouchers
     * const vouchers = await prisma.voucher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voucherWithIdOnly = await prisma.voucher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoucherFindManyArgs>(args?: SelectSubset<T, VoucherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Voucher.
     * @param {VoucherCreateArgs} args - Arguments to create a Voucher.
     * @example
     * // Create one Voucher
     * const Voucher = await prisma.voucher.create({
     *   data: {
     *     // ... data to create a Voucher
     *   }
     * })
     * 
     */
    create<T extends VoucherCreateArgs>(args: SelectSubset<T, VoucherCreateArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vouchers.
     * @param {VoucherCreateManyArgs} args - Arguments to create many Vouchers.
     * @example
     * // Create many Vouchers
     * const voucher = await prisma.voucher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoucherCreateManyArgs>(args?: SelectSubset<T, VoucherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vouchers and returns the data saved in the database.
     * @param {VoucherCreateManyAndReturnArgs} args - Arguments to create many Vouchers.
     * @example
     * // Create many Vouchers
     * const voucher = await prisma.voucher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vouchers and only return the `id`
     * const voucherWithIdOnly = await prisma.voucher.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoucherCreateManyAndReturnArgs>(args?: SelectSubset<T, VoucherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Voucher.
     * @param {VoucherDeleteArgs} args - Arguments to delete one Voucher.
     * @example
     * // Delete one Voucher
     * const Voucher = await prisma.voucher.delete({
     *   where: {
     *     // ... filter to delete one Voucher
     *   }
     * })
     * 
     */
    delete<T extends VoucherDeleteArgs>(args: SelectSubset<T, VoucherDeleteArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Voucher.
     * @param {VoucherUpdateArgs} args - Arguments to update one Voucher.
     * @example
     * // Update one Voucher
     * const voucher = await prisma.voucher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoucherUpdateArgs>(args: SelectSubset<T, VoucherUpdateArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vouchers.
     * @param {VoucherDeleteManyArgs} args - Arguments to filter Vouchers to delete.
     * @example
     * // Delete a few Vouchers
     * const { count } = await prisma.voucher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoucherDeleteManyArgs>(args?: SelectSubset<T, VoucherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vouchers
     * const voucher = await prisma.voucher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoucherUpdateManyArgs>(args: SelectSubset<T, VoucherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vouchers and returns the data updated in the database.
     * @param {VoucherUpdateManyAndReturnArgs} args - Arguments to update many Vouchers.
     * @example
     * // Update many Vouchers
     * const voucher = await prisma.voucher.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vouchers and only return the `id`
     * const voucherWithIdOnly = await prisma.voucher.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoucherUpdateManyAndReturnArgs>(args: SelectSubset<T, VoucherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Voucher.
     * @param {VoucherUpsertArgs} args - Arguments to update or create a Voucher.
     * @example
     * // Update or create a Voucher
     * const voucher = await prisma.voucher.upsert({
     *   create: {
     *     // ... data to create a Voucher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Voucher we want to update
     *   }
     * })
     */
    upsert<T extends VoucherUpsertArgs>(args: SelectSubset<T, VoucherUpsertArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherCountArgs} args - Arguments to filter Vouchers to count.
     * @example
     * // Count the number of Vouchers
     * const count = await prisma.voucher.count({
     *   where: {
     *     // ... the filter for the Vouchers we want to count
     *   }
     * })
    **/
    count<T extends VoucherCountArgs>(
      args?: Subset<T, VoucherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoucherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoucherAggregateArgs>(args: Subset<T, VoucherAggregateArgs>): Prisma.PrismaPromise<GetVoucherAggregateType<T>>

    /**
     * Group by Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoucherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoucherGroupByArgs['orderBy'] }
        : { orderBy?: VoucherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoucherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoucherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Voucher model
   */
  readonly fields: VoucherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Voucher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoucherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Transaction<T extends Voucher$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Voucher model
   */
  interface VoucherFieldRefs {
    readonly id: FieldRef<"Voucher", 'String'>
    readonly code: FieldRef<"Voucher", 'String'>
    readonly value: FieldRef<"Voucher", 'Int'>
    readonly usedAt: FieldRef<"Voucher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Voucher findUnique
   */
  export type VoucherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher findUniqueOrThrow
   */
  export type VoucherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher findFirst
   */
  export type VoucherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher findFirstOrThrow
   */
  export type VoucherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher findMany
   */
  export type VoucherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Vouchers to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher create
   */
  export type VoucherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to create a Voucher.
     */
    data: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
  }

  /**
   * Voucher createMany
   */
  export type VoucherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vouchers.
     */
    data: VoucherCreateManyInput | VoucherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Voucher createManyAndReturn
   */
  export type VoucherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * The data used to create many Vouchers.
     */
    data: VoucherCreateManyInput | VoucherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Voucher update
   */
  export type VoucherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to update a Voucher.
     */
    data: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
    /**
     * Choose, which Voucher to update.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher updateMany
   */
  export type VoucherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vouchers.
     */
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyInput>
    /**
     * Filter which Vouchers to update
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to update.
     */
    limit?: number
  }

  /**
   * Voucher updateManyAndReturn
   */
  export type VoucherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * The data used to update Vouchers.
     */
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyInput>
    /**
     * Filter which Vouchers to update
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to update.
     */
    limit?: number
  }

  /**
   * Voucher upsert
   */
  export type VoucherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The filter to search for the Voucher to update in case it exists.
     */
    where: VoucherWhereUniqueInput
    /**
     * In case the Voucher found by the `where` argument doesn't exist, create a new Voucher with this data.
     */
    create: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
    /**
     * In case the Voucher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
  }

  /**
   * Voucher delete
   */
  export type VoucherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter which Voucher to delete.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher deleteMany
   */
  export type VoucherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vouchers to delete
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to delete.
     */
    limit?: number
  }

  /**
   * Voucher.Transaction
   */
  export type Voucher$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Voucher without action
   */
  export type VoucherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    discount: number | null
    grandTotal: number | null
  }

  export type TransactionSumAggregateOutputType = {
    discount: number | null
    grandTotal: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    bookedFor: Date | null
    customerId: string | null
    voucherId: string | null
    discount: number | null
    paymentMethod: $Enums.PaymentMethod | null
    grandTotal: number | null
    status: $Enums.Status | null
    branchId: string | null
    bookingReminderSentAt: Date | null
    giftCertificateId: string | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    bookedFor: Date | null
    customerId: string | null
    voucherId: string | null
    discount: number | null
    paymentMethod: $Enums.PaymentMethod | null
    grandTotal: number | null
    status: $Enums.Status | null
    branchId: string | null
    bookingReminderSentAt: Date | null
    giftCertificateId: string | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    createdAt: number
    bookedFor: number
    customerId: number
    voucherId: number
    discount: number
    paymentMethod: number
    grandTotal: number
    status: number
    branchId: number
    bookingReminderSentAt: number
    giftCertificateId: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    discount?: true
    grandTotal?: true
  }

  export type TransactionSumAggregateInputType = {
    discount?: true
    grandTotal?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    createdAt?: true
    bookedFor?: true
    customerId?: true
    voucherId?: true
    discount?: true
    paymentMethod?: true
    grandTotal?: true
    status?: true
    branchId?: true
    bookingReminderSentAt?: true
    giftCertificateId?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    bookedFor?: true
    customerId?: true
    voucherId?: true
    discount?: true
    paymentMethod?: true
    grandTotal?: true
    status?: true
    branchId?: true
    bookingReminderSentAt?: true
    giftCertificateId?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    createdAt?: true
    bookedFor?: true
    customerId?: true
    voucherId?: true
    discount?: true
    paymentMethod?: true
    grandTotal?: true
    status?: true
    branchId?: true
    bookingReminderSentAt?: true
    giftCertificateId?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    createdAt: Date
    bookedFor: Date
    customerId: string
    voucherId: string | null
    discount: number
    paymentMethod: $Enums.PaymentMethod | null
    grandTotal: number
    status: $Enums.Status
    branchId: string | null
    bookingReminderSentAt: Date | null
    giftCertificateId: string | null
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    bookedFor?: boolean
    customerId?: boolean
    voucherId?: boolean
    discount?: boolean
    paymentMethod?: boolean
    grandTotal?: boolean
    status?: boolean
    branchId?: boolean
    bookingReminderSentAt?: boolean
    giftCertificateId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    availedServices?: boolean | Transaction$availedServicesArgs<ExtArgs>
    voucherUsed?: boolean | Transaction$voucherUsedArgs<ExtArgs>
    branch?: boolean | Transaction$branchArgs<ExtArgs>
    giftCertificateUsed?: boolean | Transaction$giftCertificateUsedArgs<ExtArgs>
    originatingRecommendations?: boolean | Transaction$originatingRecommendationsArgs<ExtArgs>
    attendedAppointment?: boolean | Transaction$attendedAppointmentArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    bookedFor?: boolean
    customerId?: boolean
    voucherId?: boolean
    discount?: boolean
    paymentMethod?: boolean
    grandTotal?: boolean
    status?: boolean
    branchId?: boolean
    bookingReminderSentAt?: boolean
    giftCertificateId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    voucherUsed?: boolean | Transaction$voucherUsedArgs<ExtArgs>
    branch?: boolean | Transaction$branchArgs<ExtArgs>
    giftCertificateUsed?: boolean | Transaction$giftCertificateUsedArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    bookedFor?: boolean
    customerId?: boolean
    voucherId?: boolean
    discount?: boolean
    paymentMethod?: boolean
    grandTotal?: boolean
    status?: boolean
    branchId?: boolean
    bookingReminderSentAt?: boolean
    giftCertificateId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    voucherUsed?: boolean | Transaction$voucherUsedArgs<ExtArgs>
    branch?: boolean | Transaction$branchArgs<ExtArgs>
    giftCertificateUsed?: boolean | Transaction$giftCertificateUsedArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    bookedFor?: boolean
    customerId?: boolean
    voucherId?: boolean
    discount?: boolean
    paymentMethod?: boolean
    grandTotal?: boolean
    status?: boolean
    branchId?: boolean
    bookingReminderSentAt?: boolean
    giftCertificateId?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "bookedFor" | "customerId" | "voucherId" | "discount" | "paymentMethod" | "grandTotal" | "status" | "branchId" | "bookingReminderSentAt" | "giftCertificateId", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    availedServices?: boolean | Transaction$availedServicesArgs<ExtArgs>
    voucherUsed?: boolean | Transaction$voucherUsedArgs<ExtArgs>
    branch?: boolean | Transaction$branchArgs<ExtArgs>
    giftCertificateUsed?: boolean | Transaction$giftCertificateUsedArgs<ExtArgs>
    originatingRecommendations?: boolean | Transaction$originatingRecommendationsArgs<ExtArgs>
    attendedAppointment?: boolean | Transaction$attendedAppointmentArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    voucherUsed?: boolean | Transaction$voucherUsedArgs<ExtArgs>
    branch?: boolean | Transaction$branchArgs<ExtArgs>
    giftCertificateUsed?: boolean | Transaction$giftCertificateUsedArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    voucherUsed?: boolean | Transaction$voucherUsedArgs<ExtArgs>
    branch?: boolean | Transaction$branchArgs<ExtArgs>
    giftCertificateUsed?: boolean | Transaction$giftCertificateUsedArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      availedServices: Prisma.$AvailedServicePayload<ExtArgs>[]
      voucherUsed: Prisma.$VoucherPayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs> | null
      giftCertificateUsed: Prisma.$GiftCertificatePayload<ExtArgs> | null
      originatingRecommendations: Prisma.$RecommendedAppointmentPayload<ExtArgs>[]
      attendedAppointment: Prisma.$RecommendedAppointmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      bookedFor: Date
      customerId: string
      voucherId: string | null
      discount: number
      paymentMethod: $Enums.PaymentMethod | null
      grandTotal: number
      status: $Enums.Status
      branchId: string | null
      bookingReminderSentAt: Date | null
      giftCertificateId: string | null
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    availedServices<T extends Transaction$availedServicesArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$availedServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailedServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    voucherUsed<T extends Transaction$voucherUsedArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$voucherUsedArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    branch<T extends Transaction$branchArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    giftCertificateUsed<T extends Transaction$giftCertificateUsedArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$giftCertificateUsedArgs<ExtArgs>>): Prisma__GiftCertificateClient<$Result.GetResult<Prisma.$GiftCertificatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    originatingRecommendations<T extends Transaction$originatingRecommendationsArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$originatingRecommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendedAppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendedAppointment<T extends Transaction$attendedAppointmentArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$attendedAppointmentArgs<ExtArgs>>): Prisma__RecommendedAppointmentClient<$Result.GetResult<Prisma.$RecommendedAppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly bookedFor: FieldRef<"Transaction", 'DateTime'>
    readonly customerId: FieldRef<"Transaction", 'String'>
    readonly voucherId: FieldRef<"Transaction", 'String'>
    readonly discount: FieldRef<"Transaction", 'Int'>
    readonly paymentMethod: FieldRef<"Transaction", 'PaymentMethod'>
    readonly grandTotal: FieldRef<"Transaction", 'Int'>
    readonly status: FieldRef<"Transaction", 'Status'>
    readonly branchId: FieldRef<"Transaction", 'String'>
    readonly bookingReminderSentAt: FieldRef<"Transaction", 'DateTime'>
    readonly giftCertificateId: FieldRef<"Transaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.availedServices
   */
  export type Transaction$availedServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailedService
     */
    select?: AvailedServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailedService
     */
    omit?: AvailedServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailedServiceInclude<ExtArgs> | null
    where?: AvailedServiceWhereInput
    orderBy?: AvailedServiceOrderByWithRelationInput | AvailedServiceOrderByWithRelationInput[]
    cursor?: AvailedServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvailedServiceScalarFieldEnum | AvailedServiceScalarFieldEnum[]
  }

  /**
   * Transaction.voucherUsed
   */
  export type Transaction$voucherUsedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    where?: VoucherWhereInput
  }

  /**
   * Transaction.branch
   */
  export type Transaction$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Transaction.giftCertificateUsed
   */
  export type Transaction$giftCertificateUsedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCertificate
     */
    select?: GiftCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GiftCertificate
     */
    omit?: GiftCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCertificateInclude<ExtArgs> | null
    where?: GiftCertificateWhereInput
  }

  /**
   * Transaction.originatingRecommendations
   */
  export type Transaction$originatingRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedAppointment
     */
    select?: RecommendedAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedAppointment
     */
    omit?: RecommendedAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAppointmentInclude<ExtArgs> | null
    where?: RecommendedAppointmentWhereInput
    orderBy?: RecommendedAppointmentOrderByWithRelationInput | RecommendedAppointmentOrderByWithRelationInput[]
    cursor?: RecommendedAppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecommendedAppointmentScalarFieldEnum | RecommendedAppointmentScalarFieldEnum[]
  }

  /**
   * Transaction.attendedAppointment
   */
  export type Transaction$attendedAppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedAppointment
     */
    select?: RecommendedAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedAppointment
     */
    omit?: RecommendedAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAppointmentInclude<ExtArgs> | null
    where?: RecommendedAppointmentWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model AvailedService
   */

  export type AggregateAvailedService = {
    _count: AvailedServiceCountAggregateOutputType | null
    _avg: AvailedServiceAvgAggregateOutputType | null
    _sum: AvailedServiceSumAggregateOutputType | null
    _min: AvailedServiceMinAggregateOutputType | null
    _max: AvailedServiceMaxAggregateOutputType | null
  }

  export type AvailedServiceAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
    commissionValue: number | null
  }

  export type AvailedServiceSumAggregateOutputType = {
    quantity: number | null
    price: number | null
    commissionValue: number | null
  }

  export type AvailedServiceMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    serviceId: string | null
    quantity: number | null
    price: number | null
    commissionValue: number | null
    originatingSetId: string | null
    originatingSetTitle: string | null
    checkedById: string | null
    servedById: string | null
    serviceSetId: string | null
    status: $Enums.Status | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvailedServiceMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    serviceId: string | null
    quantity: number | null
    price: number | null
    commissionValue: number | null
    originatingSetId: string | null
    originatingSetTitle: string | null
    checkedById: string | null
    servedById: string | null
    serviceSetId: string | null
    status: $Enums.Status | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvailedServiceCountAggregateOutputType = {
    id: number
    transactionId: number
    serviceId: number
    quantity: number
    price: number
    commissionValue: number
    originatingSetId: number
    originatingSetTitle: number
    checkedById: number
    servedById: number
    serviceSetId: number
    status: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AvailedServiceAvgAggregateInputType = {
    quantity?: true
    price?: true
    commissionValue?: true
  }

  export type AvailedServiceSumAggregateInputType = {
    quantity?: true
    price?: true
    commissionValue?: true
  }

  export type AvailedServiceMinAggregateInputType = {
    id?: true
    transactionId?: true
    serviceId?: true
    quantity?: true
    price?: true
    commissionValue?: true
    originatingSetId?: true
    originatingSetTitle?: true
    checkedById?: true
    servedById?: true
    serviceSetId?: true
    status?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvailedServiceMaxAggregateInputType = {
    id?: true
    transactionId?: true
    serviceId?: true
    quantity?: true
    price?: true
    commissionValue?: true
    originatingSetId?: true
    originatingSetTitle?: true
    checkedById?: true
    servedById?: true
    serviceSetId?: true
    status?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvailedServiceCountAggregateInputType = {
    id?: true
    transactionId?: true
    serviceId?: true
    quantity?: true
    price?: true
    commissionValue?: true
    originatingSetId?: true
    originatingSetTitle?: true
    checkedById?: true
    servedById?: true
    serviceSetId?: true
    status?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AvailedServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AvailedService to aggregate.
     */
    where?: AvailedServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvailedServices to fetch.
     */
    orderBy?: AvailedServiceOrderByWithRelationInput | AvailedServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvailedServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvailedServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvailedServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AvailedServices
    **/
    _count?: true | AvailedServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AvailedServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AvailedServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvailedServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvailedServiceMaxAggregateInputType
  }

  export type GetAvailedServiceAggregateType<T extends AvailedServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateAvailedService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvailedService[P]>
      : GetScalarType<T[P], AggregateAvailedService[P]>
  }




  export type AvailedServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailedServiceWhereInput
    orderBy?: AvailedServiceOrderByWithAggregationInput | AvailedServiceOrderByWithAggregationInput[]
    by: AvailedServiceScalarFieldEnum[] | AvailedServiceScalarFieldEnum
    having?: AvailedServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvailedServiceCountAggregateInputType | true
    _avg?: AvailedServiceAvgAggregateInputType
    _sum?: AvailedServiceSumAggregateInputType
    _min?: AvailedServiceMinAggregateInputType
    _max?: AvailedServiceMaxAggregateInputType
  }

  export type AvailedServiceGroupByOutputType = {
    id: string
    transactionId: string
    serviceId: string | null
    quantity: number
    price: number
    commissionValue: number
    originatingSetId: string | null
    originatingSetTitle: string | null
    checkedById: string | null
    servedById: string | null
    serviceSetId: string | null
    status: $Enums.Status
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AvailedServiceCountAggregateOutputType | null
    _avg: AvailedServiceAvgAggregateOutputType | null
    _sum: AvailedServiceSumAggregateOutputType | null
    _min: AvailedServiceMinAggregateOutputType | null
    _max: AvailedServiceMaxAggregateOutputType | null
  }

  type GetAvailedServiceGroupByPayload<T extends AvailedServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvailedServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvailedServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvailedServiceGroupByOutputType[P]>
            : GetScalarType<T[P], AvailedServiceGroupByOutputType[P]>
        }
      >
    >


  export type AvailedServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    serviceId?: boolean
    quantity?: boolean
    price?: boolean
    commissionValue?: boolean
    originatingSetId?: boolean
    originatingSetTitle?: boolean
    checkedById?: boolean
    servedById?: boolean
    serviceSetId?: boolean
    status?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    service?: boolean | AvailedService$serviceArgs<ExtArgs>
    originatingSet?: boolean | AvailedService$originatingSetArgs<ExtArgs>
    checkedBy?: boolean | AvailedService$checkedByArgs<ExtArgs>
    servedBy?: boolean | AvailedService$servedByArgs<ExtArgs>
    recommendedAppointment?: boolean | AvailedService$recommendedAppointmentArgs<ExtArgs>
  }, ExtArgs["result"]["availedService"]>

  export type AvailedServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    serviceId?: boolean
    quantity?: boolean
    price?: boolean
    commissionValue?: boolean
    originatingSetId?: boolean
    originatingSetTitle?: boolean
    checkedById?: boolean
    servedById?: boolean
    serviceSetId?: boolean
    status?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    service?: boolean | AvailedService$serviceArgs<ExtArgs>
    originatingSet?: boolean | AvailedService$originatingSetArgs<ExtArgs>
    checkedBy?: boolean | AvailedService$checkedByArgs<ExtArgs>
    servedBy?: boolean | AvailedService$servedByArgs<ExtArgs>
  }, ExtArgs["result"]["availedService"]>

  export type AvailedServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    serviceId?: boolean
    quantity?: boolean
    price?: boolean
    commissionValue?: boolean
    originatingSetId?: boolean
    originatingSetTitle?: boolean
    checkedById?: boolean
    servedById?: boolean
    serviceSetId?: boolean
    status?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    service?: boolean | AvailedService$serviceArgs<ExtArgs>
    originatingSet?: boolean | AvailedService$originatingSetArgs<ExtArgs>
    checkedBy?: boolean | AvailedService$checkedByArgs<ExtArgs>
    servedBy?: boolean | AvailedService$servedByArgs<ExtArgs>
  }, ExtArgs["result"]["availedService"]>

  export type AvailedServiceSelectScalar = {
    id?: boolean
    transactionId?: boolean
    serviceId?: boolean
    quantity?: boolean
    price?: boolean
    commissionValue?: boolean
    originatingSetId?: boolean
    originatingSetTitle?: boolean
    checkedById?: boolean
    servedById?: boolean
    serviceSetId?: boolean
    status?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AvailedServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "serviceId" | "quantity" | "price" | "commissionValue" | "originatingSetId" | "originatingSetTitle" | "checkedById" | "servedById" | "serviceSetId" | "status" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["availedService"]>
  export type AvailedServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    service?: boolean | AvailedService$serviceArgs<ExtArgs>
    originatingSet?: boolean | AvailedService$originatingSetArgs<ExtArgs>
    checkedBy?: boolean | AvailedService$checkedByArgs<ExtArgs>
    servedBy?: boolean | AvailedService$servedByArgs<ExtArgs>
    recommendedAppointment?: boolean | AvailedService$recommendedAppointmentArgs<ExtArgs>
  }
  export type AvailedServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    service?: boolean | AvailedService$serviceArgs<ExtArgs>
    originatingSet?: boolean | AvailedService$originatingSetArgs<ExtArgs>
    checkedBy?: boolean | AvailedService$checkedByArgs<ExtArgs>
    servedBy?: boolean | AvailedService$servedByArgs<ExtArgs>
  }
  export type AvailedServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    service?: boolean | AvailedService$serviceArgs<ExtArgs>
    originatingSet?: boolean | AvailedService$originatingSetArgs<ExtArgs>
    checkedBy?: boolean | AvailedService$checkedByArgs<ExtArgs>
    servedBy?: boolean | AvailedService$servedByArgs<ExtArgs>
  }

  export type $AvailedServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AvailedService"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs> | null
      originatingSet: Prisma.$ServiceSetPayload<ExtArgs> | null
      checkedBy: Prisma.$AccountPayload<ExtArgs> | null
      servedBy: Prisma.$AccountPayload<ExtArgs> | null
      recommendedAppointment: Prisma.$RecommendedAppointmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      serviceId: string | null
      quantity: number
      price: number
      commissionValue: number
      originatingSetId: string | null
      originatingSetTitle: string | null
      checkedById: string | null
      servedById: string | null
      serviceSetId: string | null
      status: $Enums.Status
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["availedService"]>
    composites: {}
  }

  type AvailedServiceGetPayload<S extends boolean | null | undefined | AvailedServiceDefaultArgs> = $Result.GetResult<Prisma.$AvailedServicePayload, S>

  type AvailedServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AvailedServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AvailedServiceCountAggregateInputType | true
    }

  export interface AvailedServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AvailedService'], meta: { name: 'AvailedService' } }
    /**
     * Find zero or one AvailedService that matches the filter.
     * @param {AvailedServiceFindUniqueArgs} args - Arguments to find a AvailedService
     * @example
     * // Get one AvailedService
     * const availedService = await prisma.availedService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvailedServiceFindUniqueArgs>(args: SelectSubset<T, AvailedServiceFindUniqueArgs<ExtArgs>>): Prisma__AvailedServiceClient<$Result.GetResult<Prisma.$AvailedServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AvailedService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AvailedServiceFindUniqueOrThrowArgs} args - Arguments to find a AvailedService
     * @example
     * // Get one AvailedService
     * const availedService = await prisma.availedService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvailedServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, AvailedServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvailedServiceClient<$Result.GetResult<Prisma.$AvailedServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AvailedService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailedServiceFindFirstArgs} args - Arguments to find a AvailedService
     * @example
     * // Get one AvailedService
     * const availedService = await prisma.availedService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvailedServiceFindFirstArgs>(args?: SelectSubset<T, AvailedServiceFindFirstArgs<ExtArgs>>): Prisma__AvailedServiceClient<$Result.GetResult<Prisma.$AvailedServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AvailedService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailedServiceFindFirstOrThrowArgs} args - Arguments to find a AvailedService
     * @example
     * // Get one AvailedService
     * const availedService = await prisma.availedService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvailedServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, AvailedServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvailedServiceClient<$Result.GetResult<Prisma.$AvailedServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AvailedServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailedServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AvailedServices
     * const availedServices = await prisma.availedService.findMany()
     * 
     * // Get first 10 AvailedServices
     * const availedServices = await prisma.availedService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const availedServiceWithIdOnly = await prisma.availedService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvailedServiceFindManyArgs>(args?: SelectSubset<T, AvailedServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailedServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AvailedService.
     * @param {AvailedServiceCreateArgs} args - Arguments to create a AvailedService.
     * @example
     * // Create one AvailedService
     * const AvailedService = await prisma.availedService.create({
     *   data: {
     *     // ... data to create a AvailedService
     *   }
     * })
     * 
     */
    create<T extends AvailedServiceCreateArgs>(args: SelectSubset<T, AvailedServiceCreateArgs<ExtArgs>>): Prisma__AvailedServiceClient<$Result.GetResult<Prisma.$AvailedServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AvailedServices.
     * @param {AvailedServiceCreateManyArgs} args - Arguments to create many AvailedServices.
     * @example
     * // Create many AvailedServices
     * const availedService = await prisma.availedService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvailedServiceCreateManyArgs>(args?: SelectSubset<T, AvailedServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AvailedServices and returns the data saved in the database.
     * @param {AvailedServiceCreateManyAndReturnArgs} args - Arguments to create many AvailedServices.
     * @example
     * // Create many AvailedServices
     * const availedService = await prisma.availedService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AvailedServices and only return the `id`
     * const availedServiceWithIdOnly = await prisma.availedService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AvailedServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, AvailedServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailedServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AvailedService.
     * @param {AvailedServiceDeleteArgs} args - Arguments to delete one AvailedService.
     * @example
     * // Delete one AvailedService
     * const AvailedService = await prisma.availedService.delete({
     *   where: {
     *     // ... filter to delete one AvailedService
     *   }
     * })
     * 
     */
    delete<T extends AvailedServiceDeleteArgs>(args: SelectSubset<T, AvailedServiceDeleteArgs<ExtArgs>>): Prisma__AvailedServiceClient<$Result.GetResult<Prisma.$AvailedServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AvailedService.
     * @param {AvailedServiceUpdateArgs} args - Arguments to update one AvailedService.
     * @example
     * // Update one AvailedService
     * const availedService = await prisma.availedService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvailedServiceUpdateArgs>(args: SelectSubset<T, AvailedServiceUpdateArgs<ExtArgs>>): Prisma__AvailedServiceClient<$Result.GetResult<Prisma.$AvailedServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AvailedServices.
     * @param {AvailedServiceDeleteManyArgs} args - Arguments to filter AvailedServices to delete.
     * @example
     * // Delete a few AvailedServices
     * const { count } = await prisma.availedService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvailedServiceDeleteManyArgs>(args?: SelectSubset<T, AvailedServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AvailedServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailedServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AvailedServices
     * const availedService = await prisma.availedService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvailedServiceUpdateManyArgs>(args: SelectSubset<T, AvailedServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AvailedServices and returns the data updated in the database.
     * @param {AvailedServiceUpdateManyAndReturnArgs} args - Arguments to update many AvailedServices.
     * @example
     * // Update many AvailedServices
     * const availedService = await prisma.availedService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AvailedServices and only return the `id`
     * const availedServiceWithIdOnly = await prisma.availedService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AvailedServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, AvailedServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailedServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AvailedService.
     * @param {AvailedServiceUpsertArgs} args - Arguments to update or create a AvailedService.
     * @example
     * // Update or create a AvailedService
     * const availedService = await prisma.availedService.upsert({
     *   create: {
     *     // ... data to create a AvailedService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AvailedService we want to update
     *   }
     * })
     */
    upsert<T extends AvailedServiceUpsertArgs>(args: SelectSubset<T, AvailedServiceUpsertArgs<ExtArgs>>): Prisma__AvailedServiceClient<$Result.GetResult<Prisma.$AvailedServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AvailedServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailedServiceCountArgs} args - Arguments to filter AvailedServices to count.
     * @example
     * // Count the number of AvailedServices
     * const count = await prisma.availedService.count({
     *   where: {
     *     // ... the filter for the AvailedServices we want to count
     *   }
     * })
    **/
    count<T extends AvailedServiceCountArgs>(
      args?: Subset<T, AvailedServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvailedServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AvailedService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailedServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvailedServiceAggregateArgs>(args: Subset<T, AvailedServiceAggregateArgs>): Prisma.PrismaPromise<GetAvailedServiceAggregateType<T>>

    /**
     * Group by AvailedService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailedServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvailedServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvailedServiceGroupByArgs['orderBy'] }
        : { orderBy?: AvailedServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvailedServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvailedServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AvailedService model
   */
  readonly fields: AvailedServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AvailedService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvailedServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends AvailedService$serviceArgs<ExtArgs> = {}>(args?: Subset<T, AvailedService$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    originatingSet<T extends AvailedService$originatingSetArgs<ExtArgs> = {}>(args?: Subset<T, AvailedService$originatingSetArgs<ExtArgs>>): Prisma__ServiceSetClient<$Result.GetResult<Prisma.$ServiceSetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    checkedBy<T extends AvailedService$checkedByArgs<ExtArgs> = {}>(args?: Subset<T, AvailedService$checkedByArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    servedBy<T extends AvailedService$servedByArgs<ExtArgs> = {}>(args?: Subset<T, AvailedService$servedByArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    recommendedAppointment<T extends AvailedService$recommendedAppointmentArgs<ExtArgs> = {}>(args?: Subset<T, AvailedService$recommendedAppointmentArgs<ExtArgs>>): Prisma__RecommendedAppointmentClient<$Result.GetResult<Prisma.$RecommendedAppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AvailedService model
   */
  interface AvailedServiceFieldRefs {
    readonly id: FieldRef<"AvailedService", 'String'>
    readonly transactionId: FieldRef<"AvailedService", 'String'>
    readonly serviceId: FieldRef<"AvailedService", 'String'>
    readonly quantity: FieldRef<"AvailedService", 'Int'>
    readonly price: FieldRef<"AvailedService", 'Int'>
    readonly commissionValue: FieldRef<"AvailedService", 'Int'>
    readonly originatingSetId: FieldRef<"AvailedService", 'String'>
    readonly originatingSetTitle: FieldRef<"AvailedService", 'String'>
    readonly checkedById: FieldRef<"AvailedService", 'String'>
    readonly servedById: FieldRef<"AvailedService", 'String'>
    readonly serviceSetId: FieldRef<"AvailedService", 'String'>
    readonly status: FieldRef<"AvailedService", 'Status'>
    readonly completedAt: FieldRef<"AvailedService", 'DateTime'>
    readonly createdAt: FieldRef<"AvailedService", 'DateTime'>
    readonly updatedAt: FieldRef<"AvailedService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AvailedService findUnique
   */
  export type AvailedServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailedService
     */
    select?: AvailedServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailedService
     */
    omit?: AvailedServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailedServiceInclude<ExtArgs> | null
    /**
     * Filter, which AvailedService to fetch.
     */
    where: AvailedServiceWhereUniqueInput
  }

  /**
   * AvailedService findUniqueOrThrow
   */
  export type AvailedServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailedService
     */
    select?: AvailedServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailedService
     */
    omit?: AvailedServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailedServiceInclude<ExtArgs> | null
    /**
     * Filter, which AvailedService to fetch.
     */
    where: AvailedServiceWhereUniqueInput
  }

  /**
   * AvailedService findFirst
   */
  export type AvailedServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailedService
     */
    select?: AvailedServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailedService
     */
    omit?: AvailedServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailedServiceInclude<ExtArgs> | null
    /**
     * Filter, which AvailedService to fetch.
     */
    where?: AvailedServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvailedServices to fetch.
     */
    orderBy?: AvailedServiceOrderByWithRelationInput | AvailedServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AvailedServices.
     */
    cursor?: AvailedServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvailedServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvailedServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AvailedServices.
     */
    distinct?: AvailedServiceScalarFieldEnum | AvailedServiceScalarFieldEnum[]
  }

  /**
   * AvailedService findFirstOrThrow
   */
  export type AvailedServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailedService
     */
    select?: AvailedServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailedService
     */
    omit?: AvailedServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailedServiceInclude<ExtArgs> | null
    /**
     * Filter, which AvailedService to fetch.
     */
    where?: AvailedServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvailedServices to fetch.
     */
    orderBy?: AvailedServiceOrderByWithRelationInput | AvailedServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AvailedServices.
     */
    cursor?: AvailedServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvailedServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvailedServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AvailedServices.
     */
    distinct?: AvailedServiceScalarFieldEnum | AvailedServiceScalarFieldEnum[]
  }

  /**
   * AvailedService findMany
   */
  export type AvailedServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailedService
     */
    select?: AvailedServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailedService
     */
    omit?: AvailedServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailedServiceInclude<ExtArgs> | null
    /**
     * Filter, which AvailedServices to fetch.
     */
    where?: AvailedServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvailedServices to fetch.
     */
    orderBy?: AvailedServiceOrderByWithRelationInput | AvailedServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AvailedServices.
     */
    cursor?: AvailedServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvailedServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvailedServices.
     */
    skip?: number
    distinct?: AvailedServiceScalarFieldEnum | AvailedServiceScalarFieldEnum[]
  }

  /**
   * AvailedService create
   */
  export type AvailedServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailedService
     */
    select?: AvailedServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailedService
     */
    omit?: AvailedServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailedServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a AvailedService.
     */
    data: XOR<AvailedServiceCreateInput, AvailedServiceUncheckedCreateInput>
  }

  /**
   * AvailedService createMany
   */
  export type AvailedServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AvailedServices.
     */
    data: AvailedServiceCreateManyInput | AvailedServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AvailedService createManyAndReturn
   */
  export type AvailedServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailedService
     */
    select?: AvailedServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AvailedService
     */
    omit?: AvailedServiceOmit<ExtArgs> | null
    /**
     * The data used to create many AvailedServices.
     */
    data: AvailedServiceCreateManyInput | AvailedServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailedServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AvailedService update
   */
  export type AvailedServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailedService
     */
    select?: AvailedServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailedService
     */
    omit?: AvailedServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailedServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a AvailedService.
     */
    data: XOR<AvailedServiceUpdateInput, AvailedServiceUncheckedUpdateInput>
    /**
     * Choose, which AvailedService to update.
     */
    where: AvailedServiceWhereUniqueInput
  }

  /**
   * AvailedService updateMany
   */
  export type AvailedServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AvailedServices.
     */
    data: XOR<AvailedServiceUpdateManyMutationInput, AvailedServiceUncheckedUpdateManyInput>
    /**
     * Filter which AvailedServices to update
     */
    where?: AvailedServiceWhereInput
    /**
     * Limit how many AvailedServices to update.
     */
    limit?: number
  }

  /**
   * AvailedService updateManyAndReturn
   */
  export type AvailedServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailedService
     */
    select?: AvailedServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AvailedService
     */
    omit?: AvailedServiceOmit<ExtArgs> | null
    /**
     * The data used to update AvailedServices.
     */
    data: XOR<AvailedServiceUpdateManyMutationInput, AvailedServiceUncheckedUpdateManyInput>
    /**
     * Filter which AvailedServices to update
     */
    where?: AvailedServiceWhereInput
    /**
     * Limit how many AvailedServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailedServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AvailedService upsert
   */
  export type AvailedServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailedService
     */
    select?: AvailedServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailedService
     */
    omit?: AvailedServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailedServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the AvailedService to update in case it exists.
     */
    where: AvailedServiceWhereUniqueInput
    /**
     * In case the AvailedService found by the `where` argument doesn't exist, create a new AvailedService with this data.
     */
    create: XOR<AvailedServiceCreateInput, AvailedServiceUncheckedCreateInput>
    /**
     * In case the AvailedService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvailedServiceUpdateInput, AvailedServiceUncheckedUpdateInput>
  }

  /**
   * AvailedService delete
   */
  export type AvailedServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailedService
     */
    select?: AvailedServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailedService
     */
    omit?: AvailedServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailedServiceInclude<ExtArgs> | null
    /**
     * Filter which AvailedService to delete.
     */
    where: AvailedServiceWhereUniqueInput
  }

  /**
   * AvailedService deleteMany
   */
  export type AvailedServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AvailedServices to delete
     */
    where?: AvailedServiceWhereInput
    /**
     * Limit how many AvailedServices to delete.
     */
    limit?: number
  }

  /**
   * AvailedService.service
   */
  export type AvailedService$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * AvailedService.originatingSet
   */
  export type AvailedService$originatingSetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSet
     */
    select?: ServiceSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSet
     */
    omit?: ServiceSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSetInclude<ExtArgs> | null
    where?: ServiceSetWhereInput
  }

  /**
   * AvailedService.checkedBy
   */
  export type AvailedService$checkedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * AvailedService.servedBy
   */
  export type AvailedService$servedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * AvailedService.recommendedAppointment
   */
  export type AvailedService$recommendedAppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedAppointment
     */
    select?: RecommendedAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedAppointment
     */
    omit?: RecommendedAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAppointmentInclude<ExtArgs> | null
    where?: RecommendedAppointmentWhereInput
  }

  /**
   * AvailedService without action
   */
  export type AvailedServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailedService
     */
    select?: AvailedServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailedService
     */
    omit?: AvailedServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailedServiceInclude<ExtArgs> | null
  }


  /**
   * Model GiftCertificate
   */

  export type AggregateGiftCertificate = {
    _count: GiftCertificateCountAggregateOutputType | null
    _min: GiftCertificateMinAggregateOutputType | null
    _max: GiftCertificateMaxAggregateOutputType | null
  }

  export type GiftCertificateMinAggregateOutputType = {
    id: string | null
    code: string | null
    issuedAt: Date | null
    expiresAt: Date | null
    purchaserCustomerId: string | null
    recipientName: string | null
    recipientEmail: string | null
    usedAt: Date | null
  }

  export type GiftCertificateMaxAggregateOutputType = {
    id: string | null
    code: string | null
    issuedAt: Date | null
    expiresAt: Date | null
    purchaserCustomerId: string | null
    recipientName: string | null
    recipientEmail: string | null
    usedAt: Date | null
  }

  export type GiftCertificateCountAggregateOutputType = {
    id: number
    code: number
    issuedAt: number
    expiresAt: number
    purchaserCustomerId: number
    recipientName: number
    recipientEmail: number
    usedAt: number
    _all: number
  }


  export type GiftCertificateMinAggregateInputType = {
    id?: true
    code?: true
    issuedAt?: true
    expiresAt?: true
    purchaserCustomerId?: true
    recipientName?: true
    recipientEmail?: true
    usedAt?: true
  }

  export type GiftCertificateMaxAggregateInputType = {
    id?: true
    code?: true
    issuedAt?: true
    expiresAt?: true
    purchaserCustomerId?: true
    recipientName?: true
    recipientEmail?: true
    usedAt?: true
  }

  export type GiftCertificateCountAggregateInputType = {
    id?: true
    code?: true
    issuedAt?: true
    expiresAt?: true
    purchaserCustomerId?: true
    recipientName?: true
    recipientEmail?: true
    usedAt?: true
    _all?: true
  }

  export type GiftCertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GiftCertificate to aggregate.
     */
    where?: GiftCertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GiftCertificates to fetch.
     */
    orderBy?: GiftCertificateOrderByWithRelationInput | GiftCertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GiftCertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GiftCertificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GiftCertificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GiftCertificates
    **/
    _count?: true | GiftCertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GiftCertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GiftCertificateMaxAggregateInputType
  }

  export type GetGiftCertificateAggregateType<T extends GiftCertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateGiftCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGiftCertificate[P]>
      : GetScalarType<T[P], AggregateGiftCertificate[P]>
  }




  export type GiftCertificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GiftCertificateWhereInput
    orderBy?: GiftCertificateOrderByWithAggregationInput | GiftCertificateOrderByWithAggregationInput[]
    by: GiftCertificateScalarFieldEnum[] | GiftCertificateScalarFieldEnum
    having?: GiftCertificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GiftCertificateCountAggregateInputType | true
    _min?: GiftCertificateMinAggregateInputType
    _max?: GiftCertificateMaxAggregateInputType
  }

  export type GiftCertificateGroupByOutputType = {
    id: string
    code: string
    issuedAt: Date
    expiresAt: Date | null
    purchaserCustomerId: string | null
    recipientName: string | null
    recipientEmail: string | null
    usedAt: Date | null
    _count: GiftCertificateCountAggregateOutputType | null
    _min: GiftCertificateMinAggregateOutputType | null
    _max: GiftCertificateMaxAggregateOutputType | null
  }

  type GetGiftCertificateGroupByPayload<T extends GiftCertificateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GiftCertificateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GiftCertificateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GiftCertificateGroupByOutputType[P]>
            : GetScalarType<T[P], GiftCertificateGroupByOutputType[P]>
        }
      >
    >


  export type GiftCertificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    purchaserCustomerId?: boolean
    recipientName?: boolean
    recipientEmail?: boolean
    usedAt?: boolean
    purchaserCustomer?: boolean | GiftCertificate$purchaserCustomerArgs<ExtArgs>
    services?: boolean | GiftCertificate$servicesArgs<ExtArgs>
    serviceSets?: boolean | GiftCertificate$serviceSetsArgs<ExtArgs>
    transactions?: boolean | GiftCertificate$transactionsArgs<ExtArgs>
    _count?: boolean | GiftCertificateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["giftCertificate"]>

  export type GiftCertificateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    purchaserCustomerId?: boolean
    recipientName?: boolean
    recipientEmail?: boolean
    usedAt?: boolean
    purchaserCustomer?: boolean | GiftCertificate$purchaserCustomerArgs<ExtArgs>
  }, ExtArgs["result"]["giftCertificate"]>

  export type GiftCertificateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    purchaserCustomerId?: boolean
    recipientName?: boolean
    recipientEmail?: boolean
    usedAt?: boolean
    purchaserCustomer?: boolean | GiftCertificate$purchaserCustomerArgs<ExtArgs>
  }, ExtArgs["result"]["giftCertificate"]>

  export type GiftCertificateSelectScalar = {
    id?: boolean
    code?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    purchaserCustomerId?: boolean
    recipientName?: boolean
    recipientEmail?: boolean
    usedAt?: boolean
  }

  export type GiftCertificateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "issuedAt" | "expiresAt" | "purchaserCustomerId" | "recipientName" | "recipientEmail" | "usedAt", ExtArgs["result"]["giftCertificate"]>
  export type GiftCertificateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaserCustomer?: boolean | GiftCertificate$purchaserCustomerArgs<ExtArgs>
    services?: boolean | GiftCertificate$servicesArgs<ExtArgs>
    serviceSets?: boolean | GiftCertificate$serviceSetsArgs<ExtArgs>
    transactions?: boolean | GiftCertificate$transactionsArgs<ExtArgs>
    _count?: boolean | GiftCertificateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GiftCertificateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaserCustomer?: boolean | GiftCertificate$purchaserCustomerArgs<ExtArgs>
  }
  export type GiftCertificateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaserCustomer?: boolean | GiftCertificate$purchaserCustomerArgs<ExtArgs>
  }

  export type $GiftCertificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GiftCertificate"
    objects: {
      purchaserCustomer: Prisma.$CustomerPayload<ExtArgs> | null
      services: Prisma.$ServicePayload<ExtArgs>[]
      serviceSets: Prisma.$ServiceSetPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      issuedAt: Date
      expiresAt: Date | null
      purchaserCustomerId: string | null
      recipientName: string | null
      recipientEmail: string | null
      usedAt: Date | null
    }, ExtArgs["result"]["giftCertificate"]>
    composites: {}
  }

  type GiftCertificateGetPayload<S extends boolean | null | undefined | GiftCertificateDefaultArgs> = $Result.GetResult<Prisma.$GiftCertificatePayload, S>

  type GiftCertificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GiftCertificateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GiftCertificateCountAggregateInputType | true
    }

  export interface GiftCertificateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GiftCertificate'], meta: { name: 'GiftCertificate' } }
    /**
     * Find zero or one GiftCertificate that matches the filter.
     * @param {GiftCertificateFindUniqueArgs} args - Arguments to find a GiftCertificate
     * @example
     * // Get one GiftCertificate
     * const giftCertificate = await prisma.giftCertificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GiftCertificateFindUniqueArgs>(args: SelectSubset<T, GiftCertificateFindUniqueArgs<ExtArgs>>): Prisma__GiftCertificateClient<$Result.GetResult<Prisma.$GiftCertificatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GiftCertificate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GiftCertificateFindUniqueOrThrowArgs} args - Arguments to find a GiftCertificate
     * @example
     * // Get one GiftCertificate
     * const giftCertificate = await prisma.giftCertificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GiftCertificateFindUniqueOrThrowArgs>(args: SelectSubset<T, GiftCertificateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GiftCertificateClient<$Result.GetResult<Prisma.$GiftCertificatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GiftCertificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCertificateFindFirstArgs} args - Arguments to find a GiftCertificate
     * @example
     * // Get one GiftCertificate
     * const giftCertificate = await prisma.giftCertificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GiftCertificateFindFirstArgs>(args?: SelectSubset<T, GiftCertificateFindFirstArgs<ExtArgs>>): Prisma__GiftCertificateClient<$Result.GetResult<Prisma.$GiftCertificatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GiftCertificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCertificateFindFirstOrThrowArgs} args - Arguments to find a GiftCertificate
     * @example
     * // Get one GiftCertificate
     * const giftCertificate = await prisma.giftCertificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GiftCertificateFindFirstOrThrowArgs>(args?: SelectSubset<T, GiftCertificateFindFirstOrThrowArgs<ExtArgs>>): Prisma__GiftCertificateClient<$Result.GetResult<Prisma.$GiftCertificatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GiftCertificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GiftCertificates
     * const giftCertificates = await prisma.giftCertificate.findMany()
     * 
     * // Get first 10 GiftCertificates
     * const giftCertificates = await prisma.giftCertificate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const giftCertificateWithIdOnly = await prisma.giftCertificate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GiftCertificateFindManyArgs>(args?: SelectSubset<T, GiftCertificateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiftCertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GiftCertificate.
     * @param {GiftCertificateCreateArgs} args - Arguments to create a GiftCertificate.
     * @example
     * // Create one GiftCertificate
     * const GiftCertificate = await prisma.giftCertificate.create({
     *   data: {
     *     // ... data to create a GiftCertificate
     *   }
     * })
     * 
     */
    create<T extends GiftCertificateCreateArgs>(args: SelectSubset<T, GiftCertificateCreateArgs<ExtArgs>>): Prisma__GiftCertificateClient<$Result.GetResult<Prisma.$GiftCertificatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GiftCertificates.
     * @param {GiftCertificateCreateManyArgs} args - Arguments to create many GiftCertificates.
     * @example
     * // Create many GiftCertificates
     * const giftCertificate = await prisma.giftCertificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GiftCertificateCreateManyArgs>(args?: SelectSubset<T, GiftCertificateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GiftCertificates and returns the data saved in the database.
     * @param {GiftCertificateCreateManyAndReturnArgs} args - Arguments to create many GiftCertificates.
     * @example
     * // Create many GiftCertificates
     * const giftCertificate = await prisma.giftCertificate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GiftCertificates and only return the `id`
     * const giftCertificateWithIdOnly = await prisma.giftCertificate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GiftCertificateCreateManyAndReturnArgs>(args?: SelectSubset<T, GiftCertificateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiftCertificatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GiftCertificate.
     * @param {GiftCertificateDeleteArgs} args - Arguments to delete one GiftCertificate.
     * @example
     * // Delete one GiftCertificate
     * const GiftCertificate = await prisma.giftCertificate.delete({
     *   where: {
     *     // ... filter to delete one GiftCertificate
     *   }
     * })
     * 
     */
    delete<T extends GiftCertificateDeleteArgs>(args: SelectSubset<T, GiftCertificateDeleteArgs<ExtArgs>>): Prisma__GiftCertificateClient<$Result.GetResult<Prisma.$GiftCertificatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GiftCertificate.
     * @param {GiftCertificateUpdateArgs} args - Arguments to update one GiftCertificate.
     * @example
     * // Update one GiftCertificate
     * const giftCertificate = await prisma.giftCertificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GiftCertificateUpdateArgs>(args: SelectSubset<T, GiftCertificateUpdateArgs<ExtArgs>>): Prisma__GiftCertificateClient<$Result.GetResult<Prisma.$GiftCertificatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GiftCertificates.
     * @param {GiftCertificateDeleteManyArgs} args - Arguments to filter GiftCertificates to delete.
     * @example
     * // Delete a few GiftCertificates
     * const { count } = await prisma.giftCertificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GiftCertificateDeleteManyArgs>(args?: SelectSubset<T, GiftCertificateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GiftCertificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GiftCertificates
     * const giftCertificate = await prisma.giftCertificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GiftCertificateUpdateManyArgs>(args: SelectSubset<T, GiftCertificateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GiftCertificates and returns the data updated in the database.
     * @param {GiftCertificateUpdateManyAndReturnArgs} args - Arguments to update many GiftCertificates.
     * @example
     * // Update many GiftCertificates
     * const giftCertificate = await prisma.giftCertificate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GiftCertificates and only return the `id`
     * const giftCertificateWithIdOnly = await prisma.giftCertificate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GiftCertificateUpdateManyAndReturnArgs>(args: SelectSubset<T, GiftCertificateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiftCertificatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GiftCertificate.
     * @param {GiftCertificateUpsertArgs} args - Arguments to update or create a GiftCertificate.
     * @example
     * // Update or create a GiftCertificate
     * const giftCertificate = await prisma.giftCertificate.upsert({
     *   create: {
     *     // ... data to create a GiftCertificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GiftCertificate we want to update
     *   }
     * })
     */
    upsert<T extends GiftCertificateUpsertArgs>(args: SelectSubset<T, GiftCertificateUpsertArgs<ExtArgs>>): Prisma__GiftCertificateClient<$Result.GetResult<Prisma.$GiftCertificatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GiftCertificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCertificateCountArgs} args - Arguments to filter GiftCertificates to count.
     * @example
     * // Count the number of GiftCertificates
     * const count = await prisma.giftCertificate.count({
     *   where: {
     *     // ... the filter for the GiftCertificates we want to count
     *   }
     * })
    **/
    count<T extends GiftCertificateCountArgs>(
      args?: Subset<T, GiftCertificateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GiftCertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GiftCertificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GiftCertificateAggregateArgs>(args: Subset<T, GiftCertificateAggregateArgs>): Prisma.PrismaPromise<GetGiftCertificateAggregateType<T>>

    /**
     * Group by GiftCertificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GiftCertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GiftCertificateGroupByArgs['orderBy'] }
        : { orderBy?: GiftCertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GiftCertificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGiftCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GiftCertificate model
   */
  readonly fields: GiftCertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GiftCertificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GiftCertificateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaserCustomer<T extends GiftCertificate$purchaserCustomerArgs<ExtArgs> = {}>(args?: Subset<T, GiftCertificate$purchaserCustomerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    services<T extends GiftCertificate$servicesArgs<ExtArgs> = {}>(args?: Subset<T, GiftCertificate$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceSets<T extends GiftCertificate$serviceSetsArgs<ExtArgs> = {}>(args?: Subset<T, GiftCertificate$serviceSetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceSetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends GiftCertificate$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, GiftCertificate$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GiftCertificate model
   */
  interface GiftCertificateFieldRefs {
    readonly id: FieldRef<"GiftCertificate", 'String'>
    readonly code: FieldRef<"GiftCertificate", 'String'>
    readonly issuedAt: FieldRef<"GiftCertificate", 'DateTime'>
    readonly expiresAt: FieldRef<"GiftCertificate", 'DateTime'>
    readonly purchaserCustomerId: FieldRef<"GiftCertificate", 'String'>
    readonly recipientName: FieldRef<"GiftCertificate", 'String'>
    readonly recipientEmail: FieldRef<"GiftCertificate", 'String'>
    readonly usedAt: FieldRef<"GiftCertificate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GiftCertificate findUnique
   */
  export type GiftCertificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCertificate
     */
    select?: GiftCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GiftCertificate
     */
    omit?: GiftCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCertificateInclude<ExtArgs> | null
    /**
     * Filter, which GiftCertificate to fetch.
     */
    where: GiftCertificateWhereUniqueInput
  }

  /**
   * GiftCertificate findUniqueOrThrow
   */
  export type GiftCertificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCertificate
     */
    select?: GiftCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GiftCertificate
     */
    omit?: GiftCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCertificateInclude<ExtArgs> | null
    /**
     * Filter, which GiftCertificate to fetch.
     */
    where: GiftCertificateWhereUniqueInput
  }

  /**
   * GiftCertificate findFirst
   */
  export type GiftCertificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCertificate
     */
    select?: GiftCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GiftCertificate
     */
    omit?: GiftCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCertificateInclude<ExtArgs> | null
    /**
     * Filter, which GiftCertificate to fetch.
     */
    where?: GiftCertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GiftCertificates to fetch.
     */
    orderBy?: GiftCertificateOrderByWithRelationInput | GiftCertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GiftCertificates.
     */
    cursor?: GiftCertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GiftCertificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GiftCertificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GiftCertificates.
     */
    distinct?: GiftCertificateScalarFieldEnum | GiftCertificateScalarFieldEnum[]
  }

  /**
   * GiftCertificate findFirstOrThrow
   */
  export type GiftCertificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCertificate
     */
    select?: GiftCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GiftCertificate
     */
    omit?: GiftCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCertificateInclude<ExtArgs> | null
    /**
     * Filter, which GiftCertificate to fetch.
     */
    where?: GiftCertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GiftCertificates to fetch.
     */
    orderBy?: GiftCertificateOrderByWithRelationInput | GiftCertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GiftCertificates.
     */
    cursor?: GiftCertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GiftCertificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GiftCertificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GiftCertificates.
     */
    distinct?: GiftCertificateScalarFieldEnum | GiftCertificateScalarFieldEnum[]
  }

  /**
   * GiftCertificate findMany
   */
  export type GiftCertificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCertificate
     */
    select?: GiftCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GiftCertificate
     */
    omit?: GiftCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCertificateInclude<ExtArgs> | null
    /**
     * Filter, which GiftCertificates to fetch.
     */
    where?: GiftCertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GiftCertificates to fetch.
     */
    orderBy?: GiftCertificateOrderByWithRelationInput | GiftCertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GiftCertificates.
     */
    cursor?: GiftCertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GiftCertificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GiftCertificates.
     */
    skip?: number
    distinct?: GiftCertificateScalarFieldEnum | GiftCertificateScalarFieldEnum[]
  }

  /**
   * GiftCertificate create
   */
  export type GiftCertificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCertificate
     */
    select?: GiftCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GiftCertificate
     */
    omit?: GiftCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCertificateInclude<ExtArgs> | null
    /**
     * The data needed to create a GiftCertificate.
     */
    data: XOR<GiftCertificateCreateInput, GiftCertificateUncheckedCreateInput>
  }

  /**
   * GiftCertificate createMany
   */
  export type GiftCertificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GiftCertificates.
     */
    data: GiftCertificateCreateManyInput | GiftCertificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GiftCertificate createManyAndReturn
   */
  export type GiftCertificateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCertificate
     */
    select?: GiftCertificateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GiftCertificate
     */
    omit?: GiftCertificateOmit<ExtArgs> | null
    /**
     * The data used to create many GiftCertificates.
     */
    data: GiftCertificateCreateManyInput | GiftCertificateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCertificateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GiftCertificate update
   */
  export type GiftCertificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCertificate
     */
    select?: GiftCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GiftCertificate
     */
    omit?: GiftCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCertificateInclude<ExtArgs> | null
    /**
     * The data needed to update a GiftCertificate.
     */
    data: XOR<GiftCertificateUpdateInput, GiftCertificateUncheckedUpdateInput>
    /**
     * Choose, which GiftCertificate to update.
     */
    where: GiftCertificateWhereUniqueInput
  }

  /**
   * GiftCertificate updateMany
   */
  export type GiftCertificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GiftCertificates.
     */
    data: XOR<GiftCertificateUpdateManyMutationInput, GiftCertificateUncheckedUpdateManyInput>
    /**
     * Filter which GiftCertificates to update
     */
    where?: GiftCertificateWhereInput
    /**
     * Limit how many GiftCertificates to update.
     */
    limit?: number
  }

  /**
   * GiftCertificate updateManyAndReturn
   */
  export type GiftCertificateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCertificate
     */
    select?: GiftCertificateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GiftCertificate
     */
    omit?: GiftCertificateOmit<ExtArgs> | null
    /**
     * The data used to update GiftCertificates.
     */
    data: XOR<GiftCertificateUpdateManyMutationInput, GiftCertificateUncheckedUpdateManyInput>
    /**
     * Filter which GiftCertificates to update
     */
    where?: GiftCertificateWhereInput
    /**
     * Limit how many GiftCertificates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCertificateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GiftCertificate upsert
   */
  export type GiftCertificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCertificate
     */
    select?: GiftCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GiftCertificate
     */
    omit?: GiftCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCertificateInclude<ExtArgs> | null
    /**
     * The filter to search for the GiftCertificate to update in case it exists.
     */
    where: GiftCertificateWhereUniqueInput
    /**
     * In case the GiftCertificate found by the `where` argument doesn't exist, create a new GiftCertificate with this data.
     */
    create: XOR<GiftCertificateCreateInput, GiftCertificateUncheckedCreateInput>
    /**
     * In case the GiftCertificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GiftCertificateUpdateInput, GiftCertificateUncheckedUpdateInput>
  }

  /**
   * GiftCertificate delete
   */
  export type GiftCertificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCertificate
     */
    select?: GiftCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GiftCertificate
     */
    omit?: GiftCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCertificateInclude<ExtArgs> | null
    /**
     * Filter which GiftCertificate to delete.
     */
    where: GiftCertificateWhereUniqueInput
  }

  /**
   * GiftCertificate deleteMany
   */
  export type GiftCertificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GiftCertificates to delete
     */
    where?: GiftCertificateWhereInput
    /**
     * Limit how many GiftCertificates to delete.
     */
    limit?: number
  }

  /**
   * GiftCertificate.purchaserCustomer
   */
  export type GiftCertificate$purchaserCustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * GiftCertificate.services
   */
  export type GiftCertificate$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * GiftCertificate.serviceSets
   */
  export type GiftCertificate$serviceSetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSet
     */
    select?: ServiceSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSet
     */
    omit?: ServiceSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSetInclude<ExtArgs> | null
    where?: ServiceSetWhereInput
    orderBy?: ServiceSetOrderByWithRelationInput | ServiceSetOrderByWithRelationInput[]
    cursor?: ServiceSetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceSetScalarFieldEnum | ServiceSetScalarFieldEnum[]
  }

  /**
   * GiftCertificate.transactions
   */
  export type GiftCertificate$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * GiftCertificate without action
   */
  export type GiftCertificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCertificate
     */
    select?: GiftCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GiftCertificate
     */
    omit?: GiftCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCertificateInclude<ExtArgs> | null
  }


  /**
   * Model ManualSale
   */

  export type AggregateManualSale = {
    _count: ManualSaleCountAggregateOutputType | null
    _avg: ManualSaleAvgAggregateOutputType | null
    _sum: ManualSaleSumAggregateOutputType | null
    _min: ManualSaleMinAggregateOutputType | null
    _max: ManualSaleMaxAggregateOutputType | null
  }

  export type ManualSaleAvgAggregateOutputType = {
    amount: number | null
  }

  export type ManualSaleSumAggregateOutputType = {
    amount: number | null
  }

  export type ManualSaleMinAggregateOutputType = {
    id: string | null
    date: Date | null
    amount: number | null
    paymentMethod: $Enums.PaymentMethod | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    recordedById: string | null
    branchId: string | null
  }

  export type ManualSaleMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    amount: number | null
    paymentMethod: $Enums.PaymentMethod | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    recordedById: string | null
    branchId: string | null
  }

  export type ManualSaleCountAggregateOutputType = {
    id: number
    date: number
    amount: number
    paymentMethod: number
    description: number
    createdAt: number
    updatedAt: number
    recordedById: number
    branchId: number
    _all: number
  }


  export type ManualSaleAvgAggregateInputType = {
    amount?: true
  }

  export type ManualSaleSumAggregateInputType = {
    amount?: true
  }

  export type ManualSaleMinAggregateInputType = {
    id?: true
    date?: true
    amount?: true
    paymentMethod?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    recordedById?: true
    branchId?: true
  }

  export type ManualSaleMaxAggregateInputType = {
    id?: true
    date?: true
    amount?: true
    paymentMethod?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    recordedById?: true
    branchId?: true
  }

  export type ManualSaleCountAggregateInputType = {
    id?: true
    date?: true
    amount?: true
    paymentMethod?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    recordedById?: true
    branchId?: true
    _all?: true
  }

  export type ManualSaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManualSale to aggregate.
     */
    where?: ManualSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualSales to fetch.
     */
    orderBy?: ManualSaleOrderByWithRelationInput | ManualSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManualSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ManualSales
    **/
    _count?: true | ManualSaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ManualSaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ManualSaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManualSaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManualSaleMaxAggregateInputType
  }

  export type GetManualSaleAggregateType<T extends ManualSaleAggregateArgs> = {
        [P in keyof T & keyof AggregateManualSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManualSale[P]>
      : GetScalarType<T[P], AggregateManualSale[P]>
  }




  export type ManualSaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManualSaleWhereInput
    orderBy?: ManualSaleOrderByWithAggregationInput | ManualSaleOrderByWithAggregationInput[]
    by: ManualSaleScalarFieldEnum[] | ManualSaleScalarFieldEnum
    having?: ManualSaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManualSaleCountAggregateInputType | true
    _avg?: ManualSaleAvgAggregateInputType
    _sum?: ManualSaleSumAggregateInputType
    _min?: ManualSaleMinAggregateInputType
    _max?: ManualSaleMaxAggregateInputType
  }

  export type ManualSaleGroupByOutputType = {
    id: string
    date: Date
    amount: number
    paymentMethod: $Enums.PaymentMethod | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    recordedById: string
    branchId: string | null
    _count: ManualSaleCountAggregateOutputType | null
    _avg: ManualSaleAvgAggregateOutputType | null
    _sum: ManualSaleSumAggregateOutputType | null
    _min: ManualSaleMinAggregateOutputType | null
    _max: ManualSaleMaxAggregateOutputType | null
  }

  type GetManualSaleGroupByPayload<T extends ManualSaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManualSaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManualSaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManualSaleGroupByOutputType[P]>
            : GetScalarType<T[P], ManualSaleGroupByOutputType[P]>
        }
      >
    >


  export type ManualSaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    amount?: boolean
    paymentMethod?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recordedById?: boolean
    branchId?: boolean
    recordedBy?: boolean | AccountDefaultArgs<ExtArgs>
    branch?: boolean | ManualSale$branchArgs<ExtArgs>
  }, ExtArgs["result"]["manualSale"]>

  export type ManualSaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    amount?: boolean
    paymentMethod?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recordedById?: boolean
    branchId?: boolean
    recordedBy?: boolean | AccountDefaultArgs<ExtArgs>
    branch?: boolean | ManualSale$branchArgs<ExtArgs>
  }, ExtArgs["result"]["manualSale"]>

  export type ManualSaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    amount?: boolean
    paymentMethod?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recordedById?: boolean
    branchId?: boolean
    recordedBy?: boolean | AccountDefaultArgs<ExtArgs>
    branch?: boolean | ManualSale$branchArgs<ExtArgs>
  }, ExtArgs["result"]["manualSale"]>

  export type ManualSaleSelectScalar = {
    id?: boolean
    date?: boolean
    amount?: boolean
    paymentMethod?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recordedById?: boolean
    branchId?: boolean
  }

  export type ManualSaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "amount" | "paymentMethod" | "description" | "createdAt" | "updatedAt" | "recordedById" | "branchId", ExtArgs["result"]["manualSale"]>
  export type ManualSaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recordedBy?: boolean | AccountDefaultArgs<ExtArgs>
    branch?: boolean | ManualSale$branchArgs<ExtArgs>
  }
  export type ManualSaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recordedBy?: boolean | AccountDefaultArgs<ExtArgs>
    branch?: boolean | ManualSale$branchArgs<ExtArgs>
  }
  export type ManualSaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recordedBy?: boolean | AccountDefaultArgs<ExtArgs>
    branch?: boolean | ManualSale$branchArgs<ExtArgs>
  }

  export type $ManualSalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ManualSale"
    objects: {
      recordedBy: Prisma.$AccountPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      amount: number
      paymentMethod: $Enums.PaymentMethod | null
      description: string | null
      createdAt: Date
      updatedAt: Date
      recordedById: string
      branchId: string | null
    }, ExtArgs["result"]["manualSale"]>
    composites: {}
  }

  type ManualSaleGetPayload<S extends boolean | null | undefined | ManualSaleDefaultArgs> = $Result.GetResult<Prisma.$ManualSalePayload, S>

  type ManualSaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ManualSaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ManualSaleCountAggregateInputType | true
    }

  export interface ManualSaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ManualSale'], meta: { name: 'ManualSale' } }
    /**
     * Find zero or one ManualSale that matches the filter.
     * @param {ManualSaleFindUniqueArgs} args - Arguments to find a ManualSale
     * @example
     * // Get one ManualSale
     * const manualSale = await prisma.manualSale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManualSaleFindUniqueArgs>(args: SelectSubset<T, ManualSaleFindUniqueArgs<ExtArgs>>): Prisma__ManualSaleClient<$Result.GetResult<Prisma.$ManualSalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ManualSale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ManualSaleFindUniqueOrThrowArgs} args - Arguments to find a ManualSale
     * @example
     * // Get one ManualSale
     * const manualSale = await prisma.manualSale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManualSaleFindUniqueOrThrowArgs>(args: SelectSubset<T, ManualSaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManualSaleClient<$Result.GetResult<Prisma.$ManualSalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ManualSale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualSaleFindFirstArgs} args - Arguments to find a ManualSale
     * @example
     * // Get one ManualSale
     * const manualSale = await prisma.manualSale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManualSaleFindFirstArgs>(args?: SelectSubset<T, ManualSaleFindFirstArgs<ExtArgs>>): Prisma__ManualSaleClient<$Result.GetResult<Prisma.$ManualSalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ManualSale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualSaleFindFirstOrThrowArgs} args - Arguments to find a ManualSale
     * @example
     * // Get one ManualSale
     * const manualSale = await prisma.manualSale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManualSaleFindFirstOrThrowArgs>(args?: SelectSubset<T, ManualSaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManualSaleClient<$Result.GetResult<Prisma.$ManualSalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ManualSales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualSaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ManualSales
     * const manualSales = await prisma.manualSale.findMany()
     * 
     * // Get first 10 ManualSales
     * const manualSales = await prisma.manualSale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const manualSaleWithIdOnly = await prisma.manualSale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManualSaleFindManyArgs>(args?: SelectSubset<T, ManualSaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualSalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ManualSale.
     * @param {ManualSaleCreateArgs} args - Arguments to create a ManualSale.
     * @example
     * // Create one ManualSale
     * const ManualSale = await prisma.manualSale.create({
     *   data: {
     *     // ... data to create a ManualSale
     *   }
     * })
     * 
     */
    create<T extends ManualSaleCreateArgs>(args: SelectSubset<T, ManualSaleCreateArgs<ExtArgs>>): Prisma__ManualSaleClient<$Result.GetResult<Prisma.$ManualSalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ManualSales.
     * @param {ManualSaleCreateManyArgs} args - Arguments to create many ManualSales.
     * @example
     * // Create many ManualSales
     * const manualSale = await prisma.manualSale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManualSaleCreateManyArgs>(args?: SelectSubset<T, ManualSaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ManualSales and returns the data saved in the database.
     * @param {ManualSaleCreateManyAndReturnArgs} args - Arguments to create many ManualSales.
     * @example
     * // Create many ManualSales
     * const manualSale = await prisma.manualSale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ManualSales and only return the `id`
     * const manualSaleWithIdOnly = await prisma.manualSale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ManualSaleCreateManyAndReturnArgs>(args?: SelectSubset<T, ManualSaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualSalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ManualSale.
     * @param {ManualSaleDeleteArgs} args - Arguments to delete one ManualSale.
     * @example
     * // Delete one ManualSale
     * const ManualSale = await prisma.manualSale.delete({
     *   where: {
     *     // ... filter to delete one ManualSale
     *   }
     * })
     * 
     */
    delete<T extends ManualSaleDeleteArgs>(args: SelectSubset<T, ManualSaleDeleteArgs<ExtArgs>>): Prisma__ManualSaleClient<$Result.GetResult<Prisma.$ManualSalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ManualSale.
     * @param {ManualSaleUpdateArgs} args - Arguments to update one ManualSale.
     * @example
     * // Update one ManualSale
     * const manualSale = await prisma.manualSale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManualSaleUpdateArgs>(args: SelectSubset<T, ManualSaleUpdateArgs<ExtArgs>>): Prisma__ManualSaleClient<$Result.GetResult<Prisma.$ManualSalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ManualSales.
     * @param {ManualSaleDeleteManyArgs} args - Arguments to filter ManualSales to delete.
     * @example
     * // Delete a few ManualSales
     * const { count } = await prisma.manualSale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManualSaleDeleteManyArgs>(args?: SelectSubset<T, ManualSaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ManualSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualSaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ManualSales
     * const manualSale = await prisma.manualSale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManualSaleUpdateManyArgs>(args: SelectSubset<T, ManualSaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ManualSales and returns the data updated in the database.
     * @param {ManualSaleUpdateManyAndReturnArgs} args - Arguments to update many ManualSales.
     * @example
     * // Update many ManualSales
     * const manualSale = await prisma.manualSale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ManualSales and only return the `id`
     * const manualSaleWithIdOnly = await prisma.manualSale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ManualSaleUpdateManyAndReturnArgs>(args: SelectSubset<T, ManualSaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualSalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ManualSale.
     * @param {ManualSaleUpsertArgs} args - Arguments to update or create a ManualSale.
     * @example
     * // Update or create a ManualSale
     * const manualSale = await prisma.manualSale.upsert({
     *   create: {
     *     // ... data to create a ManualSale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ManualSale we want to update
     *   }
     * })
     */
    upsert<T extends ManualSaleUpsertArgs>(args: SelectSubset<T, ManualSaleUpsertArgs<ExtArgs>>): Prisma__ManualSaleClient<$Result.GetResult<Prisma.$ManualSalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ManualSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualSaleCountArgs} args - Arguments to filter ManualSales to count.
     * @example
     * // Count the number of ManualSales
     * const count = await prisma.manualSale.count({
     *   where: {
     *     // ... the filter for the ManualSales we want to count
     *   }
     * })
    **/
    count<T extends ManualSaleCountArgs>(
      args?: Subset<T, ManualSaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManualSaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ManualSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualSaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManualSaleAggregateArgs>(args: Subset<T, ManualSaleAggregateArgs>): Prisma.PrismaPromise<GetManualSaleAggregateType<T>>

    /**
     * Group by ManualSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualSaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManualSaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManualSaleGroupByArgs['orderBy'] }
        : { orderBy?: ManualSaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManualSaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManualSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ManualSale model
   */
  readonly fields: ManualSaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ManualSale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManualSaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recordedBy<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    branch<T extends ManualSale$branchArgs<ExtArgs> = {}>(args?: Subset<T, ManualSale$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ManualSale model
   */
  interface ManualSaleFieldRefs {
    readonly id: FieldRef<"ManualSale", 'String'>
    readonly date: FieldRef<"ManualSale", 'DateTime'>
    readonly amount: FieldRef<"ManualSale", 'Int'>
    readonly paymentMethod: FieldRef<"ManualSale", 'PaymentMethod'>
    readonly description: FieldRef<"ManualSale", 'String'>
    readonly createdAt: FieldRef<"ManualSale", 'DateTime'>
    readonly updatedAt: FieldRef<"ManualSale", 'DateTime'>
    readonly recordedById: FieldRef<"ManualSale", 'String'>
    readonly branchId: FieldRef<"ManualSale", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ManualSale findUnique
   */
  export type ManualSaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualSale
     */
    select?: ManualSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualSale
     */
    omit?: ManualSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualSaleInclude<ExtArgs> | null
    /**
     * Filter, which ManualSale to fetch.
     */
    where: ManualSaleWhereUniqueInput
  }

  /**
   * ManualSale findUniqueOrThrow
   */
  export type ManualSaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualSale
     */
    select?: ManualSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualSale
     */
    omit?: ManualSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualSaleInclude<ExtArgs> | null
    /**
     * Filter, which ManualSale to fetch.
     */
    where: ManualSaleWhereUniqueInput
  }

  /**
   * ManualSale findFirst
   */
  export type ManualSaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualSale
     */
    select?: ManualSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualSale
     */
    omit?: ManualSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualSaleInclude<ExtArgs> | null
    /**
     * Filter, which ManualSale to fetch.
     */
    where?: ManualSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualSales to fetch.
     */
    orderBy?: ManualSaleOrderByWithRelationInput | ManualSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManualSales.
     */
    cursor?: ManualSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManualSales.
     */
    distinct?: ManualSaleScalarFieldEnum | ManualSaleScalarFieldEnum[]
  }

  /**
   * ManualSale findFirstOrThrow
   */
  export type ManualSaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualSale
     */
    select?: ManualSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualSale
     */
    omit?: ManualSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualSaleInclude<ExtArgs> | null
    /**
     * Filter, which ManualSale to fetch.
     */
    where?: ManualSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualSales to fetch.
     */
    orderBy?: ManualSaleOrderByWithRelationInput | ManualSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManualSales.
     */
    cursor?: ManualSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManualSales.
     */
    distinct?: ManualSaleScalarFieldEnum | ManualSaleScalarFieldEnum[]
  }

  /**
   * ManualSale findMany
   */
  export type ManualSaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualSale
     */
    select?: ManualSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualSale
     */
    omit?: ManualSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualSaleInclude<ExtArgs> | null
    /**
     * Filter, which ManualSales to fetch.
     */
    where?: ManualSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualSales to fetch.
     */
    orderBy?: ManualSaleOrderByWithRelationInput | ManualSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ManualSales.
     */
    cursor?: ManualSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualSales.
     */
    skip?: number
    distinct?: ManualSaleScalarFieldEnum | ManualSaleScalarFieldEnum[]
  }

  /**
   * ManualSale create
   */
  export type ManualSaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualSale
     */
    select?: ManualSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualSale
     */
    omit?: ManualSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualSaleInclude<ExtArgs> | null
    /**
     * The data needed to create a ManualSale.
     */
    data: XOR<ManualSaleCreateInput, ManualSaleUncheckedCreateInput>
  }

  /**
   * ManualSale createMany
   */
  export type ManualSaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ManualSales.
     */
    data: ManualSaleCreateManyInput | ManualSaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ManualSale createManyAndReturn
   */
  export type ManualSaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualSale
     */
    select?: ManualSaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ManualSale
     */
    omit?: ManualSaleOmit<ExtArgs> | null
    /**
     * The data used to create many ManualSales.
     */
    data: ManualSaleCreateManyInput | ManualSaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualSaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ManualSale update
   */
  export type ManualSaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualSale
     */
    select?: ManualSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualSale
     */
    omit?: ManualSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualSaleInclude<ExtArgs> | null
    /**
     * The data needed to update a ManualSale.
     */
    data: XOR<ManualSaleUpdateInput, ManualSaleUncheckedUpdateInput>
    /**
     * Choose, which ManualSale to update.
     */
    where: ManualSaleWhereUniqueInput
  }

  /**
   * ManualSale updateMany
   */
  export type ManualSaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ManualSales.
     */
    data: XOR<ManualSaleUpdateManyMutationInput, ManualSaleUncheckedUpdateManyInput>
    /**
     * Filter which ManualSales to update
     */
    where?: ManualSaleWhereInput
    /**
     * Limit how many ManualSales to update.
     */
    limit?: number
  }

  /**
   * ManualSale updateManyAndReturn
   */
  export type ManualSaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualSale
     */
    select?: ManualSaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ManualSale
     */
    omit?: ManualSaleOmit<ExtArgs> | null
    /**
     * The data used to update ManualSales.
     */
    data: XOR<ManualSaleUpdateManyMutationInput, ManualSaleUncheckedUpdateManyInput>
    /**
     * Filter which ManualSales to update
     */
    where?: ManualSaleWhereInput
    /**
     * Limit how many ManualSales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualSaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ManualSale upsert
   */
  export type ManualSaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualSale
     */
    select?: ManualSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualSale
     */
    omit?: ManualSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualSaleInclude<ExtArgs> | null
    /**
     * The filter to search for the ManualSale to update in case it exists.
     */
    where: ManualSaleWhereUniqueInput
    /**
     * In case the ManualSale found by the `where` argument doesn't exist, create a new ManualSale with this data.
     */
    create: XOR<ManualSaleCreateInput, ManualSaleUncheckedCreateInput>
    /**
     * In case the ManualSale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManualSaleUpdateInput, ManualSaleUncheckedUpdateInput>
  }

  /**
   * ManualSale delete
   */
  export type ManualSaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualSale
     */
    select?: ManualSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualSale
     */
    omit?: ManualSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualSaleInclude<ExtArgs> | null
    /**
     * Filter which ManualSale to delete.
     */
    where: ManualSaleWhereUniqueInput
  }

  /**
   * ManualSale deleteMany
   */
  export type ManualSaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManualSales to delete
     */
    where?: ManualSaleWhereInput
    /**
     * Limit how many ManualSales to delete.
     */
    limit?: number
  }

  /**
   * ManualSale.branch
   */
  export type ManualSale$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * ManualSale without action
   */
  export type ManualSaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualSale
     */
    select?: ManualSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualSale
     */
    omit?: ManualSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualSaleInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    date: Date | null
    amount: number | null
    category: $Enums.ExpenseCategory | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    recordedById: string | null
    branchId: string | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    amount: number | null
    category: $Enums.ExpenseCategory | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    recordedById: string | null
    branchId: string | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    date: number
    amount: number
    category: number
    description: number
    createdAt: number
    updatedAt: number
    recordedById: number
    branchId: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    amount?: true
  }

  export type ExpenseSumAggregateInputType = {
    amount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    date?: true
    amount?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    recordedById?: true
    branchId?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    date?: true
    amount?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    recordedById?: true
    branchId?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    date?: true
    amount?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    recordedById?: true
    branchId?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: string
    date: Date
    amount: number
    category: $Enums.ExpenseCategory
    description: string | null
    createdAt: Date
    updatedAt: Date
    recordedById: string
    branchId: string | null
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recordedById?: boolean
    branchId?: boolean
    recordedBy?: boolean | AccountDefaultArgs<ExtArgs>
    branch?: boolean | Expense$branchArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recordedById?: boolean
    branchId?: boolean
    recordedBy?: boolean | AccountDefaultArgs<ExtArgs>
    branch?: boolean | Expense$branchArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recordedById?: boolean
    branchId?: boolean
    recordedBy?: boolean | AccountDefaultArgs<ExtArgs>
    branch?: boolean | Expense$branchArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    date?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recordedById?: boolean
    branchId?: boolean
  }

  export type ExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "amount" | "category" | "description" | "createdAt" | "updatedAt" | "recordedById" | "branchId", ExtArgs["result"]["expense"]>
  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recordedBy?: boolean | AccountDefaultArgs<ExtArgs>
    branch?: boolean | Expense$branchArgs<ExtArgs>
  }
  export type ExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recordedBy?: boolean | AccountDefaultArgs<ExtArgs>
    branch?: boolean | Expense$branchArgs<ExtArgs>
  }
  export type ExpenseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recordedBy?: boolean | AccountDefaultArgs<ExtArgs>
    branch?: boolean | Expense$branchArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      recordedBy: Prisma.$AccountPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      amount: number
      category: $Enums.ExpenseCategory
      description: string | null
      createdAt: Date
      updatedAt: Date
      recordedById: string
      branchId: string | null
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses and returns the data updated in the database.
     * @param {ExpenseUpdateManyAndReturnArgs} args - Arguments to update many Expenses.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recordedBy<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    branch<T extends Expense$branchArgs<ExtArgs> = {}>(args?: Subset<T, Expense$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'String'>
    readonly date: FieldRef<"Expense", 'DateTime'>
    readonly amount: FieldRef<"Expense", 'Int'>
    readonly category: FieldRef<"Expense", 'ExpenseCategory'>
    readonly description: FieldRef<"Expense", 'String'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
    readonly updatedAt: FieldRef<"Expense", 'DateTime'>
    readonly recordedById: FieldRef<"Expense", 'String'>
    readonly branchId: FieldRef<"Expense", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense updateManyAndReturn
   */
  export type ExpenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to delete.
     */
    limit?: number
  }

  /**
   * Expense.branch
   */
  export type Expense$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Model EmailTemplate
   */

  export type AggregateEmailTemplate = {
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  export type EmailTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    body: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    body: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    body: number
    placeholders: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailTemplateMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    placeholders?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplate to aggregate.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTemplates
    **/
    _count?: true | EmailTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type GetEmailTemplateAggregateType<T extends EmailTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailTemplate[P]>
      : GetScalarType<T[P], AggregateEmailTemplate[P]>
  }




  export type EmailTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithAggregationInput | EmailTemplateOrderByWithAggregationInput[]
    by: EmailTemplateScalarFieldEnum[] | EmailTemplateScalarFieldEnum
    having?: EmailTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTemplateCountAggregateInputType | true
    _min?: EmailTemplateMinAggregateInputType
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type EmailTemplateGroupByOutputType = {
    id: string
    name: string
    subject: string
    body: string
    placeholders: string[]
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  type GetEmailTemplateGroupByPayload<T extends EmailTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
        }
      >
    >


  export type EmailTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    placeholders?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    placeholders?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    placeholders?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    placeholders?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subject" | "body" | "placeholders" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["emailTemplate"]>

  export type $EmailTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subject: string
      body: string
      placeholders: string[]
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailTemplate"]>
    composites: {}
  }

  type EmailTemplateGetPayload<S extends boolean | null | undefined | EmailTemplateDefaultArgs> = $Result.GetResult<Prisma.$EmailTemplatePayload, S>

  type EmailTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailTemplateCountAggregateInputType | true
    }

  export interface EmailTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailTemplate'], meta: { name: 'EmailTemplate' } }
    /**
     * Find zero or one EmailTemplate that matches the filter.
     * @param {EmailTemplateFindUniqueArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailTemplateFindUniqueArgs>(args: SelectSubset<T, EmailTemplateFindUniqueArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailTemplateFindUniqueOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailTemplateFindFirstArgs>(args?: SelectSubset<T, EmailTemplateFindFirstArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany()
     * 
     * // Get first 10 EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailTemplateFindManyArgs>(args?: SelectSubset<T, EmailTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailTemplate.
     * @param {EmailTemplateCreateArgs} args - Arguments to create a EmailTemplate.
     * @example
     * // Create one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.create({
     *   data: {
     *     // ... data to create a EmailTemplate
     *   }
     * })
     * 
     */
    create<T extends EmailTemplateCreateArgs>(args: SelectSubset<T, EmailTemplateCreateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailTemplates.
     * @param {EmailTemplateCreateManyArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailTemplateCreateManyArgs>(args?: SelectSubset<T, EmailTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailTemplates and returns the data saved in the database.
     * @param {EmailTemplateCreateManyAndReturnArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailTemplate.
     * @param {EmailTemplateDeleteArgs} args - Arguments to delete one EmailTemplate.
     * @example
     * // Delete one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.delete({
     *   where: {
     *     // ... filter to delete one EmailTemplate
     *   }
     * })
     * 
     */
    delete<T extends EmailTemplateDeleteArgs>(args: SelectSubset<T, EmailTemplateDeleteArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailTemplate.
     * @param {EmailTemplateUpdateArgs} args - Arguments to update one EmailTemplate.
     * @example
     * // Update one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailTemplateUpdateArgs>(args: SelectSubset<T, EmailTemplateUpdateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailTemplates.
     * @param {EmailTemplateDeleteManyArgs} args - Arguments to filter EmailTemplates to delete.
     * @example
     * // Delete a few EmailTemplates
     * const { count } = await prisma.emailTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailTemplateDeleteManyArgs>(args?: SelectSubset<T, EmailTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailTemplateUpdateManyArgs>(args: SelectSubset<T, EmailTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates and returns the data updated in the database.
     * @param {EmailTemplateUpdateManyAndReturnArgs} args - Arguments to update many EmailTemplates.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailTemplate.
     * @param {EmailTemplateUpsertArgs} args - Arguments to update or create a EmailTemplate.
     * @example
     * // Update or create a EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.upsert({
     *   create: {
     *     // ... data to create a EmailTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailTemplate we want to update
     *   }
     * })
     */
    upsert<T extends EmailTemplateUpsertArgs>(args: SelectSubset<T, EmailTemplateUpsertArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateCountArgs} args - Arguments to filter EmailTemplates to count.
     * @example
     * // Count the number of EmailTemplates
     * const count = await prisma.emailTemplate.count({
     *   where: {
     *     // ... the filter for the EmailTemplates we want to count
     *   }
     * })
    **/
    count<T extends EmailTemplateCountArgs>(
      args?: Subset<T, EmailTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTemplateAggregateArgs>(args: Subset<T, EmailTemplateAggregateArgs>): Prisma.PrismaPromise<GetEmailTemplateAggregateType<T>>

    /**
     * Group by EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTemplateGroupByArgs['orderBy'] }
        : { orderBy?: EmailTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailTemplate model
   */
  readonly fields: EmailTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailTemplate model
   */
  interface EmailTemplateFieldRefs {
    readonly id: FieldRef<"EmailTemplate", 'String'>
    readonly name: FieldRef<"EmailTemplate", 'String'>
    readonly subject: FieldRef<"EmailTemplate", 'String'>
    readonly body: FieldRef<"EmailTemplate", 'String'>
    readonly placeholders: FieldRef<"EmailTemplate", 'String[]'>
    readonly isActive: FieldRef<"EmailTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"EmailTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailTemplate findUnique
   */
  export type EmailTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findUniqueOrThrow
   */
  export type EmailTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findFirst
   */
  export type EmailTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findFirstOrThrow
   */
  export type EmailTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findMany
   */
  export type EmailTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Filter, which EmailTemplates to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate create
   */
  export type EmailTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data needed to create a EmailTemplate.
     */
    data: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
  }

  /**
   * EmailTemplate createMany
   */
  export type EmailTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate createManyAndReturn
   */
  export type EmailTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate update
   */
  export type EmailTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data needed to update a EmailTemplate.
     */
    data: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
    /**
     * Choose, which EmailTemplate to update.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate updateMany
   */
  export type EmailTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to update.
     */
    limit?: number
  }

  /**
   * EmailTemplate updateManyAndReturn
   */
  export type EmailTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to update.
     */
    limit?: number
  }

  /**
   * EmailTemplate upsert
   */
  export type EmailTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The filter to search for the EmailTemplate to update in case it exists.
     */
    where: EmailTemplateWhereUniqueInput
    /**
     * In case the EmailTemplate found by the `where` argument doesn't exist, create a new EmailTemplate with this data.
     */
    create: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
    /**
     * In case the EmailTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
  }

  /**
   * EmailTemplate delete
   */
  export type EmailTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Filter which EmailTemplate to delete.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate deleteMany
   */
  export type EmailTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplates to delete
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to delete.
     */
    limit?: number
  }

  /**
   * EmailTemplate without action
   */
  export type EmailTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PayslipRequestScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    requestTimestamp: 'requestTimestamp',
    periodStartDate: 'periodStartDate',
    periodEndDate: 'periodEndDate',
    status: 'status',
    notes: 'notes',
    processedById: 'processedById',
    processedTimestamp: 'processedTimestamp',
    relatedPayslipId: 'relatedPayslipId'
  };

  export type PayslipRequestScalarFieldEnum = (typeof PayslipRequestScalarFieldEnum)[keyof typeof PayslipRequestScalarFieldEnum]


  export const PayslipScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    periodStartDate: 'periodStartDate',
    periodEndDate: 'periodEndDate',
    baseSalary: 'baseSalary',
    totalCommissions: 'totalCommissions',
    totalDeductions: 'totalDeductions',
    totalBonuses: 'totalBonuses',
    netPay: 'netPay',
    status: 'status',
    releasedDate: 'releasedDate',
    generatedAt: 'generatedAt'
  };

  export type PayslipScalarFieldEnum = (typeof PayslipScalarFieldEnum)[keyof typeof PayslipScalarFieldEnum]


  export const RecommendedAppointmentScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    recommendedDate: 'recommendedDate',
    originatingTransactionId: 'originatingTransactionId',
    originatingAvailedServiceId: 'originatingAvailedServiceId',
    originatingServiceId: 'originatingServiceId',
    status: 'status',
    attendedTransactionId: 'attendedTransactionId',
    suppressNextFollowUpGeneration: 'suppressNextFollowUpGeneration',
    reminder3DaySentAt: 'reminder3DaySentAt',
    reminder2DaySentAt: 'reminder2DaySentAt',
    reminder1DaySentAt: 'reminder1DaySentAt',
    reminderTodaySentAt: 'reminderTodaySentAt',
    reminder1DayAfterSentAt: 'reminder1DayAfterSentAt',
    reminder7DaySentAt: 'reminder7DaySentAt',
    reminder7DayAfterSentAt: 'reminder7DayAfterSentAt',
    reminder14DayAfterSentAt: 'reminder14DayAfterSentAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecommendedAppointmentScalarFieldEnum = (typeof RecommendedAppointmentScalarFieldEnum)[keyof typeof RecommendedAppointmentScalarFieldEnum]


  export const DiscountRuleScalarFieldEnum: {
    id: 'id',
    description: 'description',
    discountType: 'discountType',
    discountValue: 'discountValue',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    applyToAll: 'applyToAll',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DiscountRuleScalarFieldEnum = (typeof DiscountRuleScalarFieldEnum)[keyof typeof DiscountRuleScalarFieldEnum]


  export const BranchScalarFieldEnum: {
    id: 'id',
    title: 'title',
    code: 'code',
    totalSales: 'totalSales'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    date: 'date',
    accountId: 'accountId',
    isPresent: 'isPresent',
    notes: 'notes',
    checkedById: 'checkedById',
    checkedAt: 'checkedAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    name: 'name',
    email: 'email',
    role: 'role',
    salary: 'salary',
    dailyRate: 'dailyRate',
    branchId: 'branchId',
    canRequestPayslip: 'canRequestPayslip',
    mustChangePassword: 'mustChangePassword'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    price: 'price',
    branchId: 'branchId',
    totalSales: 'totalSales',
    recommendFollowUp: 'recommendFollowUp',
    recommendedFollowUpDays: 'recommendedFollowUpDays',
    followUpPolicy: 'followUpPolicy'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ServiceSetScalarFieldEnum: {
    id: 'id',
    title: 'title',
    price: 'price'
  };

  export type ServiceSetScalarFieldEnum = (typeof ServiceSetScalarFieldEnum)[keyof typeof ServiceSetScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    totalPaid: 'totalPaid',
    nextAppointment: 'nextAppointment'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const VoucherScalarFieldEnum: {
    id: 'id',
    code: 'code',
    value: 'value',
    usedAt: 'usedAt'
  };

  export type VoucherScalarFieldEnum = (typeof VoucherScalarFieldEnum)[keyof typeof VoucherScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    bookedFor: 'bookedFor',
    customerId: 'customerId',
    voucherId: 'voucherId',
    discount: 'discount',
    paymentMethod: 'paymentMethod',
    grandTotal: 'grandTotal',
    status: 'status',
    branchId: 'branchId',
    bookingReminderSentAt: 'bookingReminderSentAt',
    giftCertificateId: 'giftCertificateId'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const AvailedServiceScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    serviceId: 'serviceId',
    quantity: 'quantity',
    price: 'price',
    commissionValue: 'commissionValue',
    originatingSetId: 'originatingSetId',
    originatingSetTitle: 'originatingSetTitle',
    checkedById: 'checkedById',
    servedById: 'servedById',
    serviceSetId: 'serviceSetId',
    status: 'status',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AvailedServiceScalarFieldEnum = (typeof AvailedServiceScalarFieldEnum)[keyof typeof AvailedServiceScalarFieldEnum]


  export const GiftCertificateScalarFieldEnum: {
    id: 'id',
    code: 'code',
    issuedAt: 'issuedAt',
    expiresAt: 'expiresAt',
    purchaserCustomerId: 'purchaserCustomerId',
    recipientName: 'recipientName',
    recipientEmail: 'recipientEmail',
    usedAt: 'usedAt'
  };

  export type GiftCertificateScalarFieldEnum = (typeof GiftCertificateScalarFieldEnum)[keyof typeof GiftCertificateScalarFieldEnum]


  export const ManualSaleScalarFieldEnum: {
    id: 'id',
    date: 'date',
    amount: 'amount',
    paymentMethod: 'paymentMethod',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    recordedById: 'recordedById',
    branchId: 'branchId'
  };

  export type ManualSaleScalarFieldEnum = (typeof ManualSaleScalarFieldEnum)[keyof typeof ManualSaleScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    date: 'date',
    amount: 'amount',
    category: 'category',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    recordedById: 'recordedById',
    branchId: 'branchId'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const EmailTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    body: 'body',
    placeholders: 'placeholders',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailTemplateScalarFieldEnum = (typeof EmailTemplateScalarFieldEnum)[keyof typeof EmailTemplateScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'PayslipRequestStatus'
   */
  export type EnumPayslipRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayslipRequestStatus'>
    


  /**
   * Reference to a field of type 'PayslipRequestStatus[]'
   */
  export type ListEnumPayslipRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayslipRequestStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'PayslipStatus'
   */
  export type EnumPayslipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayslipStatus'>
    


  /**
   * Reference to a field of type 'PayslipStatus[]'
   */
  export type ListEnumPayslipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayslipStatus[]'>
    


  /**
   * Reference to a field of type 'RecommendedAppointmentStatus'
   */
  export type EnumRecommendedAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecommendedAppointmentStatus'>
    


  /**
   * Reference to a field of type 'RecommendedAppointmentStatus[]'
   */
  export type ListEnumRecommendedAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecommendedAppointmentStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DiscountType'
   */
  export type EnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType'>
    


  /**
   * Reference to a field of type 'DiscountType[]'
   */
  export type ListEnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'FollowUpPolicy'
   */
  export type EnumFollowUpPolicyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FollowUpPolicy'>
    


  /**
   * Reference to a field of type 'FollowUpPolicy[]'
   */
  export type ListEnumFollowUpPolicyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FollowUpPolicy[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'ExpenseCategory'
   */
  export type EnumExpenseCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseCategory'>
    


  /**
   * Reference to a field of type 'ExpenseCategory[]'
   */
  export type ListEnumExpenseCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseCategory[]'>
    
  /**
   * Deep Input Types
   */


  export type PayslipRequestWhereInput = {
    AND?: PayslipRequestWhereInput | PayslipRequestWhereInput[]
    OR?: PayslipRequestWhereInput[]
    NOT?: PayslipRequestWhereInput | PayslipRequestWhereInput[]
    id?: StringFilter<"PayslipRequest"> | string
    accountId?: StringFilter<"PayslipRequest"> | string
    requestTimestamp?: DateTimeFilter<"PayslipRequest"> | Date | string
    periodStartDate?: DateTimeFilter<"PayslipRequest"> | Date | string
    periodEndDate?: DateTimeFilter<"PayslipRequest"> | Date | string
    status?: EnumPayslipRequestStatusFilter<"PayslipRequest"> | $Enums.PayslipRequestStatus
    notes?: StringNullableFilter<"PayslipRequest"> | string | null
    processedById?: StringNullableFilter<"PayslipRequest"> | string | null
    processedTimestamp?: DateTimeNullableFilter<"PayslipRequest"> | Date | string | null
    relatedPayslipId?: StringNullableFilter<"PayslipRequest"> | string | null
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    processedBy?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    relatedPayslip?: XOR<PayslipNullableScalarRelationFilter, PayslipWhereInput> | null
  }

  export type PayslipRequestOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    requestTimestamp?: SortOrder
    periodStartDate?: SortOrder
    periodEndDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    processedById?: SortOrderInput | SortOrder
    processedTimestamp?: SortOrderInput | SortOrder
    relatedPayslipId?: SortOrderInput | SortOrder
    account?: AccountOrderByWithRelationInput
    processedBy?: AccountOrderByWithRelationInput
    relatedPayslip?: PayslipOrderByWithRelationInput
  }

  export type PayslipRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    relatedPayslipId?: string
    AND?: PayslipRequestWhereInput | PayslipRequestWhereInput[]
    OR?: PayslipRequestWhereInput[]
    NOT?: PayslipRequestWhereInput | PayslipRequestWhereInput[]
    accountId?: StringFilter<"PayslipRequest"> | string
    requestTimestamp?: DateTimeFilter<"PayslipRequest"> | Date | string
    periodStartDate?: DateTimeFilter<"PayslipRequest"> | Date | string
    periodEndDate?: DateTimeFilter<"PayslipRequest"> | Date | string
    status?: EnumPayslipRequestStatusFilter<"PayslipRequest"> | $Enums.PayslipRequestStatus
    notes?: StringNullableFilter<"PayslipRequest"> | string | null
    processedById?: StringNullableFilter<"PayslipRequest"> | string | null
    processedTimestamp?: DateTimeNullableFilter<"PayslipRequest"> | Date | string | null
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    processedBy?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    relatedPayslip?: XOR<PayslipNullableScalarRelationFilter, PayslipWhereInput> | null
  }, "id" | "relatedPayslipId">

  export type PayslipRequestOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    requestTimestamp?: SortOrder
    periodStartDate?: SortOrder
    periodEndDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    processedById?: SortOrderInput | SortOrder
    processedTimestamp?: SortOrderInput | SortOrder
    relatedPayslipId?: SortOrderInput | SortOrder
    _count?: PayslipRequestCountOrderByAggregateInput
    _max?: PayslipRequestMaxOrderByAggregateInput
    _min?: PayslipRequestMinOrderByAggregateInput
  }

  export type PayslipRequestScalarWhereWithAggregatesInput = {
    AND?: PayslipRequestScalarWhereWithAggregatesInput | PayslipRequestScalarWhereWithAggregatesInput[]
    OR?: PayslipRequestScalarWhereWithAggregatesInput[]
    NOT?: PayslipRequestScalarWhereWithAggregatesInput | PayslipRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PayslipRequest"> | string
    accountId?: StringWithAggregatesFilter<"PayslipRequest"> | string
    requestTimestamp?: DateTimeWithAggregatesFilter<"PayslipRequest"> | Date | string
    periodStartDate?: DateTimeWithAggregatesFilter<"PayslipRequest"> | Date | string
    periodEndDate?: DateTimeWithAggregatesFilter<"PayslipRequest"> | Date | string
    status?: EnumPayslipRequestStatusWithAggregatesFilter<"PayslipRequest"> | $Enums.PayslipRequestStatus
    notes?: StringNullableWithAggregatesFilter<"PayslipRequest"> | string | null
    processedById?: StringNullableWithAggregatesFilter<"PayslipRequest"> | string | null
    processedTimestamp?: DateTimeNullableWithAggregatesFilter<"PayslipRequest"> | Date | string | null
    relatedPayslipId?: StringNullableWithAggregatesFilter<"PayslipRequest"> | string | null
  }

  export type PayslipWhereInput = {
    AND?: PayslipWhereInput | PayslipWhereInput[]
    OR?: PayslipWhereInput[]
    NOT?: PayslipWhereInput | PayslipWhereInput[]
    id?: StringFilter<"Payslip"> | string
    accountId?: StringFilter<"Payslip"> | string
    periodStartDate?: DateTimeFilter<"Payslip"> | Date | string
    periodEndDate?: DateTimeFilter<"Payslip"> | Date | string
    baseSalary?: IntFilter<"Payslip"> | number
    totalCommissions?: IntFilter<"Payslip"> | number
    totalDeductions?: IntFilter<"Payslip"> | number
    totalBonuses?: IntFilter<"Payslip"> | number
    netPay?: IntFilter<"Payslip"> | number
    status?: EnumPayslipStatusFilter<"Payslip"> | $Enums.PayslipStatus
    releasedDate?: DateTimeNullableFilter<"Payslip"> | Date | string | null
    generatedAt?: DateTimeFilter<"Payslip"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    payslipRequest?: XOR<PayslipRequestNullableScalarRelationFilter, PayslipRequestWhereInput> | null
  }

  export type PayslipOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    periodStartDate?: SortOrder
    periodEndDate?: SortOrder
    baseSalary?: SortOrder
    totalCommissions?: SortOrder
    totalDeductions?: SortOrder
    totalBonuses?: SortOrder
    netPay?: SortOrder
    status?: SortOrder
    releasedDate?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    payslipRequest?: PayslipRequestOrderByWithRelationInput
  }

  export type PayslipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accountId_periodStartDate_periodEndDate?: PayslipAccountIdPeriodStartDatePeriodEndDateCompoundUniqueInput
    AND?: PayslipWhereInput | PayslipWhereInput[]
    OR?: PayslipWhereInput[]
    NOT?: PayslipWhereInput | PayslipWhereInput[]
    accountId?: StringFilter<"Payslip"> | string
    periodStartDate?: DateTimeFilter<"Payslip"> | Date | string
    periodEndDate?: DateTimeFilter<"Payslip"> | Date | string
    baseSalary?: IntFilter<"Payslip"> | number
    totalCommissions?: IntFilter<"Payslip"> | number
    totalDeductions?: IntFilter<"Payslip"> | number
    totalBonuses?: IntFilter<"Payslip"> | number
    netPay?: IntFilter<"Payslip"> | number
    status?: EnumPayslipStatusFilter<"Payslip"> | $Enums.PayslipStatus
    releasedDate?: DateTimeNullableFilter<"Payslip"> | Date | string | null
    generatedAt?: DateTimeFilter<"Payslip"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    payslipRequest?: XOR<PayslipRequestNullableScalarRelationFilter, PayslipRequestWhereInput> | null
  }, "id" | "accountId_periodStartDate_periodEndDate">

  export type PayslipOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    periodStartDate?: SortOrder
    periodEndDate?: SortOrder
    baseSalary?: SortOrder
    totalCommissions?: SortOrder
    totalDeductions?: SortOrder
    totalBonuses?: SortOrder
    netPay?: SortOrder
    status?: SortOrder
    releasedDate?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    _count?: PayslipCountOrderByAggregateInput
    _avg?: PayslipAvgOrderByAggregateInput
    _max?: PayslipMaxOrderByAggregateInput
    _min?: PayslipMinOrderByAggregateInput
    _sum?: PayslipSumOrderByAggregateInput
  }

  export type PayslipScalarWhereWithAggregatesInput = {
    AND?: PayslipScalarWhereWithAggregatesInput | PayslipScalarWhereWithAggregatesInput[]
    OR?: PayslipScalarWhereWithAggregatesInput[]
    NOT?: PayslipScalarWhereWithAggregatesInput | PayslipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payslip"> | string
    accountId?: StringWithAggregatesFilter<"Payslip"> | string
    periodStartDate?: DateTimeWithAggregatesFilter<"Payslip"> | Date | string
    periodEndDate?: DateTimeWithAggregatesFilter<"Payslip"> | Date | string
    baseSalary?: IntWithAggregatesFilter<"Payslip"> | number
    totalCommissions?: IntWithAggregatesFilter<"Payslip"> | number
    totalDeductions?: IntWithAggregatesFilter<"Payslip"> | number
    totalBonuses?: IntWithAggregatesFilter<"Payslip"> | number
    netPay?: IntWithAggregatesFilter<"Payslip"> | number
    status?: EnumPayslipStatusWithAggregatesFilter<"Payslip"> | $Enums.PayslipStatus
    releasedDate?: DateTimeNullableWithAggregatesFilter<"Payslip"> | Date | string | null
    generatedAt?: DateTimeWithAggregatesFilter<"Payslip"> | Date | string
  }

  export type RecommendedAppointmentWhereInput = {
    AND?: RecommendedAppointmentWhereInput | RecommendedAppointmentWhereInput[]
    OR?: RecommendedAppointmentWhereInput[]
    NOT?: RecommendedAppointmentWhereInput | RecommendedAppointmentWhereInput[]
    id?: StringFilter<"RecommendedAppointment"> | string
    customerId?: StringFilter<"RecommendedAppointment"> | string
    recommendedDate?: DateTimeFilter<"RecommendedAppointment"> | Date | string
    originatingTransactionId?: StringNullableFilter<"RecommendedAppointment"> | string | null
    originatingAvailedServiceId?: StringFilter<"RecommendedAppointment"> | string
    originatingServiceId?: StringFilter<"RecommendedAppointment"> | string
    status?: EnumRecommendedAppointmentStatusFilter<"RecommendedAppointment"> | $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: StringNullableFilter<"RecommendedAppointment"> | string | null
    suppressNextFollowUpGeneration?: BoolFilter<"RecommendedAppointment"> | boolean
    reminder3DaySentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminder2DaySentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminder1DaySentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminderTodaySentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminder1DayAfterSentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminder7DaySentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminder7DayAfterSentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminder14DayAfterSentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    createdAt?: DateTimeFilter<"RecommendedAppointment"> | Date | string
    updatedAt?: DateTimeFilter<"RecommendedAppointment"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    originatingTransaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
    originatingAvailedService?: XOR<AvailedServiceScalarRelationFilter, AvailedServiceWhereInput>
    originatingService?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    attendedTransaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }

  export type RecommendedAppointmentOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    recommendedDate?: SortOrder
    originatingTransactionId?: SortOrderInput | SortOrder
    originatingAvailedServiceId?: SortOrder
    originatingServiceId?: SortOrder
    status?: SortOrder
    attendedTransactionId?: SortOrderInput | SortOrder
    suppressNextFollowUpGeneration?: SortOrder
    reminder3DaySentAt?: SortOrderInput | SortOrder
    reminder2DaySentAt?: SortOrderInput | SortOrder
    reminder1DaySentAt?: SortOrderInput | SortOrder
    reminderTodaySentAt?: SortOrderInput | SortOrder
    reminder1DayAfterSentAt?: SortOrderInput | SortOrder
    reminder7DaySentAt?: SortOrderInput | SortOrder
    reminder7DayAfterSentAt?: SortOrderInput | SortOrder
    reminder14DayAfterSentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    originatingTransaction?: TransactionOrderByWithRelationInput
    originatingAvailedService?: AvailedServiceOrderByWithRelationInput
    originatingService?: ServiceOrderByWithRelationInput
    attendedTransaction?: TransactionOrderByWithRelationInput
  }

  export type RecommendedAppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    originatingAvailedServiceId?: string
    attendedTransactionId?: string
    AND?: RecommendedAppointmentWhereInput | RecommendedAppointmentWhereInput[]
    OR?: RecommendedAppointmentWhereInput[]
    NOT?: RecommendedAppointmentWhereInput | RecommendedAppointmentWhereInput[]
    customerId?: StringFilter<"RecommendedAppointment"> | string
    recommendedDate?: DateTimeFilter<"RecommendedAppointment"> | Date | string
    originatingTransactionId?: StringNullableFilter<"RecommendedAppointment"> | string | null
    originatingServiceId?: StringFilter<"RecommendedAppointment"> | string
    status?: EnumRecommendedAppointmentStatusFilter<"RecommendedAppointment"> | $Enums.RecommendedAppointmentStatus
    suppressNextFollowUpGeneration?: BoolFilter<"RecommendedAppointment"> | boolean
    reminder3DaySentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminder2DaySentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminder1DaySentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminderTodaySentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminder1DayAfterSentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminder7DaySentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminder7DayAfterSentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminder14DayAfterSentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    createdAt?: DateTimeFilter<"RecommendedAppointment"> | Date | string
    updatedAt?: DateTimeFilter<"RecommendedAppointment"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    originatingTransaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
    originatingAvailedService?: XOR<AvailedServiceScalarRelationFilter, AvailedServiceWhereInput>
    originatingService?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    attendedTransaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }, "id" | "originatingAvailedServiceId" | "attendedTransactionId">

  export type RecommendedAppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    recommendedDate?: SortOrder
    originatingTransactionId?: SortOrderInput | SortOrder
    originatingAvailedServiceId?: SortOrder
    originatingServiceId?: SortOrder
    status?: SortOrder
    attendedTransactionId?: SortOrderInput | SortOrder
    suppressNextFollowUpGeneration?: SortOrder
    reminder3DaySentAt?: SortOrderInput | SortOrder
    reminder2DaySentAt?: SortOrderInput | SortOrder
    reminder1DaySentAt?: SortOrderInput | SortOrder
    reminderTodaySentAt?: SortOrderInput | SortOrder
    reminder1DayAfterSentAt?: SortOrderInput | SortOrder
    reminder7DaySentAt?: SortOrderInput | SortOrder
    reminder7DayAfterSentAt?: SortOrderInput | SortOrder
    reminder14DayAfterSentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecommendedAppointmentCountOrderByAggregateInput
    _max?: RecommendedAppointmentMaxOrderByAggregateInput
    _min?: RecommendedAppointmentMinOrderByAggregateInput
  }

  export type RecommendedAppointmentScalarWhereWithAggregatesInput = {
    AND?: RecommendedAppointmentScalarWhereWithAggregatesInput | RecommendedAppointmentScalarWhereWithAggregatesInput[]
    OR?: RecommendedAppointmentScalarWhereWithAggregatesInput[]
    NOT?: RecommendedAppointmentScalarWhereWithAggregatesInput | RecommendedAppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecommendedAppointment"> | string
    customerId?: StringWithAggregatesFilter<"RecommendedAppointment"> | string
    recommendedDate?: DateTimeWithAggregatesFilter<"RecommendedAppointment"> | Date | string
    originatingTransactionId?: StringNullableWithAggregatesFilter<"RecommendedAppointment"> | string | null
    originatingAvailedServiceId?: StringWithAggregatesFilter<"RecommendedAppointment"> | string
    originatingServiceId?: StringWithAggregatesFilter<"RecommendedAppointment"> | string
    status?: EnumRecommendedAppointmentStatusWithAggregatesFilter<"RecommendedAppointment"> | $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: StringNullableWithAggregatesFilter<"RecommendedAppointment"> | string | null
    suppressNextFollowUpGeneration?: BoolWithAggregatesFilter<"RecommendedAppointment"> | boolean
    reminder3DaySentAt?: DateTimeNullableWithAggregatesFilter<"RecommendedAppointment"> | Date | string | null
    reminder2DaySentAt?: DateTimeNullableWithAggregatesFilter<"RecommendedAppointment"> | Date | string | null
    reminder1DaySentAt?: DateTimeNullableWithAggregatesFilter<"RecommendedAppointment"> | Date | string | null
    reminderTodaySentAt?: DateTimeNullableWithAggregatesFilter<"RecommendedAppointment"> | Date | string | null
    reminder1DayAfterSentAt?: DateTimeNullableWithAggregatesFilter<"RecommendedAppointment"> | Date | string | null
    reminder7DaySentAt?: DateTimeNullableWithAggregatesFilter<"RecommendedAppointment"> | Date | string | null
    reminder7DayAfterSentAt?: DateTimeNullableWithAggregatesFilter<"RecommendedAppointment"> | Date | string | null
    reminder14DayAfterSentAt?: DateTimeNullableWithAggregatesFilter<"RecommendedAppointment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RecommendedAppointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RecommendedAppointment"> | Date | string
  }

  export type DiscountRuleWhereInput = {
    AND?: DiscountRuleWhereInput | DiscountRuleWhereInput[]
    OR?: DiscountRuleWhereInput[]
    NOT?: DiscountRuleWhereInput | DiscountRuleWhereInput[]
    id?: StringFilter<"DiscountRule"> | string
    description?: StringNullableFilter<"DiscountRule"> | string | null
    discountType?: EnumDiscountTypeFilter<"DiscountRule"> | $Enums.DiscountType
    discountValue?: FloatFilter<"DiscountRule"> | number
    startDate?: DateTimeFilter<"DiscountRule"> | Date | string
    endDate?: DateTimeFilter<"DiscountRule"> | Date | string
    isActive?: BoolFilter<"DiscountRule"> | boolean
    applyToAll?: BoolFilter<"DiscountRule"> | boolean
    createdAt?: DateTimeFilter<"DiscountRule"> | Date | string
    updatedAt?: DateTimeFilter<"DiscountRule"> | Date | string
    services?: ServiceListRelationFilter
  }

  export type DiscountRuleOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    applyToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
  }

  export type DiscountRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DiscountRuleWhereInput | DiscountRuleWhereInput[]
    OR?: DiscountRuleWhereInput[]
    NOT?: DiscountRuleWhereInput | DiscountRuleWhereInput[]
    description?: StringNullableFilter<"DiscountRule"> | string | null
    discountType?: EnumDiscountTypeFilter<"DiscountRule"> | $Enums.DiscountType
    discountValue?: FloatFilter<"DiscountRule"> | number
    startDate?: DateTimeFilter<"DiscountRule"> | Date | string
    endDate?: DateTimeFilter<"DiscountRule"> | Date | string
    isActive?: BoolFilter<"DiscountRule"> | boolean
    applyToAll?: BoolFilter<"DiscountRule"> | boolean
    createdAt?: DateTimeFilter<"DiscountRule"> | Date | string
    updatedAt?: DateTimeFilter<"DiscountRule"> | Date | string
    services?: ServiceListRelationFilter
  }, "id">

  export type DiscountRuleOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    applyToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DiscountRuleCountOrderByAggregateInput
    _avg?: DiscountRuleAvgOrderByAggregateInput
    _max?: DiscountRuleMaxOrderByAggregateInput
    _min?: DiscountRuleMinOrderByAggregateInput
    _sum?: DiscountRuleSumOrderByAggregateInput
  }

  export type DiscountRuleScalarWhereWithAggregatesInput = {
    AND?: DiscountRuleScalarWhereWithAggregatesInput | DiscountRuleScalarWhereWithAggregatesInput[]
    OR?: DiscountRuleScalarWhereWithAggregatesInput[]
    NOT?: DiscountRuleScalarWhereWithAggregatesInput | DiscountRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DiscountRule"> | string
    description?: StringNullableWithAggregatesFilter<"DiscountRule"> | string | null
    discountType?: EnumDiscountTypeWithAggregatesFilter<"DiscountRule"> | $Enums.DiscountType
    discountValue?: FloatWithAggregatesFilter<"DiscountRule"> | number
    startDate?: DateTimeWithAggregatesFilter<"DiscountRule"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"DiscountRule"> | Date | string
    isActive?: BoolWithAggregatesFilter<"DiscountRule"> | boolean
    applyToAll?: BoolWithAggregatesFilter<"DiscountRule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DiscountRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DiscountRule"> | Date | string
  }

  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: StringFilter<"Branch"> | string
    title?: StringFilter<"Branch"> | string
    code?: StringFilter<"Branch"> | string
    totalSales?: IntFilter<"Branch"> | number
    services?: ServiceListRelationFilter
    accounts?: AccountListRelationFilter
    manualSales?: ManualSaleListRelationFilter
    expenses?: ExpenseListRelationFilter
    Transaction?: TransactionListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    totalSales?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    manualSales?: ManualSaleOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    Transaction?: TransactionOrderByRelationAggregateInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    title?: string
    code?: string
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    totalSales?: IntFilter<"Branch"> | number
    services?: ServiceListRelationFilter
    accounts?: AccountListRelationFilter
    manualSales?: ManualSaleListRelationFilter
    expenses?: ExpenseListRelationFilter
    Transaction?: TransactionListRelationFilter
  }, "id" | "title" | "code">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    totalSales?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _avg?: BranchAvgOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
    _sum?: BranchSumOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Branch"> | string
    title?: StringWithAggregatesFilter<"Branch"> | string
    code?: StringWithAggregatesFilter<"Branch"> | string
    totalSales?: IntWithAggregatesFilter<"Branch"> | number
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    accountId?: StringFilter<"Attendance"> | string
    isPresent?: BoolFilter<"Attendance"> | boolean
    notes?: StringNullableFilter<"Attendance"> | string | null
    checkedById?: StringFilter<"Attendance"> | string
    checkedAt?: DateTimeFilter<"Attendance"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    checkedBy?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    accountId?: SortOrder
    isPresent?: SortOrder
    notes?: SortOrderInput | SortOrder
    checkedById?: SortOrder
    checkedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    checkedBy?: AccountOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    date_accountId?: AttendanceDateAccountIdCompoundUniqueInput
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    date?: DateTimeFilter<"Attendance"> | Date | string
    accountId?: StringFilter<"Attendance"> | string
    isPresent?: BoolFilter<"Attendance"> | boolean
    notes?: StringNullableFilter<"Attendance"> | string | null
    checkedById?: StringFilter<"Attendance"> | string
    checkedAt?: DateTimeFilter<"Attendance"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    checkedBy?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id" | "date_accountId">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    accountId?: SortOrder
    isPresent?: SortOrder
    notes?: SortOrderInput | SortOrder
    checkedById?: SortOrder
    checkedAt?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    date?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    accountId?: StringWithAggregatesFilter<"Attendance"> | string
    isPresent?: BoolWithAggregatesFilter<"Attendance"> | boolean
    notes?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    checkedById?: StringWithAggregatesFilter<"Attendance"> | string
    checkedAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    username?: StringFilter<"Account"> | string
    password?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    email?: StringNullableFilter<"Account"> | string | null
    role?: EnumRoleNullableListFilter<"Account">
    salary?: IntFilter<"Account"> | number
    dailyRate?: IntFilter<"Account"> | number
    branchId?: StringNullableFilter<"Account"> | string | null
    canRequestPayslip?: BoolFilter<"Account"> | boolean
    mustChangePassword?: BoolFilter<"Account"> | boolean
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    servicesServed?: AvailedServiceListRelationFilter
    servicesChecked?: AvailedServiceListRelationFilter
    attendances?: AttendanceListRelationFilter
    attendancesChecked?: AttendanceListRelationFilter
    payslips?: PayslipListRelationFilter
    payslipRequests?: PayslipRequestListRelationFilter
    managedPayslipRequests?: PayslipRequestListRelationFilter
    manualSales?: ManualSaleListRelationFilter
    expenses?: ExpenseListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    salary?: SortOrder
    dailyRate?: SortOrder
    branchId?: SortOrderInput | SortOrder
    canRequestPayslip?: SortOrder
    mustChangePassword?: SortOrder
    branch?: BranchOrderByWithRelationInput
    servicesServed?: AvailedServiceOrderByRelationAggregateInput
    servicesChecked?: AvailedServiceOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
    attendancesChecked?: AttendanceOrderByRelationAggregateInput
    payslips?: PayslipOrderByRelationAggregateInput
    payslipRequests?: PayslipRequestOrderByRelationAggregateInput
    managedPayslipRequests?: PayslipRequestOrderByRelationAggregateInput
    manualSales?: ManualSaleOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    password?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    role?: EnumRoleNullableListFilter<"Account">
    salary?: IntFilter<"Account"> | number
    dailyRate?: IntFilter<"Account"> | number
    branchId?: StringNullableFilter<"Account"> | string | null
    canRequestPayslip?: BoolFilter<"Account"> | boolean
    mustChangePassword?: BoolFilter<"Account"> | boolean
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    servicesServed?: AvailedServiceListRelationFilter
    servicesChecked?: AvailedServiceListRelationFilter
    attendances?: AttendanceListRelationFilter
    attendancesChecked?: AttendanceListRelationFilter
    payslips?: PayslipListRelationFilter
    payslipRequests?: PayslipRequestListRelationFilter
    managedPayslipRequests?: PayslipRequestListRelationFilter
    manualSales?: ManualSaleListRelationFilter
    expenses?: ExpenseListRelationFilter
  }, "id" | "username" | "email">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    salary?: SortOrder
    dailyRate?: SortOrder
    branchId?: SortOrderInput | SortOrder
    canRequestPayslip?: SortOrder
    mustChangePassword?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    username?: StringWithAggregatesFilter<"Account"> | string
    password?: StringWithAggregatesFilter<"Account"> | string
    name?: StringWithAggregatesFilter<"Account"> | string
    email?: StringNullableWithAggregatesFilter<"Account"> | string | null
    role?: EnumRoleNullableListFilter<"Account">
    salary?: IntWithAggregatesFilter<"Account"> | number
    dailyRate?: IntWithAggregatesFilter<"Account"> | number
    branchId?: StringNullableWithAggregatesFilter<"Account"> | string | null
    canRequestPayslip?: BoolWithAggregatesFilter<"Account"> | boolean
    mustChangePassword?: BoolWithAggregatesFilter<"Account"> | boolean
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    title?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    price?: IntFilter<"Service"> | number
    branchId?: StringFilter<"Service"> | string
    totalSales?: IntFilter<"Service"> | number
    recommendFollowUp?: BoolFilter<"Service"> | boolean
    recommendedFollowUpDays?: IntNullableFilter<"Service"> | number | null
    followUpPolicy?: EnumFollowUpPolicyFilter<"Service"> | $Enums.FollowUpPolicy
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    AvailedService?: AvailedServiceListRelationFilter
    serviceSets?: ServiceSetListRelationFilter
    giftCertificates?: GiftCertificateListRelationFilter
    discountRules?: DiscountRuleListRelationFilter
    recommendedAppointments?: RecommendedAppointmentListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    branchId?: SortOrder
    totalSales?: SortOrder
    recommendFollowUp?: SortOrder
    recommendedFollowUpDays?: SortOrderInput | SortOrder
    followUpPolicy?: SortOrder
    branch?: BranchOrderByWithRelationInput
    AvailedService?: AvailedServiceOrderByRelationAggregateInput
    serviceSets?: ServiceSetOrderByRelationAggregateInput
    giftCertificates?: GiftCertificateOrderByRelationAggregateInput
    discountRules?: DiscountRuleOrderByRelationAggregateInput
    recommendedAppointments?: RecommendedAppointmentOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    title?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    description?: StringNullableFilter<"Service"> | string | null
    price?: IntFilter<"Service"> | number
    branchId?: StringFilter<"Service"> | string
    totalSales?: IntFilter<"Service"> | number
    recommendFollowUp?: BoolFilter<"Service"> | boolean
    recommendedFollowUpDays?: IntNullableFilter<"Service"> | number | null
    followUpPolicy?: EnumFollowUpPolicyFilter<"Service"> | $Enums.FollowUpPolicy
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    AvailedService?: AvailedServiceListRelationFilter
    serviceSets?: ServiceSetListRelationFilter
    giftCertificates?: GiftCertificateListRelationFilter
    discountRules?: DiscountRuleListRelationFilter
    recommendedAppointments?: RecommendedAppointmentListRelationFilter
  }, "id" | "title">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    branchId?: SortOrder
    totalSales?: SortOrder
    recommendFollowUp?: SortOrder
    recommendedFollowUpDays?: SortOrderInput | SortOrder
    followUpPolicy?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    title?: StringWithAggregatesFilter<"Service"> | string
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    price?: IntWithAggregatesFilter<"Service"> | number
    branchId?: StringWithAggregatesFilter<"Service"> | string
    totalSales?: IntWithAggregatesFilter<"Service"> | number
    recommendFollowUp?: BoolWithAggregatesFilter<"Service"> | boolean
    recommendedFollowUpDays?: IntNullableWithAggregatesFilter<"Service"> | number | null
    followUpPolicy?: EnumFollowUpPolicyWithAggregatesFilter<"Service"> | $Enums.FollowUpPolicy
  }

  export type ServiceSetWhereInput = {
    AND?: ServiceSetWhereInput | ServiceSetWhereInput[]
    OR?: ServiceSetWhereInput[]
    NOT?: ServiceSetWhereInput | ServiceSetWhereInput[]
    id?: StringFilter<"ServiceSet"> | string
    title?: StringFilter<"ServiceSet"> | string
    price?: IntFilter<"ServiceSet"> | number
    services?: ServiceListRelationFilter
    giftCertificates?: GiftCertificateListRelationFilter
    AvailedService?: AvailedServiceListRelationFilter
  }

  export type ServiceSetOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    price?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
    giftCertificates?: GiftCertificateOrderByRelationAggregateInput
    AvailedService?: AvailedServiceOrderByRelationAggregateInput
  }

  export type ServiceSetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    title?: string
    AND?: ServiceSetWhereInput | ServiceSetWhereInput[]
    OR?: ServiceSetWhereInput[]
    NOT?: ServiceSetWhereInput | ServiceSetWhereInput[]
    price?: IntFilter<"ServiceSet"> | number
    services?: ServiceListRelationFilter
    giftCertificates?: GiftCertificateListRelationFilter
    AvailedService?: AvailedServiceListRelationFilter
  }, "id" | "title">

  export type ServiceSetOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    price?: SortOrder
    _count?: ServiceSetCountOrderByAggregateInput
    _avg?: ServiceSetAvgOrderByAggregateInput
    _max?: ServiceSetMaxOrderByAggregateInput
    _min?: ServiceSetMinOrderByAggregateInput
    _sum?: ServiceSetSumOrderByAggregateInput
  }

  export type ServiceSetScalarWhereWithAggregatesInput = {
    AND?: ServiceSetScalarWhereWithAggregatesInput | ServiceSetScalarWhereWithAggregatesInput[]
    OR?: ServiceSetScalarWhereWithAggregatesInput[]
    NOT?: ServiceSetScalarWhereWithAggregatesInput | ServiceSetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceSet"> | string
    title?: StringWithAggregatesFilter<"ServiceSet"> | string
    price?: IntWithAggregatesFilter<"ServiceSet"> | number
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    totalPaid?: FloatFilter<"Customer"> | number
    nextAppointment?: DateTimeNullableFilter<"Customer"> | Date | string | null
    recommendedAppointments?: RecommendedAppointmentListRelationFilter
    transactionHistory?: TransactionListRelationFilter
    purchasedGiftCertificates?: GiftCertificateListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    totalPaid?: SortOrder
    nextAppointment?: SortOrderInput | SortOrder
    recommendedAppointments?: RecommendedAppointmentOrderByRelationAggregateInput
    transactionHistory?: TransactionOrderByRelationAggregateInput
    purchasedGiftCertificates?: GiftCertificateOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    totalPaid?: FloatFilter<"Customer"> | number
    nextAppointment?: DateTimeNullableFilter<"Customer"> | Date | string | null
    recommendedAppointments?: RecommendedAppointmentListRelationFilter
    transactionHistory?: TransactionListRelationFilter
    purchasedGiftCertificates?: GiftCertificateListRelationFilter
  }, "id" | "email">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    totalPaid?: SortOrder
    nextAppointment?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    totalPaid?: FloatWithAggregatesFilter<"Customer"> | number
    nextAppointment?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
  }

  export type VoucherWhereInput = {
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    id?: StringFilter<"Voucher"> | string
    code?: StringFilter<"Voucher"> | string
    value?: IntFilter<"Voucher"> | number
    usedAt?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    Transaction?: TransactionListRelationFilter
  }

  export type VoucherOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    value?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    Transaction?: TransactionOrderByRelationAggregateInput
  }

  export type VoucherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    value?: IntFilter<"Voucher"> | number
    usedAt?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    Transaction?: TransactionListRelationFilter
  }, "id" | "code">

  export type VoucherOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    value?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    _count?: VoucherCountOrderByAggregateInput
    _avg?: VoucherAvgOrderByAggregateInput
    _max?: VoucherMaxOrderByAggregateInput
    _min?: VoucherMinOrderByAggregateInput
    _sum?: VoucherSumOrderByAggregateInput
  }

  export type VoucherScalarWhereWithAggregatesInput = {
    AND?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    OR?: VoucherScalarWhereWithAggregatesInput[]
    NOT?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Voucher"> | string
    code?: StringWithAggregatesFilter<"Voucher"> | string
    value?: IntWithAggregatesFilter<"Voucher"> | number
    usedAt?: DateTimeNullableWithAggregatesFilter<"Voucher"> | Date | string | null
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    bookedFor?: DateTimeFilter<"Transaction"> | Date | string
    customerId?: StringFilter<"Transaction"> | string
    voucherId?: StringNullableFilter<"Transaction"> | string | null
    discount?: IntFilter<"Transaction"> | number
    paymentMethod?: EnumPaymentMethodNullableFilter<"Transaction"> | $Enums.PaymentMethod | null
    grandTotal?: IntFilter<"Transaction"> | number
    status?: EnumStatusFilter<"Transaction"> | $Enums.Status
    branchId?: StringNullableFilter<"Transaction"> | string | null
    bookingReminderSentAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    giftCertificateId?: StringNullableFilter<"Transaction"> | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    availedServices?: AvailedServiceListRelationFilter
    voucherUsed?: XOR<VoucherNullableScalarRelationFilter, VoucherWhereInput> | null
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    giftCertificateUsed?: XOR<GiftCertificateNullableScalarRelationFilter, GiftCertificateWhereInput> | null
    originatingRecommendations?: RecommendedAppointmentListRelationFilter
    attendedAppointment?: XOR<RecommendedAppointmentNullableScalarRelationFilter, RecommendedAppointmentWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    bookedFor?: SortOrder
    customerId?: SortOrder
    voucherId?: SortOrderInput | SortOrder
    discount?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    grandTotal?: SortOrder
    status?: SortOrder
    branchId?: SortOrderInput | SortOrder
    bookingReminderSentAt?: SortOrderInput | SortOrder
    giftCertificateId?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    availedServices?: AvailedServiceOrderByRelationAggregateInput
    voucherUsed?: VoucherOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    giftCertificateUsed?: GiftCertificateOrderByWithRelationInput
    originatingRecommendations?: RecommendedAppointmentOrderByRelationAggregateInput
    attendedAppointment?: RecommendedAppointmentOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    bookedFor?: DateTimeFilter<"Transaction"> | Date | string
    customerId?: StringFilter<"Transaction"> | string
    voucherId?: StringNullableFilter<"Transaction"> | string | null
    discount?: IntFilter<"Transaction"> | number
    paymentMethod?: EnumPaymentMethodNullableFilter<"Transaction"> | $Enums.PaymentMethod | null
    grandTotal?: IntFilter<"Transaction"> | number
    status?: EnumStatusFilter<"Transaction"> | $Enums.Status
    branchId?: StringNullableFilter<"Transaction"> | string | null
    bookingReminderSentAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    giftCertificateId?: StringNullableFilter<"Transaction"> | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    availedServices?: AvailedServiceListRelationFilter
    voucherUsed?: XOR<VoucherNullableScalarRelationFilter, VoucherWhereInput> | null
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    giftCertificateUsed?: XOR<GiftCertificateNullableScalarRelationFilter, GiftCertificateWhereInput> | null
    originatingRecommendations?: RecommendedAppointmentListRelationFilter
    attendedAppointment?: XOR<RecommendedAppointmentNullableScalarRelationFilter, RecommendedAppointmentWhereInput> | null
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    bookedFor?: SortOrder
    customerId?: SortOrder
    voucherId?: SortOrderInput | SortOrder
    discount?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    grandTotal?: SortOrder
    status?: SortOrder
    branchId?: SortOrderInput | SortOrder
    bookingReminderSentAt?: SortOrderInput | SortOrder
    giftCertificateId?: SortOrderInput | SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    bookedFor?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    customerId?: StringWithAggregatesFilter<"Transaction"> | string
    voucherId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    discount?: IntWithAggregatesFilter<"Transaction"> | number
    paymentMethod?: EnumPaymentMethodNullableWithAggregatesFilter<"Transaction"> | $Enums.PaymentMethod | null
    grandTotal?: IntWithAggregatesFilter<"Transaction"> | number
    status?: EnumStatusWithAggregatesFilter<"Transaction"> | $Enums.Status
    branchId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    bookingReminderSentAt?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    giftCertificateId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
  }

  export type AvailedServiceWhereInput = {
    AND?: AvailedServiceWhereInput | AvailedServiceWhereInput[]
    OR?: AvailedServiceWhereInput[]
    NOT?: AvailedServiceWhereInput | AvailedServiceWhereInput[]
    id?: StringFilter<"AvailedService"> | string
    transactionId?: StringFilter<"AvailedService"> | string
    serviceId?: StringNullableFilter<"AvailedService"> | string | null
    quantity?: IntFilter<"AvailedService"> | number
    price?: IntFilter<"AvailedService"> | number
    commissionValue?: IntFilter<"AvailedService"> | number
    originatingSetId?: StringNullableFilter<"AvailedService"> | string | null
    originatingSetTitle?: StringNullableFilter<"AvailedService"> | string | null
    checkedById?: StringNullableFilter<"AvailedService"> | string | null
    servedById?: StringNullableFilter<"AvailedService"> | string | null
    serviceSetId?: StringNullableFilter<"AvailedService"> | string | null
    status?: EnumStatusFilter<"AvailedService"> | $Enums.Status
    completedAt?: DateTimeNullableFilter<"AvailedService"> | Date | string | null
    createdAt?: DateTimeFilter<"AvailedService"> | Date | string
    updatedAt?: DateTimeFilter<"AvailedService"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
    originatingSet?: XOR<ServiceSetNullableScalarRelationFilter, ServiceSetWhereInput> | null
    checkedBy?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    servedBy?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    recommendedAppointment?: XOR<RecommendedAppointmentNullableScalarRelationFilter, RecommendedAppointmentWhereInput> | null
  }

  export type AvailedServiceOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    price?: SortOrder
    commissionValue?: SortOrder
    originatingSetId?: SortOrderInput | SortOrder
    originatingSetTitle?: SortOrderInput | SortOrder
    checkedById?: SortOrderInput | SortOrder
    servedById?: SortOrderInput | SortOrder
    serviceSetId?: SortOrderInput | SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    originatingSet?: ServiceSetOrderByWithRelationInput
    checkedBy?: AccountOrderByWithRelationInput
    servedBy?: AccountOrderByWithRelationInput
    recommendedAppointment?: RecommendedAppointmentOrderByWithRelationInput
  }

  export type AvailedServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AvailedServiceWhereInput | AvailedServiceWhereInput[]
    OR?: AvailedServiceWhereInput[]
    NOT?: AvailedServiceWhereInput | AvailedServiceWhereInput[]
    transactionId?: StringFilter<"AvailedService"> | string
    serviceId?: StringNullableFilter<"AvailedService"> | string | null
    quantity?: IntFilter<"AvailedService"> | number
    price?: IntFilter<"AvailedService"> | number
    commissionValue?: IntFilter<"AvailedService"> | number
    originatingSetId?: StringNullableFilter<"AvailedService"> | string | null
    originatingSetTitle?: StringNullableFilter<"AvailedService"> | string | null
    checkedById?: StringNullableFilter<"AvailedService"> | string | null
    servedById?: StringNullableFilter<"AvailedService"> | string | null
    serviceSetId?: StringNullableFilter<"AvailedService"> | string | null
    status?: EnumStatusFilter<"AvailedService"> | $Enums.Status
    completedAt?: DateTimeNullableFilter<"AvailedService"> | Date | string | null
    createdAt?: DateTimeFilter<"AvailedService"> | Date | string
    updatedAt?: DateTimeFilter<"AvailedService"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
    originatingSet?: XOR<ServiceSetNullableScalarRelationFilter, ServiceSetWhereInput> | null
    checkedBy?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    servedBy?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    recommendedAppointment?: XOR<RecommendedAppointmentNullableScalarRelationFilter, RecommendedAppointmentWhereInput> | null
  }, "id">

  export type AvailedServiceOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    price?: SortOrder
    commissionValue?: SortOrder
    originatingSetId?: SortOrderInput | SortOrder
    originatingSetTitle?: SortOrderInput | SortOrder
    checkedById?: SortOrderInput | SortOrder
    servedById?: SortOrderInput | SortOrder
    serviceSetId?: SortOrderInput | SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AvailedServiceCountOrderByAggregateInput
    _avg?: AvailedServiceAvgOrderByAggregateInput
    _max?: AvailedServiceMaxOrderByAggregateInput
    _min?: AvailedServiceMinOrderByAggregateInput
    _sum?: AvailedServiceSumOrderByAggregateInput
  }

  export type AvailedServiceScalarWhereWithAggregatesInput = {
    AND?: AvailedServiceScalarWhereWithAggregatesInput | AvailedServiceScalarWhereWithAggregatesInput[]
    OR?: AvailedServiceScalarWhereWithAggregatesInput[]
    NOT?: AvailedServiceScalarWhereWithAggregatesInput | AvailedServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AvailedService"> | string
    transactionId?: StringWithAggregatesFilter<"AvailedService"> | string
    serviceId?: StringNullableWithAggregatesFilter<"AvailedService"> | string | null
    quantity?: IntWithAggregatesFilter<"AvailedService"> | number
    price?: IntWithAggregatesFilter<"AvailedService"> | number
    commissionValue?: IntWithAggregatesFilter<"AvailedService"> | number
    originatingSetId?: StringNullableWithAggregatesFilter<"AvailedService"> | string | null
    originatingSetTitle?: StringNullableWithAggregatesFilter<"AvailedService"> | string | null
    checkedById?: StringNullableWithAggregatesFilter<"AvailedService"> | string | null
    servedById?: StringNullableWithAggregatesFilter<"AvailedService"> | string | null
    serviceSetId?: StringNullableWithAggregatesFilter<"AvailedService"> | string | null
    status?: EnumStatusWithAggregatesFilter<"AvailedService"> | $Enums.Status
    completedAt?: DateTimeNullableWithAggregatesFilter<"AvailedService"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AvailedService"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AvailedService"> | Date | string
  }

  export type GiftCertificateWhereInput = {
    AND?: GiftCertificateWhereInput | GiftCertificateWhereInput[]
    OR?: GiftCertificateWhereInput[]
    NOT?: GiftCertificateWhereInput | GiftCertificateWhereInput[]
    id?: StringFilter<"GiftCertificate"> | string
    code?: StringFilter<"GiftCertificate"> | string
    issuedAt?: DateTimeFilter<"GiftCertificate"> | Date | string
    expiresAt?: DateTimeNullableFilter<"GiftCertificate"> | Date | string | null
    purchaserCustomerId?: StringNullableFilter<"GiftCertificate"> | string | null
    recipientName?: StringNullableFilter<"GiftCertificate"> | string | null
    recipientEmail?: StringNullableFilter<"GiftCertificate"> | string | null
    usedAt?: DateTimeNullableFilter<"GiftCertificate"> | Date | string | null
    purchaserCustomer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    services?: ServiceListRelationFilter
    serviceSets?: ServiceSetListRelationFilter
    transactions?: TransactionListRelationFilter
  }

  export type GiftCertificateOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    purchaserCustomerId?: SortOrderInput | SortOrder
    recipientName?: SortOrderInput | SortOrder
    recipientEmail?: SortOrderInput | SortOrder
    usedAt?: SortOrderInput | SortOrder
    purchaserCustomer?: CustomerOrderByWithRelationInput
    services?: ServiceOrderByRelationAggregateInput
    serviceSets?: ServiceSetOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type GiftCertificateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: GiftCertificateWhereInput | GiftCertificateWhereInput[]
    OR?: GiftCertificateWhereInput[]
    NOT?: GiftCertificateWhereInput | GiftCertificateWhereInput[]
    issuedAt?: DateTimeFilter<"GiftCertificate"> | Date | string
    expiresAt?: DateTimeNullableFilter<"GiftCertificate"> | Date | string | null
    purchaserCustomerId?: StringNullableFilter<"GiftCertificate"> | string | null
    recipientName?: StringNullableFilter<"GiftCertificate"> | string | null
    recipientEmail?: StringNullableFilter<"GiftCertificate"> | string | null
    usedAt?: DateTimeNullableFilter<"GiftCertificate"> | Date | string | null
    purchaserCustomer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    services?: ServiceListRelationFilter
    serviceSets?: ServiceSetListRelationFilter
    transactions?: TransactionListRelationFilter
  }, "id" | "code">

  export type GiftCertificateOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    purchaserCustomerId?: SortOrderInput | SortOrder
    recipientName?: SortOrderInput | SortOrder
    recipientEmail?: SortOrderInput | SortOrder
    usedAt?: SortOrderInput | SortOrder
    _count?: GiftCertificateCountOrderByAggregateInput
    _max?: GiftCertificateMaxOrderByAggregateInput
    _min?: GiftCertificateMinOrderByAggregateInput
  }

  export type GiftCertificateScalarWhereWithAggregatesInput = {
    AND?: GiftCertificateScalarWhereWithAggregatesInput | GiftCertificateScalarWhereWithAggregatesInput[]
    OR?: GiftCertificateScalarWhereWithAggregatesInput[]
    NOT?: GiftCertificateScalarWhereWithAggregatesInput | GiftCertificateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GiftCertificate"> | string
    code?: StringWithAggregatesFilter<"GiftCertificate"> | string
    issuedAt?: DateTimeWithAggregatesFilter<"GiftCertificate"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"GiftCertificate"> | Date | string | null
    purchaserCustomerId?: StringNullableWithAggregatesFilter<"GiftCertificate"> | string | null
    recipientName?: StringNullableWithAggregatesFilter<"GiftCertificate"> | string | null
    recipientEmail?: StringNullableWithAggregatesFilter<"GiftCertificate"> | string | null
    usedAt?: DateTimeNullableWithAggregatesFilter<"GiftCertificate"> | Date | string | null
  }

  export type ManualSaleWhereInput = {
    AND?: ManualSaleWhereInput | ManualSaleWhereInput[]
    OR?: ManualSaleWhereInput[]
    NOT?: ManualSaleWhereInput | ManualSaleWhereInput[]
    id?: StringFilter<"ManualSale"> | string
    date?: DateTimeFilter<"ManualSale"> | Date | string
    amount?: IntFilter<"ManualSale"> | number
    paymentMethod?: EnumPaymentMethodNullableFilter<"ManualSale"> | $Enums.PaymentMethod | null
    description?: StringNullableFilter<"ManualSale"> | string | null
    createdAt?: DateTimeFilter<"ManualSale"> | Date | string
    updatedAt?: DateTimeFilter<"ManualSale"> | Date | string
    recordedById?: StringFilter<"ManualSale"> | string
    branchId?: StringNullableFilter<"ManualSale"> | string | null
    recordedBy?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
  }

  export type ManualSaleOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recordedById?: SortOrder
    branchId?: SortOrderInput | SortOrder
    recordedBy?: AccountOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type ManualSaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ManualSaleWhereInput | ManualSaleWhereInput[]
    OR?: ManualSaleWhereInput[]
    NOT?: ManualSaleWhereInput | ManualSaleWhereInput[]
    date?: DateTimeFilter<"ManualSale"> | Date | string
    amount?: IntFilter<"ManualSale"> | number
    paymentMethod?: EnumPaymentMethodNullableFilter<"ManualSale"> | $Enums.PaymentMethod | null
    description?: StringNullableFilter<"ManualSale"> | string | null
    createdAt?: DateTimeFilter<"ManualSale"> | Date | string
    updatedAt?: DateTimeFilter<"ManualSale"> | Date | string
    recordedById?: StringFilter<"ManualSale"> | string
    branchId?: StringNullableFilter<"ManualSale"> | string | null
    recordedBy?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
  }, "id">

  export type ManualSaleOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recordedById?: SortOrder
    branchId?: SortOrderInput | SortOrder
    _count?: ManualSaleCountOrderByAggregateInput
    _avg?: ManualSaleAvgOrderByAggregateInput
    _max?: ManualSaleMaxOrderByAggregateInput
    _min?: ManualSaleMinOrderByAggregateInput
    _sum?: ManualSaleSumOrderByAggregateInput
  }

  export type ManualSaleScalarWhereWithAggregatesInput = {
    AND?: ManualSaleScalarWhereWithAggregatesInput | ManualSaleScalarWhereWithAggregatesInput[]
    OR?: ManualSaleScalarWhereWithAggregatesInput[]
    NOT?: ManualSaleScalarWhereWithAggregatesInput | ManualSaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ManualSale"> | string
    date?: DateTimeWithAggregatesFilter<"ManualSale"> | Date | string
    amount?: IntWithAggregatesFilter<"ManualSale"> | number
    paymentMethod?: EnumPaymentMethodNullableWithAggregatesFilter<"ManualSale"> | $Enums.PaymentMethod | null
    description?: StringNullableWithAggregatesFilter<"ManualSale"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ManualSale"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ManualSale"> | Date | string
    recordedById?: StringWithAggregatesFilter<"ManualSale"> | string
    branchId?: StringNullableWithAggregatesFilter<"ManualSale"> | string | null
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: StringFilter<"Expense"> | string
    date?: DateTimeFilter<"Expense"> | Date | string
    amount?: IntFilter<"Expense"> | number
    category?: EnumExpenseCategoryFilter<"Expense"> | $Enums.ExpenseCategory
    description?: StringNullableFilter<"Expense"> | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    recordedById?: StringFilter<"Expense"> | string
    branchId?: StringNullableFilter<"Expense"> | string | null
    recordedBy?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recordedById?: SortOrder
    branchId?: SortOrderInput | SortOrder
    recordedBy?: AccountOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    date?: DateTimeFilter<"Expense"> | Date | string
    amount?: IntFilter<"Expense"> | number
    category?: EnumExpenseCategoryFilter<"Expense"> | $Enums.ExpenseCategory
    description?: StringNullableFilter<"Expense"> | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    recordedById?: StringFilter<"Expense"> | string
    branchId?: StringNullableFilter<"Expense"> | string | null
    recordedBy?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recordedById?: SortOrder
    branchId?: SortOrderInput | SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expense"> | string
    date?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    amount?: IntWithAggregatesFilter<"Expense"> | number
    category?: EnumExpenseCategoryWithAggregatesFilter<"Expense"> | $Enums.ExpenseCategory
    description?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    recordedById?: StringWithAggregatesFilter<"Expense"> | string
    branchId?: StringNullableWithAggregatesFilter<"Expense"> | string | null
  }

  export type EmailTemplateWhereInput = {
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    id?: StringFilter<"EmailTemplate"> | string
    name?: StringFilter<"EmailTemplate"> | string
    subject?: StringFilter<"EmailTemplate"> | string
    body?: StringFilter<"EmailTemplate"> | string
    placeholders?: StringNullableListFilter<"EmailTemplate">
    isActive?: BoolFilter<"EmailTemplate"> | boolean
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
  }

  export type EmailTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    placeholders?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    subject?: StringFilter<"EmailTemplate"> | string
    body?: StringFilter<"EmailTemplate"> | string
    placeholders?: StringNullableListFilter<"EmailTemplate">
    isActive?: BoolFilter<"EmailTemplate"> | boolean
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
  }, "id" | "name">

  export type EmailTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    placeholders?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailTemplateCountOrderByAggregateInput
    _max?: EmailTemplateMaxOrderByAggregateInput
    _min?: EmailTemplateMinOrderByAggregateInput
  }

  export type EmailTemplateScalarWhereWithAggregatesInput = {
    AND?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    OR?: EmailTemplateScalarWhereWithAggregatesInput[]
    NOT?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailTemplate"> | string
    name?: StringWithAggregatesFilter<"EmailTemplate"> | string
    subject?: StringWithAggregatesFilter<"EmailTemplate"> | string
    body?: StringWithAggregatesFilter<"EmailTemplate"> | string
    placeholders?: StringNullableListFilter<"EmailTemplate">
    isActive?: BoolWithAggregatesFilter<"EmailTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
  }

  export type PayslipRequestCreateInput = {
    id?: string
    requestTimestamp?: Date | string
    periodStartDate: Date | string
    periodEndDate: Date | string
    status?: $Enums.PayslipRequestStatus
    notes?: string | null
    processedTimestamp?: Date | string | null
    account: AccountCreateNestedOneWithoutPayslipRequestsInput
    processedBy?: AccountCreateNestedOneWithoutManagedPayslipRequestsInput
    relatedPayslip?: PayslipCreateNestedOneWithoutPayslipRequestInput
  }

  export type PayslipRequestUncheckedCreateInput = {
    id?: string
    accountId: string
    requestTimestamp?: Date | string
    periodStartDate: Date | string
    periodEndDate: Date | string
    status?: $Enums.PayslipRequestStatus
    notes?: string | null
    processedById?: string | null
    processedTimestamp?: Date | string | null
    relatedPayslipId?: string | null
  }

  export type PayslipRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayslipRequestStatusFieldUpdateOperationsInput | $Enums.PayslipRequestStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUpdateOneRequiredWithoutPayslipRequestsNestedInput
    processedBy?: AccountUpdateOneWithoutManagedPayslipRequestsNestedInput
    relatedPayslip?: PayslipUpdateOneWithoutPayslipRequestNestedInput
  }

  export type PayslipRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayslipRequestStatusFieldUpdateOperationsInput | $Enums.PayslipRequestStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relatedPayslipId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PayslipRequestCreateManyInput = {
    id?: string
    accountId: string
    requestTimestamp?: Date | string
    periodStartDate: Date | string
    periodEndDate: Date | string
    status?: $Enums.PayslipRequestStatus
    notes?: string | null
    processedById?: string | null
    processedTimestamp?: Date | string | null
    relatedPayslipId?: string | null
  }

  export type PayslipRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayslipRequestStatusFieldUpdateOperationsInput | $Enums.PayslipRequestStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayslipRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayslipRequestStatusFieldUpdateOperationsInput | $Enums.PayslipRequestStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relatedPayslipId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PayslipCreateInput = {
    id?: string
    periodStartDate: Date | string
    periodEndDate: Date | string
    baseSalary: number
    totalCommissions: number
    totalDeductions?: number
    totalBonuses?: number
    netPay: number
    status?: $Enums.PayslipStatus
    releasedDate?: Date | string | null
    generatedAt?: Date | string
    account: AccountCreateNestedOneWithoutPayslipsInput
    payslipRequest?: PayslipRequestCreateNestedOneWithoutRelatedPayslipInput
  }

  export type PayslipUncheckedCreateInput = {
    id?: string
    accountId: string
    periodStartDate: Date | string
    periodEndDate: Date | string
    baseSalary: number
    totalCommissions: number
    totalDeductions?: number
    totalBonuses?: number
    netPay: number
    status?: $Enums.PayslipStatus
    releasedDate?: Date | string | null
    generatedAt?: Date | string
    payslipRequest?: PayslipRequestUncheckedCreateNestedOneWithoutRelatedPayslipInput
  }

  export type PayslipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    baseSalary?: IntFieldUpdateOperationsInput | number
    totalCommissions?: IntFieldUpdateOperationsInput | number
    totalDeductions?: IntFieldUpdateOperationsInput | number
    totalBonuses?: IntFieldUpdateOperationsInput | number
    netPay?: IntFieldUpdateOperationsInput | number
    status?: EnumPayslipStatusFieldUpdateOperationsInput | $Enums.PayslipStatus
    releasedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutPayslipsNestedInput
    payslipRequest?: PayslipRequestUpdateOneWithoutRelatedPayslipNestedInput
  }

  export type PayslipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    baseSalary?: IntFieldUpdateOperationsInput | number
    totalCommissions?: IntFieldUpdateOperationsInput | number
    totalDeductions?: IntFieldUpdateOperationsInput | number
    totalBonuses?: IntFieldUpdateOperationsInput | number
    netPay?: IntFieldUpdateOperationsInput | number
    status?: EnumPayslipStatusFieldUpdateOperationsInput | $Enums.PayslipStatus
    releasedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payslipRequest?: PayslipRequestUncheckedUpdateOneWithoutRelatedPayslipNestedInput
  }

  export type PayslipCreateManyInput = {
    id?: string
    accountId: string
    periodStartDate: Date | string
    periodEndDate: Date | string
    baseSalary: number
    totalCommissions: number
    totalDeductions?: number
    totalBonuses?: number
    netPay: number
    status?: $Enums.PayslipStatus
    releasedDate?: Date | string | null
    generatedAt?: Date | string
  }

  export type PayslipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    baseSalary?: IntFieldUpdateOperationsInput | number
    totalCommissions?: IntFieldUpdateOperationsInput | number
    totalDeductions?: IntFieldUpdateOperationsInput | number
    totalBonuses?: IntFieldUpdateOperationsInput | number
    netPay?: IntFieldUpdateOperationsInput | number
    status?: EnumPayslipStatusFieldUpdateOperationsInput | $Enums.PayslipStatus
    releasedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayslipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    baseSalary?: IntFieldUpdateOperationsInput | number
    totalCommissions?: IntFieldUpdateOperationsInput | number
    totalDeductions?: IntFieldUpdateOperationsInput | number
    totalBonuses?: IntFieldUpdateOperationsInput | number
    netPay?: IntFieldUpdateOperationsInput | number
    status?: EnumPayslipStatusFieldUpdateOperationsInput | $Enums.PayslipStatus
    releasedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendedAppointmentCreateInput = {
    id?: string
    recommendedDate: Date | string
    status?: $Enums.RecommendedAppointmentStatus
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: Date | string | null
    reminder2DaySentAt?: Date | string | null
    reminder1DaySentAt?: Date | string | null
    reminderTodaySentAt?: Date | string | null
    reminder1DayAfterSentAt?: Date | string | null
    reminder7DaySentAt?: Date | string | null
    reminder7DayAfterSentAt?: Date | string | null
    reminder14DayAfterSentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutRecommendedAppointmentsInput
    originatingTransaction?: TransactionCreateNestedOneWithoutOriginatingRecommendationsInput
    originatingAvailedService: AvailedServiceCreateNestedOneWithoutRecommendedAppointmentInput
    originatingService: ServiceCreateNestedOneWithoutRecommendedAppointmentsInput
    attendedTransaction?: TransactionCreateNestedOneWithoutAttendedAppointmentInput
  }

  export type RecommendedAppointmentUncheckedCreateInput = {
    id?: string
    customerId: string
    recommendedDate: Date | string
    originatingTransactionId?: string | null
    originatingAvailedServiceId: string
    originatingServiceId: string
    status?: $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: string | null
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: Date | string | null
    reminder2DaySentAt?: Date | string | null
    reminder1DaySentAt?: Date | string | null
    reminderTodaySentAt?: Date | string | null
    reminder1DayAfterSentAt?: Date | string | null
    reminder7DaySentAt?: Date | string | null
    reminder7DayAfterSentAt?: Date | string | null
    reminder14DayAfterSentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecommendedAppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recommendedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRecommendedAppointmentStatusFieldUpdateOperationsInput | $Enums.RecommendedAppointmentStatus
    suppressNextFollowUpGeneration?: BoolFieldUpdateOperationsInput | boolean
    reminder3DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTodaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder14DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutRecommendedAppointmentsNestedInput
    originatingTransaction?: TransactionUpdateOneWithoutOriginatingRecommendationsNestedInput
    originatingAvailedService?: AvailedServiceUpdateOneRequiredWithoutRecommendedAppointmentNestedInput
    originatingService?: ServiceUpdateOneRequiredWithoutRecommendedAppointmentsNestedInput
    attendedTransaction?: TransactionUpdateOneWithoutAttendedAppointmentNestedInput
  }

  export type RecommendedAppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    recommendedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    originatingTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingAvailedServiceId?: StringFieldUpdateOperationsInput | string
    originatingServiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumRecommendedAppointmentStatusFieldUpdateOperationsInput | $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    suppressNextFollowUpGeneration?: BoolFieldUpdateOperationsInput | boolean
    reminder3DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTodaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder14DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendedAppointmentCreateManyInput = {
    id?: string
    customerId: string
    recommendedDate: Date | string
    originatingTransactionId?: string | null
    originatingAvailedServiceId: string
    originatingServiceId: string
    status?: $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: string | null
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: Date | string | null
    reminder2DaySentAt?: Date | string | null
    reminder1DaySentAt?: Date | string | null
    reminderTodaySentAt?: Date | string | null
    reminder1DayAfterSentAt?: Date | string | null
    reminder7DaySentAt?: Date | string | null
    reminder7DayAfterSentAt?: Date | string | null
    reminder14DayAfterSentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecommendedAppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recommendedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRecommendedAppointmentStatusFieldUpdateOperationsInput | $Enums.RecommendedAppointmentStatus
    suppressNextFollowUpGeneration?: BoolFieldUpdateOperationsInput | boolean
    reminder3DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTodaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder14DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendedAppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    recommendedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    originatingTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingAvailedServiceId?: StringFieldUpdateOperationsInput | string
    originatingServiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumRecommendedAppointmentStatusFieldUpdateOperationsInput | $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    suppressNextFollowUpGeneration?: BoolFieldUpdateOperationsInput | boolean
    reminder3DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTodaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder14DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountRuleCreateInput = {
    id?: string
    description?: string | null
    discountType: $Enums.DiscountType
    discountValue: number
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    applyToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutDiscountRulesInput
  }

  export type DiscountRuleUncheckedCreateInput = {
    id?: string
    description?: string | null
    discountType: $Enums.DiscountType
    discountValue: number
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    applyToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutDiscountRulesInput
  }

  export type DiscountRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    applyToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutDiscountRulesNestedInput
  }

  export type DiscountRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    applyToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutDiscountRulesNestedInput
  }

  export type DiscountRuleCreateManyInput = {
    id?: string
    description?: string | null
    discountType: $Enums.DiscountType
    discountValue: number
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    applyToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    applyToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    applyToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateInput = {
    id?: string
    title: string
    code: string
    totalSales?: number
    services?: ServiceCreateNestedManyWithoutBranchInput
    accounts?: AccountCreateNestedManyWithoutBranchInput
    manualSales?: ManualSaleCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    Transaction?: TransactionCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateInput = {
    id?: string
    title: string
    code: string
    totalSales?: number
    services?: ServiceUncheckedCreateNestedManyWithoutBranchInput
    accounts?: AccountUncheckedCreateNestedManyWithoutBranchInput
    manualSales?: ManualSaleUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    services?: ServiceUpdateManyWithoutBranchNestedInput
    accounts?: AccountUpdateManyWithoutBranchNestedInput
    manualSales?: ManualSaleUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    Transaction?: TransactionUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    services?: ServiceUncheckedUpdateManyWithoutBranchNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutBranchNestedInput
    manualSales?: ManualSaleUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateManyInput = {
    id?: string
    title: string
    code: string
    totalSales?: number
  }

  export type BranchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
  }

  export type AttendanceCreateInput = {
    id?: string
    date: Date | string
    isPresent?: boolean
    notes?: string | null
    checkedAt?: Date | string
    account: AccountCreateNestedOneWithoutAttendancesInput
    checkedBy: AccountCreateNestedOneWithoutAttendancesCheckedInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    date: Date | string
    accountId: string
    isPresent?: boolean
    notes?: string | null
    checkedById: string
    checkedAt?: Date | string
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPresent?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutAttendancesNestedInput
    checkedBy?: AccountUpdateOneRequiredWithoutAttendancesCheckedNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    isPresent?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkedById?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyInput = {
    id?: string
    date: Date | string
    accountId: string
    isPresent?: boolean
    notes?: string | null
    checkedById: string
    checkedAt?: Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPresent?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    isPresent?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkedById?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    branch?: BranchCreateNestedOneWithoutAccountsInput
    servicesServed?: AvailedServiceCreateNestedManyWithoutServedByInput
    servicesChecked?: AvailedServiceCreateNestedManyWithoutCheckedByInput
    attendances?: AttendanceCreateNestedManyWithoutAccountInput
    attendancesChecked?: AttendanceCreateNestedManyWithoutCheckedByInput
    payslips?: PayslipCreateNestedManyWithoutAccountInput
    payslipRequests?: PayslipRequestCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestCreateNestedManyWithoutProcessedByInput
    manualSales?: ManualSaleCreateNestedManyWithoutRecordedByInput
    expenses?: ExpenseCreateNestedManyWithoutRecordedByInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    branchId?: string | null
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    servicesServed?: AvailedServiceUncheckedCreateNestedManyWithoutServedByInput
    servicesChecked?: AvailedServiceUncheckedCreateNestedManyWithoutCheckedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutAccountInput
    attendancesChecked?: AttendanceUncheckedCreateNestedManyWithoutCheckedByInput
    payslips?: PayslipUncheckedCreateNestedManyWithoutAccountInput
    payslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutProcessedByInput
    manualSales?: ManualSaleUncheckedCreateNestedManyWithoutRecordedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    branch?: BranchUpdateOneWithoutAccountsNestedInput
    servicesServed?: AvailedServiceUpdateManyWithoutServedByNestedInput
    servicesChecked?: AvailedServiceUpdateManyWithoutCheckedByNestedInput
    attendances?: AttendanceUpdateManyWithoutAccountNestedInput
    attendancesChecked?: AttendanceUpdateManyWithoutCheckedByNestedInput
    payslips?: PayslipUpdateManyWithoutAccountNestedInput
    payslipRequests?: PayslipRequestUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUpdateManyWithoutProcessedByNestedInput
    manualSales?: ManualSaleUpdateManyWithoutRecordedByNestedInput
    expenses?: ExpenseUpdateManyWithoutRecordedByNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    servicesServed?: AvailedServiceUncheckedUpdateManyWithoutServedByNestedInput
    servicesChecked?: AvailedServiceUncheckedUpdateManyWithoutCheckedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutAccountNestedInput
    attendancesChecked?: AttendanceUncheckedUpdateManyWithoutCheckedByNestedInput
    payslips?: PayslipUncheckedUpdateManyWithoutAccountNestedInput
    payslipRequests?: PayslipRequestUncheckedUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    manualSales?: ManualSaleUncheckedUpdateManyWithoutRecordedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    branchId?: string | null
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceCreateInput = {
    id?: string
    title: string
    description?: string | null
    price?: number
    totalSales?: number
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: number | null
    followUpPolicy?: $Enums.FollowUpPolicy
    branch: BranchCreateNestedOneWithoutServicesInput
    AvailedService?: AvailedServiceCreateNestedManyWithoutServiceInput
    serviceSets?: ServiceSetCreateNestedManyWithoutServicesInput
    giftCertificates?: GiftCertificateCreateNestedManyWithoutServicesInput
    discountRules?: DiscountRuleCreateNestedManyWithoutServicesInput
    recommendedAppointments?: RecommendedAppointmentCreateNestedManyWithoutOriginatingServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    price?: number
    branchId: string
    totalSales?: number
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: number | null
    followUpPolicy?: $Enums.FollowUpPolicy
    AvailedService?: AvailedServiceUncheckedCreateNestedManyWithoutServiceInput
    serviceSets?: ServiceSetUncheckedCreateNestedManyWithoutServicesInput
    giftCertificates?: GiftCertificateUncheckedCreateNestedManyWithoutServicesInput
    discountRules?: DiscountRuleUncheckedCreateNestedManyWithoutServicesInput
    recommendedAppointments?: RecommendedAppointmentUncheckedCreateNestedManyWithoutOriginatingServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
    branch?: BranchUpdateOneRequiredWithoutServicesNestedInput
    AvailedService?: AvailedServiceUpdateManyWithoutServiceNestedInput
    serviceSets?: ServiceSetUpdateManyWithoutServicesNestedInput
    giftCertificates?: GiftCertificateUpdateManyWithoutServicesNestedInput
    discountRules?: DiscountRuleUpdateManyWithoutServicesNestedInput
    recommendedAppointments?: RecommendedAppointmentUpdateManyWithoutOriginatingServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    branchId?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
    AvailedService?: AvailedServiceUncheckedUpdateManyWithoutServiceNestedInput
    serviceSets?: ServiceSetUncheckedUpdateManyWithoutServicesNestedInput
    giftCertificates?: GiftCertificateUncheckedUpdateManyWithoutServicesNestedInput
    discountRules?: DiscountRuleUncheckedUpdateManyWithoutServicesNestedInput
    recommendedAppointments?: RecommendedAppointmentUncheckedUpdateManyWithoutOriginatingServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    price?: number
    branchId: string
    totalSales?: number
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: number | null
    followUpPolicy?: $Enums.FollowUpPolicy
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    branchId?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
  }

  export type ServiceSetCreateInput = {
    id?: string
    title: string
    price: number
    services?: ServiceCreateNestedManyWithoutServiceSetsInput
    giftCertificates?: GiftCertificateCreateNestedManyWithoutServiceSetsInput
    AvailedService?: AvailedServiceCreateNestedManyWithoutOriginatingSetInput
  }

  export type ServiceSetUncheckedCreateInput = {
    id?: string
    title: string
    price: number
    services?: ServiceUncheckedCreateNestedManyWithoutServiceSetsInput
    giftCertificates?: GiftCertificateUncheckedCreateNestedManyWithoutServiceSetsInput
    AvailedService?: AvailedServiceUncheckedCreateNestedManyWithoutOriginatingSetInput
  }

  export type ServiceSetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    services?: ServiceUpdateManyWithoutServiceSetsNestedInput
    giftCertificates?: GiftCertificateUpdateManyWithoutServiceSetsNestedInput
    AvailedService?: AvailedServiceUpdateManyWithoutOriginatingSetNestedInput
  }

  export type ServiceSetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    services?: ServiceUncheckedUpdateManyWithoutServiceSetsNestedInput
    giftCertificates?: GiftCertificateUncheckedUpdateManyWithoutServiceSetsNestedInput
    AvailedService?: AvailedServiceUncheckedUpdateManyWithoutOriginatingSetNestedInput
  }

  export type ServiceSetCreateManyInput = {
    id?: string
    title: string
    price: number
  }

  export type ServiceSetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceSetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type CustomerCreateInput = {
    id?: string
    name: string
    email?: string | null
    totalPaid?: number
    nextAppointment?: Date | string | null
    recommendedAppointments?: RecommendedAppointmentCreateNestedManyWithoutCustomerInput
    transactionHistory?: TransactionCreateNestedManyWithoutCustomerInput
    purchasedGiftCertificates?: GiftCertificateCreateNestedManyWithoutPurchaserCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    name: string
    email?: string | null
    totalPaid?: number
    nextAppointment?: Date | string | null
    recommendedAppointments?: RecommendedAppointmentUncheckedCreateNestedManyWithoutCustomerInput
    transactionHistory?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    purchasedGiftCertificates?: GiftCertificateUncheckedCreateNestedManyWithoutPurchaserCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: FloatFieldUpdateOperationsInput | number
    nextAppointment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recommendedAppointments?: RecommendedAppointmentUpdateManyWithoutCustomerNestedInput
    transactionHistory?: TransactionUpdateManyWithoutCustomerNestedInput
    purchasedGiftCertificates?: GiftCertificateUpdateManyWithoutPurchaserCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: FloatFieldUpdateOperationsInput | number
    nextAppointment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recommendedAppointments?: RecommendedAppointmentUncheckedUpdateManyWithoutCustomerNestedInput
    transactionHistory?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    purchasedGiftCertificates?: GiftCertificateUncheckedUpdateManyWithoutPurchaserCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    name: string
    email?: string | null
    totalPaid?: number
    nextAppointment?: Date | string | null
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: FloatFieldUpdateOperationsInput | number
    nextAppointment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: FloatFieldUpdateOperationsInput | number
    nextAppointment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherCreateInput = {
    id?: string
    code: string
    value: number
    usedAt?: Date | string | null
    Transaction?: TransactionCreateNestedManyWithoutVoucherUsedInput
  }

  export type VoucherUncheckedCreateInput = {
    id?: string
    code: string
    value: number
    usedAt?: Date | string | null
    Transaction?: TransactionUncheckedCreateNestedManyWithoutVoucherUsedInput
  }

  export type VoucherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Transaction?: TransactionUpdateManyWithoutVoucherUsedNestedInput
  }

  export type VoucherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Transaction?: TransactionUncheckedUpdateManyWithoutVoucherUsedNestedInput
  }

  export type VoucherCreateManyInput = {
    id?: string
    code: string
    value: number
    usedAt?: Date | string | null
  }

  export type VoucherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionCreateInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    bookingReminderSentAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutTransactionHistoryInput
    availedServices?: AvailedServiceCreateNestedManyWithoutTransactionInput
    voucherUsed?: VoucherCreateNestedOneWithoutTransactionInput
    branch?: BranchCreateNestedOneWithoutTransactionInput
    giftCertificateUsed?: GiftCertificateCreateNestedOneWithoutTransactionsInput
    originatingRecommendations?: RecommendedAppointmentCreateNestedManyWithoutOriginatingTransactionInput
    attendedAppointment?: RecommendedAppointmentCreateNestedOneWithoutAttendedTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    customerId: string
    voucherId?: string | null
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    branchId?: string | null
    bookingReminderSentAt?: Date | string | null
    giftCertificateId?: string | null
    availedServices?: AvailedServiceUncheckedCreateNestedManyWithoutTransactionInput
    originatingRecommendations?: RecommendedAppointmentUncheckedCreateNestedManyWithoutOriginatingTransactionInput
    attendedAppointment?: RecommendedAppointmentUncheckedCreateNestedOneWithoutAttendedTransactionInput
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutTransactionHistoryNestedInput
    availedServices?: AvailedServiceUpdateManyWithoutTransactionNestedInput
    voucherUsed?: VoucherUpdateOneWithoutTransactionNestedInput
    branch?: BranchUpdateOneWithoutTransactionNestedInput
    giftCertificateUsed?: GiftCertificateUpdateOneWithoutTransactionsNestedInput
    originatingRecommendations?: RecommendedAppointmentUpdateManyWithoutOriginatingTransactionNestedInput
    attendedAppointment?: RecommendedAppointmentUpdateOneWithoutAttendedTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    giftCertificateId?: NullableStringFieldUpdateOperationsInput | string | null
    availedServices?: AvailedServiceUncheckedUpdateManyWithoutTransactionNestedInput
    originatingRecommendations?: RecommendedAppointmentUncheckedUpdateManyWithoutOriginatingTransactionNestedInput
    attendedAppointment?: RecommendedAppointmentUncheckedUpdateOneWithoutAttendedTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    customerId: string
    voucherId?: string | null
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    branchId?: string | null
    bookingReminderSentAt?: Date | string | null
    giftCertificateId?: string | null
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    giftCertificateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AvailedServiceCreateInput = {
    id?: string
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetTitle?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutAvailedServicesInput
    service?: ServiceCreateNestedOneWithoutAvailedServiceInput
    originatingSet?: ServiceSetCreateNestedOneWithoutAvailedServiceInput
    checkedBy?: AccountCreateNestedOneWithoutServicesCheckedInput
    servedBy?: AccountCreateNestedOneWithoutServicesServedInput
    recommendedAppointment?: RecommendedAppointmentCreateNestedOneWithoutOriginatingAvailedServiceInput
  }

  export type AvailedServiceUncheckedCreateInput = {
    id?: string
    transactionId: string
    serviceId?: string | null
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetId?: string | null
    originatingSetTitle?: string | null
    checkedById?: string | null
    servedById?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recommendedAppointment?: RecommendedAppointmentUncheckedCreateNestedOneWithoutOriginatingAvailedServiceInput
  }

  export type AvailedServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutAvailedServicesNestedInput
    service?: ServiceUpdateOneWithoutAvailedServiceNestedInput
    originatingSet?: ServiceSetUpdateOneWithoutAvailedServiceNestedInput
    checkedBy?: AccountUpdateOneWithoutServicesCheckedNestedInput
    servedBy?: AccountUpdateOneWithoutServicesServedNestedInput
    recommendedAppointment?: RecommendedAppointmentUpdateOneWithoutOriginatingAvailedServiceNestedInput
  }

  export type AvailedServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    checkedById?: NullableStringFieldUpdateOperationsInput | string | null
    servedById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recommendedAppointment?: RecommendedAppointmentUncheckedUpdateOneWithoutOriginatingAvailedServiceNestedInput
  }

  export type AvailedServiceCreateManyInput = {
    id?: string
    transactionId: string
    serviceId?: string | null
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetId?: string | null
    originatingSetTitle?: string | null
    checkedById?: string | null
    servedById?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailedServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailedServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    checkedById?: NullableStringFieldUpdateOperationsInput | string | null
    servedById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GiftCertificateCreateInput = {
    id?: string
    code: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    recipientName?: string | null
    recipientEmail?: string | null
    usedAt?: Date | string | null
    purchaserCustomer?: CustomerCreateNestedOneWithoutPurchasedGiftCertificatesInput
    services?: ServiceCreateNestedManyWithoutGiftCertificatesInput
    serviceSets?: ServiceSetCreateNestedManyWithoutGiftCertificatesInput
    transactions?: TransactionCreateNestedManyWithoutGiftCertificateUsedInput
  }

  export type GiftCertificateUncheckedCreateInput = {
    id?: string
    code: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    purchaserCustomerId?: string | null
    recipientName?: string | null
    recipientEmail?: string | null
    usedAt?: Date | string | null
    services?: ServiceUncheckedCreateNestedManyWithoutGiftCertificatesInput
    serviceSets?: ServiceSetUncheckedCreateNestedManyWithoutGiftCertificatesInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutGiftCertificateUsedInput
  }

  export type GiftCertificateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaserCustomer?: CustomerUpdateOneWithoutPurchasedGiftCertificatesNestedInput
    services?: ServiceUpdateManyWithoutGiftCertificatesNestedInput
    serviceSets?: ServiceSetUpdateManyWithoutGiftCertificatesNestedInput
    transactions?: TransactionUpdateManyWithoutGiftCertificateUsedNestedInput
  }

  export type GiftCertificateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaserCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: ServiceUncheckedUpdateManyWithoutGiftCertificatesNestedInput
    serviceSets?: ServiceSetUncheckedUpdateManyWithoutGiftCertificatesNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutGiftCertificateUsedNestedInput
  }

  export type GiftCertificateCreateManyInput = {
    id?: string
    code: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    purchaserCustomerId?: string | null
    recipientName?: string | null
    recipientEmail?: string | null
    usedAt?: Date | string | null
  }

  export type GiftCertificateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GiftCertificateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaserCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ManualSaleCreateInput = {
    id?: string
    date: Date | string
    amount: number
    paymentMethod?: $Enums.PaymentMethod | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedBy: AccountCreateNestedOneWithoutManualSalesInput
    branch?: BranchCreateNestedOneWithoutManualSalesInput
  }

  export type ManualSaleUncheckedCreateInput = {
    id?: string
    date: Date | string
    amount: number
    paymentMethod?: $Enums.PaymentMethod | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedById: string
    branchId?: string | null
  }

  export type ManualSaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: AccountUpdateOneRequiredWithoutManualSalesNestedInput
    branch?: BranchUpdateOneWithoutManualSalesNestedInput
  }

  export type ManualSaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedById?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ManualSaleCreateManyInput = {
    id?: string
    date: Date | string
    amount: number
    paymentMethod?: $Enums.PaymentMethod | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedById: string
    branchId?: string | null
  }

  export type ManualSaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualSaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedById?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseCreateInput = {
    id?: string
    date: Date | string
    amount: number
    category: $Enums.ExpenseCategory
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedBy: AccountCreateNestedOneWithoutExpensesInput
    branch?: BranchCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    date: Date | string
    amount: number
    category: $Enums.ExpenseCategory
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedById: string
    branchId?: string | null
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: AccountUpdateOneRequiredWithoutExpensesNestedInput
    branch?: BranchUpdateOneWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedById?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseCreateManyInput = {
    id?: string
    date: Date | string
    amount: number
    category: $Enums.ExpenseCategory
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedById: string
    branchId?: string | null
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedById?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailTemplateCreateInput = {
    id?: string
    name: string
    subject: string
    body: string
    placeholders?: EmailTemplateCreateplaceholdersInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUncheckedCreateInput = {
    id?: string
    name: string
    subject: string
    body: string
    placeholders?: EmailTemplateCreateplaceholdersInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    placeholders?: EmailTemplateUpdateplaceholdersInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    placeholders?: EmailTemplateUpdateplaceholdersInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateCreateManyInput = {
    id?: string
    name: string
    subject: string
    body: string
    placeholders?: EmailTemplateCreateplaceholdersInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    placeholders?: EmailTemplateUpdateplaceholdersInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    placeholders?: EmailTemplateUpdateplaceholdersInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumPayslipRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayslipRequestStatus | EnumPayslipRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayslipRequestStatus[] | ListEnumPayslipRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayslipRequestStatus[] | ListEnumPayslipRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayslipRequestStatusFilter<$PrismaModel> | $Enums.PayslipRequestStatus
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountScalarRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type AccountNullableScalarRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type PayslipNullableScalarRelationFilter = {
    is?: PayslipWhereInput | null
    isNot?: PayslipWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PayslipRequestCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    requestTimestamp?: SortOrder
    periodStartDate?: SortOrder
    periodEndDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    processedById?: SortOrder
    processedTimestamp?: SortOrder
    relatedPayslipId?: SortOrder
  }

  export type PayslipRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    requestTimestamp?: SortOrder
    periodStartDate?: SortOrder
    periodEndDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    processedById?: SortOrder
    processedTimestamp?: SortOrder
    relatedPayslipId?: SortOrder
  }

  export type PayslipRequestMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    requestTimestamp?: SortOrder
    periodStartDate?: SortOrder
    periodEndDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    processedById?: SortOrder
    processedTimestamp?: SortOrder
    relatedPayslipId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumPayslipRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayslipRequestStatus | EnumPayslipRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayslipRequestStatus[] | ListEnumPayslipRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayslipRequestStatus[] | ListEnumPayslipRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayslipRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayslipRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayslipRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumPayslipRequestStatusFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumPayslipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayslipStatus | EnumPayslipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayslipStatus[] | ListEnumPayslipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayslipStatus[] | ListEnumPayslipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayslipStatusFilter<$PrismaModel> | $Enums.PayslipStatus
  }

  export type PayslipRequestNullableScalarRelationFilter = {
    is?: PayslipRequestWhereInput | null
    isNot?: PayslipRequestWhereInput | null
  }

  export type PayslipAccountIdPeriodStartDatePeriodEndDateCompoundUniqueInput = {
    accountId: string
    periodStartDate: Date | string
    periodEndDate: Date | string
  }

  export type PayslipCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    periodStartDate?: SortOrder
    periodEndDate?: SortOrder
    baseSalary?: SortOrder
    totalCommissions?: SortOrder
    totalDeductions?: SortOrder
    totalBonuses?: SortOrder
    netPay?: SortOrder
    status?: SortOrder
    releasedDate?: SortOrder
    generatedAt?: SortOrder
  }

  export type PayslipAvgOrderByAggregateInput = {
    baseSalary?: SortOrder
    totalCommissions?: SortOrder
    totalDeductions?: SortOrder
    totalBonuses?: SortOrder
    netPay?: SortOrder
  }

  export type PayslipMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    periodStartDate?: SortOrder
    periodEndDate?: SortOrder
    baseSalary?: SortOrder
    totalCommissions?: SortOrder
    totalDeductions?: SortOrder
    totalBonuses?: SortOrder
    netPay?: SortOrder
    status?: SortOrder
    releasedDate?: SortOrder
    generatedAt?: SortOrder
  }

  export type PayslipMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    periodStartDate?: SortOrder
    periodEndDate?: SortOrder
    baseSalary?: SortOrder
    totalCommissions?: SortOrder
    totalDeductions?: SortOrder
    totalBonuses?: SortOrder
    netPay?: SortOrder
    status?: SortOrder
    releasedDate?: SortOrder
    generatedAt?: SortOrder
  }

  export type PayslipSumOrderByAggregateInput = {
    baseSalary?: SortOrder
    totalCommissions?: SortOrder
    totalDeductions?: SortOrder
    totalBonuses?: SortOrder
    netPay?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumPayslipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayslipStatus | EnumPayslipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayslipStatus[] | ListEnumPayslipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayslipStatus[] | ListEnumPayslipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayslipStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayslipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayslipStatusFilter<$PrismaModel>
    _max?: NestedEnumPayslipStatusFilter<$PrismaModel>
  }

  export type EnumRecommendedAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RecommendedAppointmentStatus | EnumRecommendedAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecommendedAppointmentStatus[] | ListEnumRecommendedAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecommendedAppointmentStatus[] | ListEnumRecommendedAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecommendedAppointmentStatusFilter<$PrismaModel> | $Enums.RecommendedAppointmentStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type TransactionNullableScalarRelationFilter = {
    is?: TransactionWhereInput | null
    isNot?: TransactionWhereInput | null
  }

  export type AvailedServiceScalarRelationFilter = {
    is?: AvailedServiceWhereInput
    isNot?: AvailedServiceWhereInput
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type RecommendedAppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    recommendedDate?: SortOrder
    originatingTransactionId?: SortOrder
    originatingAvailedServiceId?: SortOrder
    originatingServiceId?: SortOrder
    status?: SortOrder
    attendedTransactionId?: SortOrder
    suppressNextFollowUpGeneration?: SortOrder
    reminder3DaySentAt?: SortOrder
    reminder2DaySentAt?: SortOrder
    reminder1DaySentAt?: SortOrder
    reminderTodaySentAt?: SortOrder
    reminder1DayAfterSentAt?: SortOrder
    reminder7DaySentAt?: SortOrder
    reminder7DayAfterSentAt?: SortOrder
    reminder14DayAfterSentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecommendedAppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    recommendedDate?: SortOrder
    originatingTransactionId?: SortOrder
    originatingAvailedServiceId?: SortOrder
    originatingServiceId?: SortOrder
    status?: SortOrder
    attendedTransactionId?: SortOrder
    suppressNextFollowUpGeneration?: SortOrder
    reminder3DaySentAt?: SortOrder
    reminder2DaySentAt?: SortOrder
    reminder1DaySentAt?: SortOrder
    reminderTodaySentAt?: SortOrder
    reminder1DayAfterSentAt?: SortOrder
    reminder7DaySentAt?: SortOrder
    reminder7DayAfterSentAt?: SortOrder
    reminder14DayAfterSentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecommendedAppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    recommendedDate?: SortOrder
    originatingTransactionId?: SortOrder
    originatingAvailedServiceId?: SortOrder
    originatingServiceId?: SortOrder
    status?: SortOrder
    attendedTransactionId?: SortOrder
    suppressNextFollowUpGeneration?: SortOrder
    reminder3DaySentAt?: SortOrder
    reminder2DaySentAt?: SortOrder
    reminder1DaySentAt?: SortOrder
    reminderTodaySentAt?: SortOrder
    reminder1DayAfterSentAt?: SortOrder
    reminder7DaySentAt?: SortOrder
    reminder7DayAfterSentAt?: SortOrder
    reminder14DayAfterSentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRecommendedAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecommendedAppointmentStatus | EnumRecommendedAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecommendedAppointmentStatus[] | ListEnumRecommendedAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecommendedAppointmentStatus[] | ListEnumRecommendedAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecommendedAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.RecommendedAppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecommendedAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumRecommendedAppointmentStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiscountRuleCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    applyToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountRuleAvgOrderByAggregateInput = {
    discountValue?: SortOrder
  }

  export type DiscountRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    applyToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountRuleMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    applyToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountRuleSumOrderByAggregateInput = {
    discountValue?: SortOrder
  }

  export type EnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ManualSaleListRelationFilter = {
    every?: ManualSaleWhereInput
    some?: ManualSaleWhereInput
    none?: ManualSaleWhereInput
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ManualSaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    totalSales?: SortOrder
  }

  export type BranchAvgOrderByAggregateInput = {
    totalSales?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    totalSales?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    totalSales?: SortOrder
  }

  export type BranchSumOrderByAggregateInput = {
    totalSales?: SortOrder
  }

  export type AttendanceDateAccountIdCompoundUniqueInput = {
    date: Date | string
    accountId: string
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    accountId?: SortOrder
    isPresent?: SortOrder
    notes?: SortOrder
    checkedById?: SortOrder
    checkedAt?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    accountId?: SortOrder
    isPresent?: SortOrder
    notes?: SortOrder
    checkedById?: SortOrder
    checkedAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    accountId?: SortOrder
    isPresent?: SortOrder
    notes?: SortOrder
    checkedById?: SortOrder
    checkedAt?: SortOrder
  }

  export type EnumRoleNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    has?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BranchNullableScalarRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type AvailedServiceListRelationFilter = {
    every?: AvailedServiceWhereInput
    some?: AvailedServiceWhereInput
    none?: AvailedServiceWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type PayslipListRelationFilter = {
    every?: PayslipWhereInput
    some?: PayslipWhereInput
    none?: PayslipWhereInput
  }

  export type PayslipRequestListRelationFilter = {
    every?: PayslipRequestWhereInput
    some?: PayslipRequestWhereInput
    none?: PayslipRequestWhereInput
  }

  export type AvailedServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayslipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayslipRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    salary?: SortOrder
    dailyRate?: SortOrder
    branchId?: SortOrder
    canRequestPayslip?: SortOrder
    mustChangePassword?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    salary?: SortOrder
    dailyRate?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrder
    salary?: SortOrder
    dailyRate?: SortOrder
    branchId?: SortOrder
    canRequestPayslip?: SortOrder
    mustChangePassword?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrder
    salary?: SortOrder
    dailyRate?: SortOrder
    branchId?: SortOrder
    canRequestPayslip?: SortOrder
    mustChangePassword?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    salary?: SortOrder
    dailyRate?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumFollowUpPolicyFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowUpPolicy | EnumFollowUpPolicyFieldRefInput<$PrismaModel>
    in?: $Enums.FollowUpPolicy[] | ListEnumFollowUpPolicyFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowUpPolicy[] | ListEnumFollowUpPolicyFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowUpPolicyFilter<$PrismaModel> | $Enums.FollowUpPolicy
  }

  export type BranchScalarRelationFilter = {
    is?: BranchWhereInput
    isNot?: BranchWhereInput
  }

  export type ServiceSetListRelationFilter = {
    every?: ServiceSetWhereInput
    some?: ServiceSetWhereInput
    none?: ServiceSetWhereInput
  }

  export type GiftCertificateListRelationFilter = {
    every?: GiftCertificateWhereInput
    some?: GiftCertificateWhereInput
    none?: GiftCertificateWhereInput
  }

  export type DiscountRuleListRelationFilter = {
    every?: DiscountRuleWhereInput
    some?: DiscountRuleWhereInput
    none?: DiscountRuleWhereInput
  }

  export type RecommendedAppointmentListRelationFilter = {
    every?: RecommendedAppointmentWhereInput
    some?: RecommendedAppointmentWhereInput
    none?: RecommendedAppointmentWhereInput
  }

  export type ServiceSetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GiftCertificateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiscountRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecommendedAppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    branchId?: SortOrder
    totalSales?: SortOrder
    recommendFollowUp?: SortOrder
    recommendedFollowUpDays?: SortOrder
    followUpPolicy?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    price?: SortOrder
    totalSales?: SortOrder
    recommendedFollowUpDays?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    branchId?: SortOrder
    totalSales?: SortOrder
    recommendFollowUp?: SortOrder
    recommendedFollowUpDays?: SortOrder
    followUpPolicy?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    branchId?: SortOrder
    totalSales?: SortOrder
    recommendFollowUp?: SortOrder
    recommendedFollowUpDays?: SortOrder
    followUpPolicy?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    price?: SortOrder
    totalSales?: SortOrder
    recommendedFollowUpDays?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumFollowUpPolicyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowUpPolicy | EnumFollowUpPolicyFieldRefInput<$PrismaModel>
    in?: $Enums.FollowUpPolicy[] | ListEnumFollowUpPolicyFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowUpPolicy[] | ListEnumFollowUpPolicyFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowUpPolicyWithAggregatesFilter<$PrismaModel> | $Enums.FollowUpPolicy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFollowUpPolicyFilter<$PrismaModel>
    _max?: NestedEnumFollowUpPolicyFilter<$PrismaModel>
  }

  export type ServiceSetCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    price?: SortOrder
  }

  export type ServiceSetAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ServiceSetMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    price?: SortOrder
  }

  export type ServiceSetMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    price?: SortOrder
  }

  export type ServiceSetSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    totalPaid?: SortOrder
    nextAppointment?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    totalPaid?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    totalPaid?: SortOrder
    nextAppointment?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    totalPaid?: SortOrder
    nextAppointment?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    totalPaid?: SortOrder
  }

  export type VoucherCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    value?: SortOrder
    usedAt?: SortOrder
  }

  export type VoucherAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type VoucherMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    value?: SortOrder
    usedAt?: SortOrder
  }

  export type VoucherMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    value?: SortOrder
    usedAt?: SortOrder
  }

  export type VoucherSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type VoucherNullableScalarRelationFilter = {
    is?: VoucherWhereInput | null
    isNot?: VoucherWhereInput | null
  }

  export type GiftCertificateNullableScalarRelationFilter = {
    is?: GiftCertificateWhereInput | null
    isNot?: GiftCertificateWhereInput | null
  }

  export type RecommendedAppointmentNullableScalarRelationFilter = {
    is?: RecommendedAppointmentWhereInput | null
    isNot?: RecommendedAppointmentWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    bookedFor?: SortOrder
    customerId?: SortOrder
    voucherId?: SortOrder
    discount?: SortOrder
    paymentMethod?: SortOrder
    grandTotal?: SortOrder
    status?: SortOrder
    branchId?: SortOrder
    bookingReminderSentAt?: SortOrder
    giftCertificateId?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    discount?: SortOrder
    grandTotal?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    bookedFor?: SortOrder
    customerId?: SortOrder
    voucherId?: SortOrder
    discount?: SortOrder
    paymentMethod?: SortOrder
    grandTotal?: SortOrder
    status?: SortOrder
    branchId?: SortOrder
    bookingReminderSentAt?: SortOrder
    giftCertificateId?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    bookedFor?: SortOrder
    customerId?: SortOrder
    voucherId?: SortOrder
    discount?: SortOrder
    paymentMethod?: SortOrder
    grandTotal?: SortOrder
    status?: SortOrder
    branchId?: SortOrder
    bookingReminderSentAt?: SortOrder
    giftCertificateId?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    discount?: SortOrder
    grandTotal?: SortOrder
  }

  export type EnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type TransactionScalarRelationFilter = {
    is?: TransactionWhereInput
    isNot?: TransactionWhereInput
  }

  export type ServiceNullableScalarRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type ServiceSetNullableScalarRelationFilter = {
    is?: ServiceSetWhereInput | null
    isNot?: ServiceSetWhereInput | null
  }

  export type AvailedServiceCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    commissionValue?: SortOrder
    originatingSetId?: SortOrder
    originatingSetTitle?: SortOrder
    checkedById?: SortOrder
    servedById?: SortOrder
    serviceSetId?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvailedServiceAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    commissionValue?: SortOrder
  }

  export type AvailedServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    commissionValue?: SortOrder
    originatingSetId?: SortOrder
    originatingSetTitle?: SortOrder
    checkedById?: SortOrder
    servedById?: SortOrder
    serviceSetId?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvailedServiceMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    commissionValue?: SortOrder
    originatingSetId?: SortOrder
    originatingSetTitle?: SortOrder
    checkedById?: SortOrder
    servedById?: SortOrder
    serviceSetId?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvailedServiceSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    commissionValue?: SortOrder
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type GiftCertificateCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    purchaserCustomerId?: SortOrder
    recipientName?: SortOrder
    recipientEmail?: SortOrder
    usedAt?: SortOrder
  }

  export type GiftCertificateMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    purchaserCustomerId?: SortOrder
    recipientName?: SortOrder
    recipientEmail?: SortOrder
    usedAt?: SortOrder
  }

  export type GiftCertificateMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    purchaserCustomerId?: SortOrder
    recipientName?: SortOrder
    recipientEmail?: SortOrder
    usedAt?: SortOrder
  }

  export type ManualSaleCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recordedById?: SortOrder
    branchId?: SortOrder
  }

  export type ManualSaleAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ManualSaleMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recordedById?: SortOrder
    branchId?: SortOrder
  }

  export type ManualSaleMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recordedById?: SortOrder
    branchId?: SortOrder
  }

  export type ManualSaleSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumExpenseCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseCategoryFilter<$PrismaModel> | $Enums.ExpenseCategory
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recordedById?: SortOrder
    branchId?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recordedById?: SortOrder
    branchId?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recordedById?: SortOrder
    branchId?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumExpenseCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseCategoryFilter<$PrismaModel>
    _max?: NestedEnumExpenseCategoryFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EmailTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    placeholders?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountCreateNestedOneWithoutPayslipRequestsInput = {
    create?: XOR<AccountCreateWithoutPayslipRequestsInput, AccountUncheckedCreateWithoutPayslipRequestsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPayslipRequestsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutManagedPayslipRequestsInput = {
    create?: XOR<AccountCreateWithoutManagedPayslipRequestsInput, AccountUncheckedCreateWithoutManagedPayslipRequestsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutManagedPayslipRequestsInput
    connect?: AccountWhereUniqueInput
  }

  export type PayslipCreateNestedOneWithoutPayslipRequestInput = {
    create?: XOR<PayslipCreateWithoutPayslipRequestInput, PayslipUncheckedCreateWithoutPayslipRequestInput>
    connectOrCreate?: PayslipCreateOrConnectWithoutPayslipRequestInput
    connect?: PayslipWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumPayslipRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.PayslipRequestStatus
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountUpdateOneRequiredWithoutPayslipRequestsNestedInput = {
    create?: XOR<AccountCreateWithoutPayslipRequestsInput, AccountUncheckedCreateWithoutPayslipRequestsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPayslipRequestsInput
    upsert?: AccountUpsertWithoutPayslipRequestsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutPayslipRequestsInput, AccountUpdateWithoutPayslipRequestsInput>, AccountUncheckedUpdateWithoutPayslipRequestsInput>
  }

  export type AccountUpdateOneWithoutManagedPayslipRequestsNestedInput = {
    create?: XOR<AccountCreateWithoutManagedPayslipRequestsInput, AccountUncheckedCreateWithoutManagedPayslipRequestsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutManagedPayslipRequestsInput
    upsert?: AccountUpsertWithoutManagedPayslipRequestsInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutManagedPayslipRequestsInput, AccountUpdateWithoutManagedPayslipRequestsInput>, AccountUncheckedUpdateWithoutManagedPayslipRequestsInput>
  }

  export type PayslipUpdateOneWithoutPayslipRequestNestedInput = {
    create?: XOR<PayslipCreateWithoutPayslipRequestInput, PayslipUncheckedCreateWithoutPayslipRequestInput>
    connectOrCreate?: PayslipCreateOrConnectWithoutPayslipRequestInput
    upsert?: PayslipUpsertWithoutPayslipRequestInput
    disconnect?: PayslipWhereInput | boolean
    delete?: PayslipWhereInput | boolean
    connect?: PayslipWhereUniqueInput
    update?: XOR<XOR<PayslipUpdateToOneWithWhereWithoutPayslipRequestInput, PayslipUpdateWithoutPayslipRequestInput>, PayslipUncheckedUpdateWithoutPayslipRequestInput>
  }

  export type AccountCreateNestedOneWithoutPayslipsInput = {
    create?: XOR<AccountCreateWithoutPayslipsInput, AccountUncheckedCreateWithoutPayslipsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPayslipsInput
    connect?: AccountWhereUniqueInput
  }

  export type PayslipRequestCreateNestedOneWithoutRelatedPayslipInput = {
    create?: XOR<PayslipRequestCreateWithoutRelatedPayslipInput, PayslipRequestUncheckedCreateWithoutRelatedPayslipInput>
    connectOrCreate?: PayslipRequestCreateOrConnectWithoutRelatedPayslipInput
    connect?: PayslipRequestWhereUniqueInput
  }

  export type PayslipRequestUncheckedCreateNestedOneWithoutRelatedPayslipInput = {
    create?: XOR<PayslipRequestCreateWithoutRelatedPayslipInput, PayslipRequestUncheckedCreateWithoutRelatedPayslipInput>
    connectOrCreate?: PayslipRequestCreateOrConnectWithoutRelatedPayslipInput
    connect?: PayslipRequestWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPayslipStatusFieldUpdateOperationsInput = {
    set?: $Enums.PayslipStatus
  }

  export type AccountUpdateOneRequiredWithoutPayslipsNestedInput = {
    create?: XOR<AccountCreateWithoutPayslipsInput, AccountUncheckedCreateWithoutPayslipsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPayslipsInput
    upsert?: AccountUpsertWithoutPayslipsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutPayslipsInput, AccountUpdateWithoutPayslipsInput>, AccountUncheckedUpdateWithoutPayslipsInput>
  }

  export type PayslipRequestUpdateOneWithoutRelatedPayslipNestedInput = {
    create?: XOR<PayslipRequestCreateWithoutRelatedPayslipInput, PayslipRequestUncheckedCreateWithoutRelatedPayslipInput>
    connectOrCreate?: PayslipRequestCreateOrConnectWithoutRelatedPayslipInput
    upsert?: PayslipRequestUpsertWithoutRelatedPayslipInput
    disconnect?: PayslipRequestWhereInput | boolean
    delete?: PayslipRequestWhereInput | boolean
    connect?: PayslipRequestWhereUniqueInput
    update?: XOR<XOR<PayslipRequestUpdateToOneWithWhereWithoutRelatedPayslipInput, PayslipRequestUpdateWithoutRelatedPayslipInput>, PayslipRequestUncheckedUpdateWithoutRelatedPayslipInput>
  }

  export type PayslipRequestUncheckedUpdateOneWithoutRelatedPayslipNestedInput = {
    create?: XOR<PayslipRequestCreateWithoutRelatedPayslipInput, PayslipRequestUncheckedCreateWithoutRelatedPayslipInput>
    connectOrCreate?: PayslipRequestCreateOrConnectWithoutRelatedPayslipInput
    upsert?: PayslipRequestUpsertWithoutRelatedPayslipInput
    disconnect?: PayslipRequestWhereInput | boolean
    delete?: PayslipRequestWhereInput | boolean
    connect?: PayslipRequestWhereUniqueInput
    update?: XOR<XOR<PayslipRequestUpdateToOneWithWhereWithoutRelatedPayslipInput, PayslipRequestUpdateWithoutRelatedPayslipInput>, PayslipRequestUncheckedUpdateWithoutRelatedPayslipInput>
  }

  export type CustomerCreateNestedOneWithoutRecommendedAppointmentsInput = {
    create?: XOR<CustomerCreateWithoutRecommendedAppointmentsInput, CustomerUncheckedCreateWithoutRecommendedAppointmentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutRecommendedAppointmentsInput
    connect?: CustomerWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutOriginatingRecommendationsInput = {
    create?: XOR<TransactionCreateWithoutOriginatingRecommendationsInput, TransactionUncheckedCreateWithoutOriginatingRecommendationsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutOriginatingRecommendationsInput
    connect?: TransactionWhereUniqueInput
  }

  export type AvailedServiceCreateNestedOneWithoutRecommendedAppointmentInput = {
    create?: XOR<AvailedServiceCreateWithoutRecommendedAppointmentInput, AvailedServiceUncheckedCreateWithoutRecommendedAppointmentInput>
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutRecommendedAppointmentInput
    connect?: AvailedServiceWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutRecommendedAppointmentsInput = {
    create?: XOR<ServiceCreateWithoutRecommendedAppointmentsInput, ServiceUncheckedCreateWithoutRecommendedAppointmentsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutRecommendedAppointmentsInput
    connect?: ServiceWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutAttendedAppointmentInput = {
    create?: XOR<TransactionCreateWithoutAttendedAppointmentInput, TransactionUncheckedCreateWithoutAttendedAppointmentInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutAttendedAppointmentInput
    connect?: TransactionWhereUniqueInput
  }

  export type EnumRecommendedAppointmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.RecommendedAppointmentStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CustomerUpdateOneRequiredWithoutRecommendedAppointmentsNestedInput = {
    create?: XOR<CustomerCreateWithoutRecommendedAppointmentsInput, CustomerUncheckedCreateWithoutRecommendedAppointmentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutRecommendedAppointmentsInput
    upsert?: CustomerUpsertWithoutRecommendedAppointmentsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutRecommendedAppointmentsInput, CustomerUpdateWithoutRecommendedAppointmentsInput>, CustomerUncheckedUpdateWithoutRecommendedAppointmentsInput>
  }

  export type TransactionUpdateOneWithoutOriginatingRecommendationsNestedInput = {
    create?: XOR<TransactionCreateWithoutOriginatingRecommendationsInput, TransactionUncheckedCreateWithoutOriginatingRecommendationsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutOriginatingRecommendationsInput
    upsert?: TransactionUpsertWithoutOriginatingRecommendationsInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutOriginatingRecommendationsInput, TransactionUpdateWithoutOriginatingRecommendationsInput>, TransactionUncheckedUpdateWithoutOriginatingRecommendationsInput>
  }

  export type AvailedServiceUpdateOneRequiredWithoutRecommendedAppointmentNestedInput = {
    create?: XOR<AvailedServiceCreateWithoutRecommendedAppointmentInput, AvailedServiceUncheckedCreateWithoutRecommendedAppointmentInput>
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutRecommendedAppointmentInput
    upsert?: AvailedServiceUpsertWithoutRecommendedAppointmentInput
    connect?: AvailedServiceWhereUniqueInput
    update?: XOR<XOR<AvailedServiceUpdateToOneWithWhereWithoutRecommendedAppointmentInput, AvailedServiceUpdateWithoutRecommendedAppointmentInput>, AvailedServiceUncheckedUpdateWithoutRecommendedAppointmentInput>
  }

  export type ServiceUpdateOneRequiredWithoutRecommendedAppointmentsNestedInput = {
    create?: XOR<ServiceCreateWithoutRecommendedAppointmentsInput, ServiceUncheckedCreateWithoutRecommendedAppointmentsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutRecommendedAppointmentsInput
    upsert?: ServiceUpsertWithoutRecommendedAppointmentsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutRecommendedAppointmentsInput, ServiceUpdateWithoutRecommendedAppointmentsInput>, ServiceUncheckedUpdateWithoutRecommendedAppointmentsInput>
  }

  export type TransactionUpdateOneWithoutAttendedAppointmentNestedInput = {
    create?: XOR<TransactionCreateWithoutAttendedAppointmentInput, TransactionUncheckedCreateWithoutAttendedAppointmentInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutAttendedAppointmentInput
    upsert?: TransactionUpsertWithoutAttendedAppointmentInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutAttendedAppointmentInput, TransactionUpdateWithoutAttendedAppointmentInput>, TransactionUncheckedUpdateWithoutAttendedAppointmentInput>
  }

  export type ServiceCreateNestedManyWithoutDiscountRulesInput = {
    create?: XOR<ServiceCreateWithoutDiscountRulesInput, ServiceUncheckedCreateWithoutDiscountRulesInput> | ServiceCreateWithoutDiscountRulesInput[] | ServiceUncheckedCreateWithoutDiscountRulesInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDiscountRulesInput | ServiceCreateOrConnectWithoutDiscountRulesInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutDiscountRulesInput = {
    create?: XOR<ServiceCreateWithoutDiscountRulesInput, ServiceUncheckedCreateWithoutDiscountRulesInput> | ServiceCreateWithoutDiscountRulesInput[] | ServiceUncheckedCreateWithoutDiscountRulesInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDiscountRulesInput | ServiceCreateOrConnectWithoutDiscountRulesInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type EnumDiscountTypeFieldUpdateOperationsInput = {
    set?: $Enums.DiscountType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ServiceUpdateManyWithoutDiscountRulesNestedInput = {
    create?: XOR<ServiceCreateWithoutDiscountRulesInput, ServiceUncheckedCreateWithoutDiscountRulesInput> | ServiceCreateWithoutDiscountRulesInput[] | ServiceUncheckedCreateWithoutDiscountRulesInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDiscountRulesInput | ServiceCreateOrConnectWithoutDiscountRulesInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutDiscountRulesInput | ServiceUpsertWithWhereUniqueWithoutDiscountRulesInput[]
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutDiscountRulesInput | ServiceUpdateWithWhereUniqueWithoutDiscountRulesInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutDiscountRulesInput | ServiceUpdateManyWithWhereWithoutDiscountRulesInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutDiscountRulesNestedInput = {
    create?: XOR<ServiceCreateWithoutDiscountRulesInput, ServiceUncheckedCreateWithoutDiscountRulesInput> | ServiceCreateWithoutDiscountRulesInput[] | ServiceUncheckedCreateWithoutDiscountRulesInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDiscountRulesInput | ServiceCreateOrConnectWithoutDiscountRulesInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutDiscountRulesInput | ServiceUpsertWithWhereUniqueWithoutDiscountRulesInput[]
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutDiscountRulesInput | ServiceUpdateWithWhereUniqueWithoutDiscountRulesInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutDiscountRulesInput | ServiceUpdateManyWithWhereWithoutDiscountRulesInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceCreateNestedManyWithoutBranchInput = {
    create?: XOR<ServiceCreateWithoutBranchInput, ServiceUncheckedCreateWithoutBranchInput> | ServiceCreateWithoutBranchInput[] | ServiceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutBranchInput | ServiceCreateOrConnectWithoutBranchInput[]
    createMany?: ServiceCreateManyBranchInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutBranchInput = {
    create?: XOR<AccountCreateWithoutBranchInput, AccountUncheckedCreateWithoutBranchInput> | AccountCreateWithoutBranchInput[] | AccountUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutBranchInput | AccountCreateOrConnectWithoutBranchInput[]
    createMany?: AccountCreateManyBranchInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ManualSaleCreateNestedManyWithoutBranchInput = {
    create?: XOR<ManualSaleCreateWithoutBranchInput, ManualSaleUncheckedCreateWithoutBranchInput> | ManualSaleCreateWithoutBranchInput[] | ManualSaleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ManualSaleCreateOrConnectWithoutBranchInput | ManualSaleCreateOrConnectWithoutBranchInput[]
    createMany?: ManualSaleCreateManyBranchInputEnvelope
    connect?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutBranchInput = {
    create?: XOR<ExpenseCreateWithoutBranchInput, ExpenseUncheckedCreateWithoutBranchInput> | ExpenseCreateWithoutBranchInput[] | ExpenseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutBranchInput | ExpenseCreateOrConnectWithoutBranchInput[]
    createMany?: ExpenseCreateManyBranchInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutBranchInput = {
    create?: XOR<TransactionCreateWithoutBranchInput, TransactionUncheckedCreateWithoutBranchInput> | TransactionCreateWithoutBranchInput[] | TransactionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBranchInput | TransactionCreateOrConnectWithoutBranchInput[]
    createMany?: TransactionCreateManyBranchInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ServiceCreateWithoutBranchInput, ServiceUncheckedCreateWithoutBranchInput> | ServiceCreateWithoutBranchInput[] | ServiceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutBranchInput | ServiceCreateOrConnectWithoutBranchInput[]
    createMany?: ServiceCreateManyBranchInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<AccountCreateWithoutBranchInput, AccountUncheckedCreateWithoutBranchInput> | AccountCreateWithoutBranchInput[] | AccountUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutBranchInput | AccountCreateOrConnectWithoutBranchInput[]
    createMany?: AccountCreateManyBranchInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ManualSaleUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ManualSaleCreateWithoutBranchInput, ManualSaleUncheckedCreateWithoutBranchInput> | ManualSaleCreateWithoutBranchInput[] | ManualSaleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ManualSaleCreateOrConnectWithoutBranchInput | ManualSaleCreateOrConnectWithoutBranchInput[]
    createMany?: ManualSaleCreateManyBranchInputEnvelope
    connect?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ExpenseCreateWithoutBranchInput, ExpenseUncheckedCreateWithoutBranchInput> | ExpenseCreateWithoutBranchInput[] | ExpenseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutBranchInput | ExpenseCreateOrConnectWithoutBranchInput[]
    createMany?: ExpenseCreateManyBranchInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<TransactionCreateWithoutBranchInput, TransactionUncheckedCreateWithoutBranchInput> | TransactionCreateWithoutBranchInput[] | TransactionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBranchInput | TransactionCreateOrConnectWithoutBranchInput[]
    createMany?: TransactionCreateManyBranchInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ServiceUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ServiceCreateWithoutBranchInput, ServiceUncheckedCreateWithoutBranchInput> | ServiceCreateWithoutBranchInput[] | ServiceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutBranchInput | ServiceCreateOrConnectWithoutBranchInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutBranchInput | ServiceUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ServiceCreateManyBranchInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutBranchInput | ServiceUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutBranchInput | ServiceUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AccountCreateWithoutBranchInput, AccountUncheckedCreateWithoutBranchInput> | AccountCreateWithoutBranchInput[] | AccountUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutBranchInput | AccountCreateOrConnectWithoutBranchInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutBranchInput | AccountUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AccountCreateManyBranchInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutBranchInput | AccountUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutBranchInput | AccountUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ManualSaleUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ManualSaleCreateWithoutBranchInput, ManualSaleUncheckedCreateWithoutBranchInput> | ManualSaleCreateWithoutBranchInput[] | ManualSaleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ManualSaleCreateOrConnectWithoutBranchInput | ManualSaleCreateOrConnectWithoutBranchInput[]
    upsert?: ManualSaleUpsertWithWhereUniqueWithoutBranchInput | ManualSaleUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ManualSaleCreateManyBranchInputEnvelope
    set?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
    disconnect?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
    delete?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
    connect?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
    update?: ManualSaleUpdateWithWhereUniqueWithoutBranchInput | ManualSaleUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ManualSaleUpdateManyWithWhereWithoutBranchInput | ManualSaleUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ManualSaleScalarWhereInput | ManualSaleScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ExpenseCreateWithoutBranchInput, ExpenseUncheckedCreateWithoutBranchInput> | ExpenseCreateWithoutBranchInput[] | ExpenseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutBranchInput | ExpenseCreateOrConnectWithoutBranchInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutBranchInput | ExpenseUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ExpenseCreateManyBranchInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutBranchInput | ExpenseUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutBranchInput | ExpenseUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TransactionCreateWithoutBranchInput, TransactionUncheckedCreateWithoutBranchInput> | TransactionCreateWithoutBranchInput[] | TransactionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBranchInput | TransactionCreateOrConnectWithoutBranchInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutBranchInput | TransactionUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TransactionCreateManyBranchInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutBranchInput | TransactionUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutBranchInput | TransactionUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ServiceCreateWithoutBranchInput, ServiceUncheckedCreateWithoutBranchInput> | ServiceCreateWithoutBranchInput[] | ServiceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutBranchInput | ServiceCreateOrConnectWithoutBranchInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutBranchInput | ServiceUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ServiceCreateManyBranchInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutBranchInput | ServiceUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutBranchInput | ServiceUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AccountCreateWithoutBranchInput, AccountUncheckedCreateWithoutBranchInput> | AccountCreateWithoutBranchInput[] | AccountUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutBranchInput | AccountCreateOrConnectWithoutBranchInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutBranchInput | AccountUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AccountCreateManyBranchInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutBranchInput | AccountUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutBranchInput | AccountUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ManualSaleUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ManualSaleCreateWithoutBranchInput, ManualSaleUncheckedCreateWithoutBranchInput> | ManualSaleCreateWithoutBranchInput[] | ManualSaleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ManualSaleCreateOrConnectWithoutBranchInput | ManualSaleCreateOrConnectWithoutBranchInput[]
    upsert?: ManualSaleUpsertWithWhereUniqueWithoutBranchInput | ManualSaleUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ManualSaleCreateManyBranchInputEnvelope
    set?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
    disconnect?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
    delete?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
    connect?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
    update?: ManualSaleUpdateWithWhereUniqueWithoutBranchInput | ManualSaleUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ManualSaleUpdateManyWithWhereWithoutBranchInput | ManualSaleUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ManualSaleScalarWhereInput | ManualSaleScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ExpenseCreateWithoutBranchInput, ExpenseUncheckedCreateWithoutBranchInput> | ExpenseCreateWithoutBranchInput[] | ExpenseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutBranchInput | ExpenseCreateOrConnectWithoutBranchInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutBranchInput | ExpenseUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ExpenseCreateManyBranchInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutBranchInput | ExpenseUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutBranchInput | ExpenseUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TransactionCreateWithoutBranchInput, TransactionUncheckedCreateWithoutBranchInput> | TransactionCreateWithoutBranchInput[] | TransactionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBranchInput | TransactionCreateOrConnectWithoutBranchInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutBranchInput | TransactionUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TransactionCreateManyBranchInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutBranchInput | TransactionUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutBranchInput | TransactionUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<AccountCreateWithoutAttendancesInput, AccountUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAttendancesInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutAttendancesCheckedInput = {
    create?: XOR<AccountCreateWithoutAttendancesCheckedInput, AccountUncheckedCreateWithoutAttendancesCheckedInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAttendancesCheckedInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<AccountCreateWithoutAttendancesInput, AccountUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAttendancesInput
    upsert?: AccountUpsertWithoutAttendancesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutAttendancesInput, AccountUpdateWithoutAttendancesInput>, AccountUncheckedUpdateWithoutAttendancesInput>
  }

  export type AccountUpdateOneRequiredWithoutAttendancesCheckedNestedInput = {
    create?: XOR<AccountCreateWithoutAttendancesCheckedInput, AccountUncheckedCreateWithoutAttendancesCheckedInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAttendancesCheckedInput
    upsert?: AccountUpsertWithoutAttendancesCheckedInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutAttendancesCheckedInput, AccountUpdateWithoutAttendancesCheckedInput>, AccountUncheckedUpdateWithoutAttendancesCheckedInput>
  }

  export type AccountCreateroleInput = {
    set: $Enums.Role[]
  }

  export type BranchCreateNestedOneWithoutAccountsInput = {
    create?: XOR<BranchCreateWithoutAccountsInput, BranchUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAccountsInput
    connect?: BranchWhereUniqueInput
  }

  export type AvailedServiceCreateNestedManyWithoutServedByInput = {
    create?: XOR<AvailedServiceCreateWithoutServedByInput, AvailedServiceUncheckedCreateWithoutServedByInput> | AvailedServiceCreateWithoutServedByInput[] | AvailedServiceUncheckedCreateWithoutServedByInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutServedByInput | AvailedServiceCreateOrConnectWithoutServedByInput[]
    createMany?: AvailedServiceCreateManyServedByInputEnvelope
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
  }

  export type AvailedServiceCreateNestedManyWithoutCheckedByInput = {
    create?: XOR<AvailedServiceCreateWithoutCheckedByInput, AvailedServiceUncheckedCreateWithoutCheckedByInput> | AvailedServiceCreateWithoutCheckedByInput[] | AvailedServiceUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutCheckedByInput | AvailedServiceCreateOrConnectWithoutCheckedByInput[]
    createMany?: AvailedServiceCreateManyCheckedByInputEnvelope
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutAccountInput = {
    create?: XOR<AttendanceCreateWithoutAccountInput, AttendanceUncheckedCreateWithoutAccountInput> | AttendanceCreateWithoutAccountInput[] | AttendanceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutAccountInput | AttendanceCreateOrConnectWithoutAccountInput[]
    createMany?: AttendanceCreateManyAccountInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutCheckedByInput = {
    create?: XOR<AttendanceCreateWithoutCheckedByInput, AttendanceUncheckedCreateWithoutCheckedByInput> | AttendanceCreateWithoutCheckedByInput[] | AttendanceUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutCheckedByInput | AttendanceCreateOrConnectWithoutCheckedByInput[]
    createMany?: AttendanceCreateManyCheckedByInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type PayslipCreateNestedManyWithoutAccountInput = {
    create?: XOR<PayslipCreateWithoutAccountInput, PayslipUncheckedCreateWithoutAccountInput> | PayslipCreateWithoutAccountInput[] | PayslipUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PayslipCreateOrConnectWithoutAccountInput | PayslipCreateOrConnectWithoutAccountInput[]
    createMany?: PayslipCreateManyAccountInputEnvelope
    connect?: PayslipWhereUniqueInput | PayslipWhereUniqueInput[]
  }

  export type PayslipRequestCreateNestedManyWithoutAccountInput = {
    create?: XOR<PayslipRequestCreateWithoutAccountInput, PayslipRequestUncheckedCreateWithoutAccountInput> | PayslipRequestCreateWithoutAccountInput[] | PayslipRequestUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PayslipRequestCreateOrConnectWithoutAccountInput | PayslipRequestCreateOrConnectWithoutAccountInput[]
    createMany?: PayslipRequestCreateManyAccountInputEnvelope
    connect?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
  }

  export type PayslipRequestCreateNestedManyWithoutProcessedByInput = {
    create?: XOR<PayslipRequestCreateWithoutProcessedByInput, PayslipRequestUncheckedCreateWithoutProcessedByInput> | PayslipRequestCreateWithoutProcessedByInput[] | PayslipRequestUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: PayslipRequestCreateOrConnectWithoutProcessedByInput | PayslipRequestCreateOrConnectWithoutProcessedByInput[]
    createMany?: PayslipRequestCreateManyProcessedByInputEnvelope
    connect?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
  }

  export type ManualSaleCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<ManualSaleCreateWithoutRecordedByInput, ManualSaleUncheckedCreateWithoutRecordedByInput> | ManualSaleCreateWithoutRecordedByInput[] | ManualSaleUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: ManualSaleCreateOrConnectWithoutRecordedByInput | ManualSaleCreateOrConnectWithoutRecordedByInput[]
    createMany?: ManualSaleCreateManyRecordedByInputEnvelope
    connect?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<ExpenseCreateWithoutRecordedByInput, ExpenseUncheckedCreateWithoutRecordedByInput> | ExpenseCreateWithoutRecordedByInput[] | ExpenseUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutRecordedByInput | ExpenseCreateOrConnectWithoutRecordedByInput[]
    createMany?: ExpenseCreateManyRecordedByInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type AvailedServiceUncheckedCreateNestedManyWithoutServedByInput = {
    create?: XOR<AvailedServiceCreateWithoutServedByInput, AvailedServiceUncheckedCreateWithoutServedByInput> | AvailedServiceCreateWithoutServedByInput[] | AvailedServiceUncheckedCreateWithoutServedByInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutServedByInput | AvailedServiceCreateOrConnectWithoutServedByInput[]
    createMany?: AvailedServiceCreateManyServedByInputEnvelope
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
  }

  export type AvailedServiceUncheckedCreateNestedManyWithoutCheckedByInput = {
    create?: XOR<AvailedServiceCreateWithoutCheckedByInput, AvailedServiceUncheckedCreateWithoutCheckedByInput> | AvailedServiceCreateWithoutCheckedByInput[] | AvailedServiceUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutCheckedByInput | AvailedServiceCreateOrConnectWithoutCheckedByInput[]
    createMany?: AvailedServiceCreateManyCheckedByInputEnvelope
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<AttendanceCreateWithoutAccountInput, AttendanceUncheckedCreateWithoutAccountInput> | AttendanceCreateWithoutAccountInput[] | AttendanceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutAccountInput | AttendanceCreateOrConnectWithoutAccountInput[]
    createMany?: AttendanceCreateManyAccountInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutCheckedByInput = {
    create?: XOR<AttendanceCreateWithoutCheckedByInput, AttendanceUncheckedCreateWithoutCheckedByInput> | AttendanceCreateWithoutCheckedByInput[] | AttendanceUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutCheckedByInput | AttendanceCreateOrConnectWithoutCheckedByInput[]
    createMany?: AttendanceCreateManyCheckedByInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type PayslipUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<PayslipCreateWithoutAccountInput, PayslipUncheckedCreateWithoutAccountInput> | PayslipCreateWithoutAccountInput[] | PayslipUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PayslipCreateOrConnectWithoutAccountInput | PayslipCreateOrConnectWithoutAccountInput[]
    createMany?: PayslipCreateManyAccountInputEnvelope
    connect?: PayslipWhereUniqueInput | PayslipWhereUniqueInput[]
  }

  export type PayslipRequestUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<PayslipRequestCreateWithoutAccountInput, PayslipRequestUncheckedCreateWithoutAccountInput> | PayslipRequestCreateWithoutAccountInput[] | PayslipRequestUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PayslipRequestCreateOrConnectWithoutAccountInput | PayslipRequestCreateOrConnectWithoutAccountInput[]
    createMany?: PayslipRequestCreateManyAccountInputEnvelope
    connect?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
  }

  export type PayslipRequestUncheckedCreateNestedManyWithoutProcessedByInput = {
    create?: XOR<PayslipRequestCreateWithoutProcessedByInput, PayslipRequestUncheckedCreateWithoutProcessedByInput> | PayslipRequestCreateWithoutProcessedByInput[] | PayslipRequestUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: PayslipRequestCreateOrConnectWithoutProcessedByInput | PayslipRequestCreateOrConnectWithoutProcessedByInput[]
    createMany?: PayslipRequestCreateManyProcessedByInputEnvelope
    connect?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
  }

  export type ManualSaleUncheckedCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<ManualSaleCreateWithoutRecordedByInput, ManualSaleUncheckedCreateWithoutRecordedByInput> | ManualSaleCreateWithoutRecordedByInput[] | ManualSaleUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: ManualSaleCreateOrConnectWithoutRecordedByInput | ManualSaleCreateOrConnectWithoutRecordedByInput[]
    createMany?: ManualSaleCreateManyRecordedByInputEnvelope
    connect?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<ExpenseCreateWithoutRecordedByInput, ExpenseUncheckedCreateWithoutRecordedByInput> | ExpenseCreateWithoutRecordedByInput[] | ExpenseUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutRecordedByInput | ExpenseCreateOrConnectWithoutRecordedByInput[]
    createMany?: ExpenseCreateManyRecordedByInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type AccountUpdateroleInput = {
    set?: $Enums.Role[]
    push?: $Enums.Role | $Enums.Role[]
  }

  export type BranchUpdateOneWithoutAccountsNestedInput = {
    create?: XOR<BranchCreateWithoutAccountsInput, BranchUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAccountsInput
    upsert?: BranchUpsertWithoutAccountsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutAccountsInput, BranchUpdateWithoutAccountsInput>, BranchUncheckedUpdateWithoutAccountsInput>
  }

  export type AvailedServiceUpdateManyWithoutServedByNestedInput = {
    create?: XOR<AvailedServiceCreateWithoutServedByInput, AvailedServiceUncheckedCreateWithoutServedByInput> | AvailedServiceCreateWithoutServedByInput[] | AvailedServiceUncheckedCreateWithoutServedByInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutServedByInput | AvailedServiceCreateOrConnectWithoutServedByInput[]
    upsert?: AvailedServiceUpsertWithWhereUniqueWithoutServedByInput | AvailedServiceUpsertWithWhereUniqueWithoutServedByInput[]
    createMany?: AvailedServiceCreateManyServedByInputEnvelope
    set?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    disconnect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    delete?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    update?: AvailedServiceUpdateWithWhereUniqueWithoutServedByInput | AvailedServiceUpdateWithWhereUniqueWithoutServedByInput[]
    updateMany?: AvailedServiceUpdateManyWithWhereWithoutServedByInput | AvailedServiceUpdateManyWithWhereWithoutServedByInput[]
    deleteMany?: AvailedServiceScalarWhereInput | AvailedServiceScalarWhereInput[]
  }

  export type AvailedServiceUpdateManyWithoutCheckedByNestedInput = {
    create?: XOR<AvailedServiceCreateWithoutCheckedByInput, AvailedServiceUncheckedCreateWithoutCheckedByInput> | AvailedServiceCreateWithoutCheckedByInput[] | AvailedServiceUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutCheckedByInput | AvailedServiceCreateOrConnectWithoutCheckedByInput[]
    upsert?: AvailedServiceUpsertWithWhereUniqueWithoutCheckedByInput | AvailedServiceUpsertWithWhereUniqueWithoutCheckedByInput[]
    createMany?: AvailedServiceCreateManyCheckedByInputEnvelope
    set?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    disconnect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    delete?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    update?: AvailedServiceUpdateWithWhereUniqueWithoutCheckedByInput | AvailedServiceUpdateWithWhereUniqueWithoutCheckedByInput[]
    updateMany?: AvailedServiceUpdateManyWithWhereWithoutCheckedByInput | AvailedServiceUpdateManyWithWhereWithoutCheckedByInput[]
    deleteMany?: AvailedServiceScalarWhereInput | AvailedServiceScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AttendanceCreateWithoutAccountInput, AttendanceUncheckedCreateWithoutAccountInput> | AttendanceCreateWithoutAccountInput[] | AttendanceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutAccountInput | AttendanceCreateOrConnectWithoutAccountInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutAccountInput | AttendanceUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AttendanceCreateManyAccountInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutAccountInput | AttendanceUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutAccountInput | AttendanceUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutCheckedByNestedInput = {
    create?: XOR<AttendanceCreateWithoutCheckedByInput, AttendanceUncheckedCreateWithoutCheckedByInput> | AttendanceCreateWithoutCheckedByInput[] | AttendanceUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutCheckedByInput | AttendanceCreateOrConnectWithoutCheckedByInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutCheckedByInput | AttendanceUpsertWithWhereUniqueWithoutCheckedByInput[]
    createMany?: AttendanceCreateManyCheckedByInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutCheckedByInput | AttendanceUpdateWithWhereUniqueWithoutCheckedByInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutCheckedByInput | AttendanceUpdateManyWithWhereWithoutCheckedByInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type PayslipUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PayslipCreateWithoutAccountInput, PayslipUncheckedCreateWithoutAccountInput> | PayslipCreateWithoutAccountInput[] | PayslipUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PayslipCreateOrConnectWithoutAccountInput | PayslipCreateOrConnectWithoutAccountInput[]
    upsert?: PayslipUpsertWithWhereUniqueWithoutAccountInput | PayslipUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PayslipCreateManyAccountInputEnvelope
    set?: PayslipWhereUniqueInput | PayslipWhereUniqueInput[]
    disconnect?: PayslipWhereUniqueInput | PayslipWhereUniqueInput[]
    delete?: PayslipWhereUniqueInput | PayslipWhereUniqueInput[]
    connect?: PayslipWhereUniqueInput | PayslipWhereUniqueInput[]
    update?: PayslipUpdateWithWhereUniqueWithoutAccountInput | PayslipUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PayslipUpdateManyWithWhereWithoutAccountInput | PayslipUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PayslipScalarWhereInput | PayslipScalarWhereInput[]
  }

  export type PayslipRequestUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PayslipRequestCreateWithoutAccountInput, PayslipRequestUncheckedCreateWithoutAccountInput> | PayslipRequestCreateWithoutAccountInput[] | PayslipRequestUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PayslipRequestCreateOrConnectWithoutAccountInput | PayslipRequestCreateOrConnectWithoutAccountInput[]
    upsert?: PayslipRequestUpsertWithWhereUniqueWithoutAccountInput | PayslipRequestUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PayslipRequestCreateManyAccountInputEnvelope
    set?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
    disconnect?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
    delete?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
    connect?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
    update?: PayslipRequestUpdateWithWhereUniqueWithoutAccountInput | PayslipRequestUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PayslipRequestUpdateManyWithWhereWithoutAccountInput | PayslipRequestUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PayslipRequestScalarWhereInput | PayslipRequestScalarWhereInput[]
  }

  export type PayslipRequestUpdateManyWithoutProcessedByNestedInput = {
    create?: XOR<PayslipRequestCreateWithoutProcessedByInput, PayslipRequestUncheckedCreateWithoutProcessedByInput> | PayslipRequestCreateWithoutProcessedByInput[] | PayslipRequestUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: PayslipRequestCreateOrConnectWithoutProcessedByInput | PayslipRequestCreateOrConnectWithoutProcessedByInput[]
    upsert?: PayslipRequestUpsertWithWhereUniqueWithoutProcessedByInput | PayslipRequestUpsertWithWhereUniqueWithoutProcessedByInput[]
    createMany?: PayslipRequestCreateManyProcessedByInputEnvelope
    set?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
    disconnect?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
    delete?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
    connect?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
    update?: PayslipRequestUpdateWithWhereUniqueWithoutProcessedByInput | PayslipRequestUpdateWithWhereUniqueWithoutProcessedByInput[]
    updateMany?: PayslipRequestUpdateManyWithWhereWithoutProcessedByInput | PayslipRequestUpdateManyWithWhereWithoutProcessedByInput[]
    deleteMany?: PayslipRequestScalarWhereInput | PayslipRequestScalarWhereInput[]
  }

  export type ManualSaleUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<ManualSaleCreateWithoutRecordedByInput, ManualSaleUncheckedCreateWithoutRecordedByInput> | ManualSaleCreateWithoutRecordedByInput[] | ManualSaleUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: ManualSaleCreateOrConnectWithoutRecordedByInput | ManualSaleCreateOrConnectWithoutRecordedByInput[]
    upsert?: ManualSaleUpsertWithWhereUniqueWithoutRecordedByInput | ManualSaleUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: ManualSaleCreateManyRecordedByInputEnvelope
    set?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
    disconnect?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
    delete?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
    connect?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
    update?: ManualSaleUpdateWithWhereUniqueWithoutRecordedByInput | ManualSaleUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: ManualSaleUpdateManyWithWhereWithoutRecordedByInput | ManualSaleUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: ManualSaleScalarWhereInput | ManualSaleScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<ExpenseCreateWithoutRecordedByInput, ExpenseUncheckedCreateWithoutRecordedByInput> | ExpenseCreateWithoutRecordedByInput[] | ExpenseUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutRecordedByInput | ExpenseCreateOrConnectWithoutRecordedByInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutRecordedByInput | ExpenseUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: ExpenseCreateManyRecordedByInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutRecordedByInput | ExpenseUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutRecordedByInput | ExpenseUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type AvailedServiceUncheckedUpdateManyWithoutServedByNestedInput = {
    create?: XOR<AvailedServiceCreateWithoutServedByInput, AvailedServiceUncheckedCreateWithoutServedByInput> | AvailedServiceCreateWithoutServedByInput[] | AvailedServiceUncheckedCreateWithoutServedByInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutServedByInput | AvailedServiceCreateOrConnectWithoutServedByInput[]
    upsert?: AvailedServiceUpsertWithWhereUniqueWithoutServedByInput | AvailedServiceUpsertWithWhereUniqueWithoutServedByInput[]
    createMany?: AvailedServiceCreateManyServedByInputEnvelope
    set?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    disconnect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    delete?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    update?: AvailedServiceUpdateWithWhereUniqueWithoutServedByInput | AvailedServiceUpdateWithWhereUniqueWithoutServedByInput[]
    updateMany?: AvailedServiceUpdateManyWithWhereWithoutServedByInput | AvailedServiceUpdateManyWithWhereWithoutServedByInput[]
    deleteMany?: AvailedServiceScalarWhereInput | AvailedServiceScalarWhereInput[]
  }

  export type AvailedServiceUncheckedUpdateManyWithoutCheckedByNestedInput = {
    create?: XOR<AvailedServiceCreateWithoutCheckedByInput, AvailedServiceUncheckedCreateWithoutCheckedByInput> | AvailedServiceCreateWithoutCheckedByInput[] | AvailedServiceUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutCheckedByInput | AvailedServiceCreateOrConnectWithoutCheckedByInput[]
    upsert?: AvailedServiceUpsertWithWhereUniqueWithoutCheckedByInput | AvailedServiceUpsertWithWhereUniqueWithoutCheckedByInput[]
    createMany?: AvailedServiceCreateManyCheckedByInputEnvelope
    set?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    disconnect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    delete?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    update?: AvailedServiceUpdateWithWhereUniqueWithoutCheckedByInput | AvailedServiceUpdateWithWhereUniqueWithoutCheckedByInput[]
    updateMany?: AvailedServiceUpdateManyWithWhereWithoutCheckedByInput | AvailedServiceUpdateManyWithWhereWithoutCheckedByInput[]
    deleteMany?: AvailedServiceScalarWhereInput | AvailedServiceScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AttendanceCreateWithoutAccountInput, AttendanceUncheckedCreateWithoutAccountInput> | AttendanceCreateWithoutAccountInput[] | AttendanceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutAccountInput | AttendanceCreateOrConnectWithoutAccountInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutAccountInput | AttendanceUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AttendanceCreateManyAccountInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutAccountInput | AttendanceUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutAccountInput | AttendanceUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutCheckedByNestedInput = {
    create?: XOR<AttendanceCreateWithoutCheckedByInput, AttendanceUncheckedCreateWithoutCheckedByInput> | AttendanceCreateWithoutCheckedByInput[] | AttendanceUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutCheckedByInput | AttendanceCreateOrConnectWithoutCheckedByInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutCheckedByInput | AttendanceUpsertWithWhereUniqueWithoutCheckedByInput[]
    createMany?: AttendanceCreateManyCheckedByInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutCheckedByInput | AttendanceUpdateWithWhereUniqueWithoutCheckedByInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutCheckedByInput | AttendanceUpdateManyWithWhereWithoutCheckedByInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type PayslipUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PayslipCreateWithoutAccountInput, PayslipUncheckedCreateWithoutAccountInput> | PayslipCreateWithoutAccountInput[] | PayslipUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PayslipCreateOrConnectWithoutAccountInput | PayslipCreateOrConnectWithoutAccountInput[]
    upsert?: PayslipUpsertWithWhereUniqueWithoutAccountInput | PayslipUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PayslipCreateManyAccountInputEnvelope
    set?: PayslipWhereUniqueInput | PayslipWhereUniqueInput[]
    disconnect?: PayslipWhereUniqueInput | PayslipWhereUniqueInput[]
    delete?: PayslipWhereUniqueInput | PayslipWhereUniqueInput[]
    connect?: PayslipWhereUniqueInput | PayslipWhereUniqueInput[]
    update?: PayslipUpdateWithWhereUniqueWithoutAccountInput | PayslipUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PayslipUpdateManyWithWhereWithoutAccountInput | PayslipUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PayslipScalarWhereInput | PayslipScalarWhereInput[]
  }

  export type PayslipRequestUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PayslipRequestCreateWithoutAccountInput, PayslipRequestUncheckedCreateWithoutAccountInput> | PayslipRequestCreateWithoutAccountInput[] | PayslipRequestUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PayslipRequestCreateOrConnectWithoutAccountInput | PayslipRequestCreateOrConnectWithoutAccountInput[]
    upsert?: PayslipRequestUpsertWithWhereUniqueWithoutAccountInput | PayslipRequestUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PayslipRequestCreateManyAccountInputEnvelope
    set?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
    disconnect?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
    delete?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
    connect?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
    update?: PayslipRequestUpdateWithWhereUniqueWithoutAccountInput | PayslipRequestUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PayslipRequestUpdateManyWithWhereWithoutAccountInput | PayslipRequestUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PayslipRequestScalarWhereInput | PayslipRequestScalarWhereInput[]
  }

  export type PayslipRequestUncheckedUpdateManyWithoutProcessedByNestedInput = {
    create?: XOR<PayslipRequestCreateWithoutProcessedByInput, PayslipRequestUncheckedCreateWithoutProcessedByInput> | PayslipRequestCreateWithoutProcessedByInput[] | PayslipRequestUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: PayslipRequestCreateOrConnectWithoutProcessedByInput | PayslipRequestCreateOrConnectWithoutProcessedByInput[]
    upsert?: PayslipRequestUpsertWithWhereUniqueWithoutProcessedByInput | PayslipRequestUpsertWithWhereUniqueWithoutProcessedByInput[]
    createMany?: PayslipRequestCreateManyProcessedByInputEnvelope
    set?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
    disconnect?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
    delete?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
    connect?: PayslipRequestWhereUniqueInput | PayslipRequestWhereUniqueInput[]
    update?: PayslipRequestUpdateWithWhereUniqueWithoutProcessedByInput | PayslipRequestUpdateWithWhereUniqueWithoutProcessedByInput[]
    updateMany?: PayslipRequestUpdateManyWithWhereWithoutProcessedByInput | PayslipRequestUpdateManyWithWhereWithoutProcessedByInput[]
    deleteMany?: PayslipRequestScalarWhereInput | PayslipRequestScalarWhereInput[]
  }

  export type ManualSaleUncheckedUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<ManualSaleCreateWithoutRecordedByInput, ManualSaleUncheckedCreateWithoutRecordedByInput> | ManualSaleCreateWithoutRecordedByInput[] | ManualSaleUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: ManualSaleCreateOrConnectWithoutRecordedByInput | ManualSaleCreateOrConnectWithoutRecordedByInput[]
    upsert?: ManualSaleUpsertWithWhereUniqueWithoutRecordedByInput | ManualSaleUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: ManualSaleCreateManyRecordedByInputEnvelope
    set?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
    disconnect?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
    delete?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
    connect?: ManualSaleWhereUniqueInput | ManualSaleWhereUniqueInput[]
    update?: ManualSaleUpdateWithWhereUniqueWithoutRecordedByInput | ManualSaleUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: ManualSaleUpdateManyWithWhereWithoutRecordedByInput | ManualSaleUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: ManualSaleScalarWhereInput | ManualSaleScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<ExpenseCreateWithoutRecordedByInput, ExpenseUncheckedCreateWithoutRecordedByInput> | ExpenseCreateWithoutRecordedByInput[] | ExpenseUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutRecordedByInput | ExpenseCreateOrConnectWithoutRecordedByInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutRecordedByInput | ExpenseUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: ExpenseCreateManyRecordedByInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutRecordedByInput | ExpenseUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutRecordedByInput | ExpenseUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutServicesInput = {
    create?: XOR<BranchCreateWithoutServicesInput, BranchUncheckedCreateWithoutServicesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutServicesInput
    connect?: BranchWhereUniqueInput
  }

  export type AvailedServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<AvailedServiceCreateWithoutServiceInput, AvailedServiceUncheckedCreateWithoutServiceInput> | AvailedServiceCreateWithoutServiceInput[] | AvailedServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutServiceInput | AvailedServiceCreateOrConnectWithoutServiceInput[]
    createMany?: AvailedServiceCreateManyServiceInputEnvelope
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
  }

  export type ServiceSetCreateNestedManyWithoutServicesInput = {
    create?: XOR<ServiceSetCreateWithoutServicesInput, ServiceSetUncheckedCreateWithoutServicesInput> | ServiceSetCreateWithoutServicesInput[] | ServiceSetUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: ServiceSetCreateOrConnectWithoutServicesInput | ServiceSetCreateOrConnectWithoutServicesInput[]
    connect?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
  }

  export type GiftCertificateCreateNestedManyWithoutServicesInput = {
    create?: XOR<GiftCertificateCreateWithoutServicesInput, GiftCertificateUncheckedCreateWithoutServicesInput> | GiftCertificateCreateWithoutServicesInput[] | GiftCertificateUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: GiftCertificateCreateOrConnectWithoutServicesInput | GiftCertificateCreateOrConnectWithoutServicesInput[]
    connect?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
  }

  export type DiscountRuleCreateNestedManyWithoutServicesInput = {
    create?: XOR<DiscountRuleCreateWithoutServicesInput, DiscountRuleUncheckedCreateWithoutServicesInput> | DiscountRuleCreateWithoutServicesInput[] | DiscountRuleUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: DiscountRuleCreateOrConnectWithoutServicesInput | DiscountRuleCreateOrConnectWithoutServicesInput[]
    connect?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
  }

  export type RecommendedAppointmentCreateNestedManyWithoutOriginatingServiceInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutOriginatingServiceInput, RecommendedAppointmentUncheckedCreateWithoutOriginatingServiceInput> | RecommendedAppointmentCreateWithoutOriginatingServiceInput[] | RecommendedAppointmentUncheckedCreateWithoutOriginatingServiceInput[]
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutOriginatingServiceInput | RecommendedAppointmentCreateOrConnectWithoutOriginatingServiceInput[]
    createMany?: RecommendedAppointmentCreateManyOriginatingServiceInputEnvelope
    connect?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
  }

  export type AvailedServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<AvailedServiceCreateWithoutServiceInput, AvailedServiceUncheckedCreateWithoutServiceInput> | AvailedServiceCreateWithoutServiceInput[] | AvailedServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutServiceInput | AvailedServiceCreateOrConnectWithoutServiceInput[]
    createMany?: AvailedServiceCreateManyServiceInputEnvelope
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
  }

  export type ServiceSetUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<ServiceSetCreateWithoutServicesInput, ServiceSetUncheckedCreateWithoutServicesInput> | ServiceSetCreateWithoutServicesInput[] | ServiceSetUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: ServiceSetCreateOrConnectWithoutServicesInput | ServiceSetCreateOrConnectWithoutServicesInput[]
    connect?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
  }

  export type GiftCertificateUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<GiftCertificateCreateWithoutServicesInput, GiftCertificateUncheckedCreateWithoutServicesInput> | GiftCertificateCreateWithoutServicesInput[] | GiftCertificateUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: GiftCertificateCreateOrConnectWithoutServicesInput | GiftCertificateCreateOrConnectWithoutServicesInput[]
    connect?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
  }

  export type DiscountRuleUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<DiscountRuleCreateWithoutServicesInput, DiscountRuleUncheckedCreateWithoutServicesInput> | DiscountRuleCreateWithoutServicesInput[] | DiscountRuleUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: DiscountRuleCreateOrConnectWithoutServicesInput | DiscountRuleCreateOrConnectWithoutServicesInput[]
    connect?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
  }

  export type RecommendedAppointmentUncheckedCreateNestedManyWithoutOriginatingServiceInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutOriginatingServiceInput, RecommendedAppointmentUncheckedCreateWithoutOriginatingServiceInput> | RecommendedAppointmentCreateWithoutOriginatingServiceInput[] | RecommendedAppointmentUncheckedCreateWithoutOriginatingServiceInput[]
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutOriginatingServiceInput | RecommendedAppointmentCreateOrConnectWithoutOriginatingServiceInput[]
    createMany?: RecommendedAppointmentCreateManyOriginatingServiceInputEnvelope
    connect?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumFollowUpPolicyFieldUpdateOperationsInput = {
    set?: $Enums.FollowUpPolicy
  }

  export type BranchUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<BranchCreateWithoutServicesInput, BranchUncheckedCreateWithoutServicesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutServicesInput
    upsert?: BranchUpsertWithoutServicesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutServicesInput, BranchUpdateWithoutServicesInput>, BranchUncheckedUpdateWithoutServicesInput>
  }

  export type AvailedServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<AvailedServiceCreateWithoutServiceInput, AvailedServiceUncheckedCreateWithoutServiceInput> | AvailedServiceCreateWithoutServiceInput[] | AvailedServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutServiceInput | AvailedServiceCreateOrConnectWithoutServiceInput[]
    upsert?: AvailedServiceUpsertWithWhereUniqueWithoutServiceInput | AvailedServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: AvailedServiceCreateManyServiceInputEnvelope
    set?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    disconnect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    delete?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    update?: AvailedServiceUpdateWithWhereUniqueWithoutServiceInput | AvailedServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: AvailedServiceUpdateManyWithWhereWithoutServiceInput | AvailedServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: AvailedServiceScalarWhereInput | AvailedServiceScalarWhereInput[]
  }

  export type ServiceSetUpdateManyWithoutServicesNestedInput = {
    create?: XOR<ServiceSetCreateWithoutServicesInput, ServiceSetUncheckedCreateWithoutServicesInput> | ServiceSetCreateWithoutServicesInput[] | ServiceSetUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: ServiceSetCreateOrConnectWithoutServicesInput | ServiceSetCreateOrConnectWithoutServicesInput[]
    upsert?: ServiceSetUpsertWithWhereUniqueWithoutServicesInput | ServiceSetUpsertWithWhereUniqueWithoutServicesInput[]
    set?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
    disconnect?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
    delete?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
    connect?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
    update?: ServiceSetUpdateWithWhereUniqueWithoutServicesInput | ServiceSetUpdateWithWhereUniqueWithoutServicesInput[]
    updateMany?: ServiceSetUpdateManyWithWhereWithoutServicesInput | ServiceSetUpdateManyWithWhereWithoutServicesInput[]
    deleteMany?: ServiceSetScalarWhereInput | ServiceSetScalarWhereInput[]
  }

  export type GiftCertificateUpdateManyWithoutServicesNestedInput = {
    create?: XOR<GiftCertificateCreateWithoutServicesInput, GiftCertificateUncheckedCreateWithoutServicesInput> | GiftCertificateCreateWithoutServicesInput[] | GiftCertificateUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: GiftCertificateCreateOrConnectWithoutServicesInput | GiftCertificateCreateOrConnectWithoutServicesInput[]
    upsert?: GiftCertificateUpsertWithWhereUniqueWithoutServicesInput | GiftCertificateUpsertWithWhereUniqueWithoutServicesInput[]
    set?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    disconnect?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    delete?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    connect?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    update?: GiftCertificateUpdateWithWhereUniqueWithoutServicesInput | GiftCertificateUpdateWithWhereUniqueWithoutServicesInput[]
    updateMany?: GiftCertificateUpdateManyWithWhereWithoutServicesInput | GiftCertificateUpdateManyWithWhereWithoutServicesInput[]
    deleteMany?: GiftCertificateScalarWhereInput | GiftCertificateScalarWhereInput[]
  }

  export type DiscountRuleUpdateManyWithoutServicesNestedInput = {
    create?: XOR<DiscountRuleCreateWithoutServicesInput, DiscountRuleUncheckedCreateWithoutServicesInput> | DiscountRuleCreateWithoutServicesInput[] | DiscountRuleUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: DiscountRuleCreateOrConnectWithoutServicesInput | DiscountRuleCreateOrConnectWithoutServicesInput[]
    upsert?: DiscountRuleUpsertWithWhereUniqueWithoutServicesInput | DiscountRuleUpsertWithWhereUniqueWithoutServicesInput[]
    set?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
    disconnect?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
    delete?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
    connect?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
    update?: DiscountRuleUpdateWithWhereUniqueWithoutServicesInput | DiscountRuleUpdateWithWhereUniqueWithoutServicesInput[]
    updateMany?: DiscountRuleUpdateManyWithWhereWithoutServicesInput | DiscountRuleUpdateManyWithWhereWithoutServicesInput[]
    deleteMany?: DiscountRuleScalarWhereInput | DiscountRuleScalarWhereInput[]
  }

  export type RecommendedAppointmentUpdateManyWithoutOriginatingServiceNestedInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutOriginatingServiceInput, RecommendedAppointmentUncheckedCreateWithoutOriginatingServiceInput> | RecommendedAppointmentCreateWithoutOriginatingServiceInput[] | RecommendedAppointmentUncheckedCreateWithoutOriginatingServiceInput[]
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutOriginatingServiceInput | RecommendedAppointmentCreateOrConnectWithoutOriginatingServiceInput[]
    upsert?: RecommendedAppointmentUpsertWithWhereUniqueWithoutOriginatingServiceInput | RecommendedAppointmentUpsertWithWhereUniqueWithoutOriginatingServiceInput[]
    createMany?: RecommendedAppointmentCreateManyOriginatingServiceInputEnvelope
    set?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    disconnect?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    delete?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    connect?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    update?: RecommendedAppointmentUpdateWithWhereUniqueWithoutOriginatingServiceInput | RecommendedAppointmentUpdateWithWhereUniqueWithoutOriginatingServiceInput[]
    updateMany?: RecommendedAppointmentUpdateManyWithWhereWithoutOriginatingServiceInput | RecommendedAppointmentUpdateManyWithWhereWithoutOriginatingServiceInput[]
    deleteMany?: RecommendedAppointmentScalarWhereInput | RecommendedAppointmentScalarWhereInput[]
  }

  export type AvailedServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<AvailedServiceCreateWithoutServiceInput, AvailedServiceUncheckedCreateWithoutServiceInput> | AvailedServiceCreateWithoutServiceInput[] | AvailedServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutServiceInput | AvailedServiceCreateOrConnectWithoutServiceInput[]
    upsert?: AvailedServiceUpsertWithWhereUniqueWithoutServiceInput | AvailedServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: AvailedServiceCreateManyServiceInputEnvelope
    set?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    disconnect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    delete?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    update?: AvailedServiceUpdateWithWhereUniqueWithoutServiceInput | AvailedServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: AvailedServiceUpdateManyWithWhereWithoutServiceInput | AvailedServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: AvailedServiceScalarWhereInput | AvailedServiceScalarWhereInput[]
  }

  export type ServiceSetUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<ServiceSetCreateWithoutServicesInput, ServiceSetUncheckedCreateWithoutServicesInput> | ServiceSetCreateWithoutServicesInput[] | ServiceSetUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: ServiceSetCreateOrConnectWithoutServicesInput | ServiceSetCreateOrConnectWithoutServicesInput[]
    upsert?: ServiceSetUpsertWithWhereUniqueWithoutServicesInput | ServiceSetUpsertWithWhereUniqueWithoutServicesInput[]
    set?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
    disconnect?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
    delete?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
    connect?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
    update?: ServiceSetUpdateWithWhereUniqueWithoutServicesInput | ServiceSetUpdateWithWhereUniqueWithoutServicesInput[]
    updateMany?: ServiceSetUpdateManyWithWhereWithoutServicesInput | ServiceSetUpdateManyWithWhereWithoutServicesInput[]
    deleteMany?: ServiceSetScalarWhereInput | ServiceSetScalarWhereInput[]
  }

  export type GiftCertificateUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<GiftCertificateCreateWithoutServicesInput, GiftCertificateUncheckedCreateWithoutServicesInput> | GiftCertificateCreateWithoutServicesInput[] | GiftCertificateUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: GiftCertificateCreateOrConnectWithoutServicesInput | GiftCertificateCreateOrConnectWithoutServicesInput[]
    upsert?: GiftCertificateUpsertWithWhereUniqueWithoutServicesInput | GiftCertificateUpsertWithWhereUniqueWithoutServicesInput[]
    set?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    disconnect?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    delete?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    connect?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    update?: GiftCertificateUpdateWithWhereUniqueWithoutServicesInput | GiftCertificateUpdateWithWhereUniqueWithoutServicesInput[]
    updateMany?: GiftCertificateUpdateManyWithWhereWithoutServicesInput | GiftCertificateUpdateManyWithWhereWithoutServicesInput[]
    deleteMany?: GiftCertificateScalarWhereInput | GiftCertificateScalarWhereInput[]
  }

  export type DiscountRuleUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<DiscountRuleCreateWithoutServicesInput, DiscountRuleUncheckedCreateWithoutServicesInput> | DiscountRuleCreateWithoutServicesInput[] | DiscountRuleUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: DiscountRuleCreateOrConnectWithoutServicesInput | DiscountRuleCreateOrConnectWithoutServicesInput[]
    upsert?: DiscountRuleUpsertWithWhereUniqueWithoutServicesInput | DiscountRuleUpsertWithWhereUniqueWithoutServicesInput[]
    set?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
    disconnect?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
    delete?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
    connect?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
    update?: DiscountRuleUpdateWithWhereUniqueWithoutServicesInput | DiscountRuleUpdateWithWhereUniqueWithoutServicesInput[]
    updateMany?: DiscountRuleUpdateManyWithWhereWithoutServicesInput | DiscountRuleUpdateManyWithWhereWithoutServicesInput[]
    deleteMany?: DiscountRuleScalarWhereInput | DiscountRuleScalarWhereInput[]
  }

  export type RecommendedAppointmentUncheckedUpdateManyWithoutOriginatingServiceNestedInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutOriginatingServiceInput, RecommendedAppointmentUncheckedCreateWithoutOriginatingServiceInput> | RecommendedAppointmentCreateWithoutOriginatingServiceInput[] | RecommendedAppointmentUncheckedCreateWithoutOriginatingServiceInput[]
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutOriginatingServiceInput | RecommendedAppointmentCreateOrConnectWithoutOriginatingServiceInput[]
    upsert?: RecommendedAppointmentUpsertWithWhereUniqueWithoutOriginatingServiceInput | RecommendedAppointmentUpsertWithWhereUniqueWithoutOriginatingServiceInput[]
    createMany?: RecommendedAppointmentCreateManyOriginatingServiceInputEnvelope
    set?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    disconnect?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    delete?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    connect?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    update?: RecommendedAppointmentUpdateWithWhereUniqueWithoutOriginatingServiceInput | RecommendedAppointmentUpdateWithWhereUniqueWithoutOriginatingServiceInput[]
    updateMany?: RecommendedAppointmentUpdateManyWithWhereWithoutOriginatingServiceInput | RecommendedAppointmentUpdateManyWithWhereWithoutOriginatingServiceInput[]
    deleteMany?: RecommendedAppointmentScalarWhereInput | RecommendedAppointmentScalarWhereInput[]
  }

  export type ServiceCreateNestedManyWithoutServiceSetsInput = {
    create?: XOR<ServiceCreateWithoutServiceSetsInput, ServiceUncheckedCreateWithoutServiceSetsInput> | ServiceCreateWithoutServiceSetsInput[] | ServiceUncheckedCreateWithoutServiceSetsInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceSetsInput | ServiceCreateOrConnectWithoutServiceSetsInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type GiftCertificateCreateNestedManyWithoutServiceSetsInput = {
    create?: XOR<GiftCertificateCreateWithoutServiceSetsInput, GiftCertificateUncheckedCreateWithoutServiceSetsInput> | GiftCertificateCreateWithoutServiceSetsInput[] | GiftCertificateUncheckedCreateWithoutServiceSetsInput[]
    connectOrCreate?: GiftCertificateCreateOrConnectWithoutServiceSetsInput | GiftCertificateCreateOrConnectWithoutServiceSetsInput[]
    connect?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
  }

  export type AvailedServiceCreateNestedManyWithoutOriginatingSetInput = {
    create?: XOR<AvailedServiceCreateWithoutOriginatingSetInput, AvailedServiceUncheckedCreateWithoutOriginatingSetInput> | AvailedServiceCreateWithoutOriginatingSetInput[] | AvailedServiceUncheckedCreateWithoutOriginatingSetInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutOriginatingSetInput | AvailedServiceCreateOrConnectWithoutOriginatingSetInput[]
    createMany?: AvailedServiceCreateManyOriginatingSetInputEnvelope
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutServiceSetsInput = {
    create?: XOR<ServiceCreateWithoutServiceSetsInput, ServiceUncheckedCreateWithoutServiceSetsInput> | ServiceCreateWithoutServiceSetsInput[] | ServiceUncheckedCreateWithoutServiceSetsInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceSetsInput | ServiceCreateOrConnectWithoutServiceSetsInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type GiftCertificateUncheckedCreateNestedManyWithoutServiceSetsInput = {
    create?: XOR<GiftCertificateCreateWithoutServiceSetsInput, GiftCertificateUncheckedCreateWithoutServiceSetsInput> | GiftCertificateCreateWithoutServiceSetsInput[] | GiftCertificateUncheckedCreateWithoutServiceSetsInput[]
    connectOrCreate?: GiftCertificateCreateOrConnectWithoutServiceSetsInput | GiftCertificateCreateOrConnectWithoutServiceSetsInput[]
    connect?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
  }

  export type AvailedServiceUncheckedCreateNestedManyWithoutOriginatingSetInput = {
    create?: XOR<AvailedServiceCreateWithoutOriginatingSetInput, AvailedServiceUncheckedCreateWithoutOriginatingSetInput> | AvailedServiceCreateWithoutOriginatingSetInput[] | AvailedServiceUncheckedCreateWithoutOriginatingSetInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutOriginatingSetInput | AvailedServiceCreateOrConnectWithoutOriginatingSetInput[]
    createMany?: AvailedServiceCreateManyOriginatingSetInputEnvelope
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
  }

  export type ServiceUpdateManyWithoutServiceSetsNestedInput = {
    create?: XOR<ServiceCreateWithoutServiceSetsInput, ServiceUncheckedCreateWithoutServiceSetsInput> | ServiceCreateWithoutServiceSetsInput[] | ServiceUncheckedCreateWithoutServiceSetsInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceSetsInput | ServiceCreateOrConnectWithoutServiceSetsInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutServiceSetsInput | ServiceUpsertWithWhereUniqueWithoutServiceSetsInput[]
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutServiceSetsInput | ServiceUpdateWithWhereUniqueWithoutServiceSetsInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutServiceSetsInput | ServiceUpdateManyWithWhereWithoutServiceSetsInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type GiftCertificateUpdateManyWithoutServiceSetsNestedInput = {
    create?: XOR<GiftCertificateCreateWithoutServiceSetsInput, GiftCertificateUncheckedCreateWithoutServiceSetsInput> | GiftCertificateCreateWithoutServiceSetsInput[] | GiftCertificateUncheckedCreateWithoutServiceSetsInput[]
    connectOrCreate?: GiftCertificateCreateOrConnectWithoutServiceSetsInput | GiftCertificateCreateOrConnectWithoutServiceSetsInput[]
    upsert?: GiftCertificateUpsertWithWhereUniqueWithoutServiceSetsInput | GiftCertificateUpsertWithWhereUniqueWithoutServiceSetsInput[]
    set?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    disconnect?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    delete?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    connect?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    update?: GiftCertificateUpdateWithWhereUniqueWithoutServiceSetsInput | GiftCertificateUpdateWithWhereUniqueWithoutServiceSetsInput[]
    updateMany?: GiftCertificateUpdateManyWithWhereWithoutServiceSetsInput | GiftCertificateUpdateManyWithWhereWithoutServiceSetsInput[]
    deleteMany?: GiftCertificateScalarWhereInput | GiftCertificateScalarWhereInput[]
  }

  export type AvailedServiceUpdateManyWithoutOriginatingSetNestedInput = {
    create?: XOR<AvailedServiceCreateWithoutOriginatingSetInput, AvailedServiceUncheckedCreateWithoutOriginatingSetInput> | AvailedServiceCreateWithoutOriginatingSetInput[] | AvailedServiceUncheckedCreateWithoutOriginatingSetInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutOriginatingSetInput | AvailedServiceCreateOrConnectWithoutOriginatingSetInput[]
    upsert?: AvailedServiceUpsertWithWhereUniqueWithoutOriginatingSetInput | AvailedServiceUpsertWithWhereUniqueWithoutOriginatingSetInput[]
    createMany?: AvailedServiceCreateManyOriginatingSetInputEnvelope
    set?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    disconnect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    delete?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    update?: AvailedServiceUpdateWithWhereUniqueWithoutOriginatingSetInput | AvailedServiceUpdateWithWhereUniqueWithoutOriginatingSetInput[]
    updateMany?: AvailedServiceUpdateManyWithWhereWithoutOriginatingSetInput | AvailedServiceUpdateManyWithWhereWithoutOriginatingSetInput[]
    deleteMany?: AvailedServiceScalarWhereInput | AvailedServiceScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutServiceSetsNestedInput = {
    create?: XOR<ServiceCreateWithoutServiceSetsInput, ServiceUncheckedCreateWithoutServiceSetsInput> | ServiceCreateWithoutServiceSetsInput[] | ServiceUncheckedCreateWithoutServiceSetsInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceSetsInput | ServiceCreateOrConnectWithoutServiceSetsInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutServiceSetsInput | ServiceUpsertWithWhereUniqueWithoutServiceSetsInput[]
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutServiceSetsInput | ServiceUpdateWithWhereUniqueWithoutServiceSetsInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutServiceSetsInput | ServiceUpdateManyWithWhereWithoutServiceSetsInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type GiftCertificateUncheckedUpdateManyWithoutServiceSetsNestedInput = {
    create?: XOR<GiftCertificateCreateWithoutServiceSetsInput, GiftCertificateUncheckedCreateWithoutServiceSetsInput> | GiftCertificateCreateWithoutServiceSetsInput[] | GiftCertificateUncheckedCreateWithoutServiceSetsInput[]
    connectOrCreate?: GiftCertificateCreateOrConnectWithoutServiceSetsInput | GiftCertificateCreateOrConnectWithoutServiceSetsInput[]
    upsert?: GiftCertificateUpsertWithWhereUniqueWithoutServiceSetsInput | GiftCertificateUpsertWithWhereUniqueWithoutServiceSetsInput[]
    set?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    disconnect?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    delete?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    connect?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    update?: GiftCertificateUpdateWithWhereUniqueWithoutServiceSetsInput | GiftCertificateUpdateWithWhereUniqueWithoutServiceSetsInput[]
    updateMany?: GiftCertificateUpdateManyWithWhereWithoutServiceSetsInput | GiftCertificateUpdateManyWithWhereWithoutServiceSetsInput[]
    deleteMany?: GiftCertificateScalarWhereInput | GiftCertificateScalarWhereInput[]
  }

  export type AvailedServiceUncheckedUpdateManyWithoutOriginatingSetNestedInput = {
    create?: XOR<AvailedServiceCreateWithoutOriginatingSetInput, AvailedServiceUncheckedCreateWithoutOriginatingSetInput> | AvailedServiceCreateWithoutOriginatingSetInput[] | AvailedServiceUncheckedCreateWithoutOriginatingSetInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutOriginatingSetInput | AvailedServiceCreateOrConnectWithoutOriginatingSetInput[]
    upsert?: AvailedServiceUpsertWithWhereUniqueWithoutOriginatingSetInput | AvailedServiceUpsertWithWhereUniqueWithoutOriginatingSetInput[]
    createMany?: AvailedServiceCreateManyOriginatingSetInputEnvelope
    set?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    disconnect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    delete?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    update?: AvailedServiceUpdateWithWhereUniqueWithoutOriginatingSetInput | AvailedServiceUpdateWithWhereUniqueWithoutOriginatingSetInput[]
    updateMany?: AvailedServiceUpdateManyWithWhereWithoutOriginatingSetInput | AvailedServiceUpdateManyWithWhereWithoutOriginatingSetInput[]
    deleteMany?: AvailedServiceScalarWhereInput | AvailedServiceScalarWhereInput[]
  }

  export type RecommendedAppointmentCreateNestedManyWithoutCustomerInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutCustomerInput, RecommendedAppointmentUncheckedCreateWithoutCustomerInput> | RecommendedAppointmentCreateWithoutCustomerInput[] | RecommendedAppointmentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutCustomerInput | RecommendedAppointmentCreateOrConnectWithoutCustomerInput[]
    createMany?: RecommendedAppointmentCreateManyCustomerInputEnvelope
    connect?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type GiftCertificateCreateNestedManyWithoutPurchaserCustomerInput = {
    create?: XOR<GiftCertificateCreateWithoutPurchaserCustomerInput, GiftCertificateUncheckedCreateWithoutPurchaserCustomerInput> | GiftCertificateCreateWithoutPurchaserCustomerInput[] | GiftCertificateUncheckedCreateWithoutPurchaserCustomerInput[]
    connectOrCreate?: GiftCertificateCreateOrConnectWithoutPurchaserCustomerInput | GiftCertificateCreateOrConnectWithoutPurchaserCustomerInput[]
    createMany?: GiftCertificateCreateManyPurchaserCustomerInputEnvelope
    connect?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
  }

  export type RecommendedAppointmentUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutCustomerInput, RecommendedAppointmentUncheckedCreateWithoutCustomerInput> | RecommendedAppointmentCreateWithoutCustomerInput[] | RecommendedAppointmentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutCustomerInput | RecommendedAppointmentCreateOrConnectWithoutCustomerInput[]
    createMany?: RecommendedAppointmentCreateManyCustomerInputEnvelope
    connect?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type GiftCertificateUncheckedCreateNestedManyWithoutPurchaserCustomerInput = {
    create?: XOR<GiftCertificateCreateWithoutPurchaserCustomerInput, GiftCertificateUncheckedCreateWithoutPurchaserCustomerInput> | GiftCertificateCreateWithoutPurchaserCustomerInput[] | GiftCertificateUncheckedCreateWithoutPurchaserCustomerInput[]
    connectOrCreate?: GiftCertificateCreateOrConnectWithoutPurchaserCustomerInput | GiftCertificateCreateOrConnectWithoutPurchaserCustomerInput[]
    createMany?: GiftCertificateCreateManyPurchaserCustomerInputEnvelope
    connect?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
  }

  export type RecommendedAppointmentUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutCustomerInput, RecommendedAppointmentUncheckedCreateWithoutCustomerInput> | RecommendedAppointmentCreateWithoutCustomerInput[] | RecommendedAppointmentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutCustomerInput | RecommendedAppointmentCreateOrConnectWithoutCustomerInput[]
    upsert?: RecommendedAppointmentUpsertWithWhereUniqueWithoutCustomerInput | RecommendedAppointmentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: RecommendedAppointmentCreateManyCustomerInputEnvelope
    set?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    disconnect?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    delete?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    connect?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    update?: RecommendedAppointmentUpdateWithWhereUniqueWithoutCustomerInput | RecommendedAppointmentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: RecommendedAppointmentUpdateManyWithWhereWithoutCustomerInput | RecommendedAppointmentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: RecommendedAppointmentScalarWhereInput | RecommendedAppointmentScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCustomerInput | TransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCustomerInput | TransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCustomerInput | TransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type GiftCertificateUpdateManyWithoutPurchaserCustomerNestedInput = {
    create?: XOR<GiftCertificateCreateWithoutPurchaserCustomerInput, GiftCertificateUncheckedCreateWithoutPurchaserCustomerInput> | GiftCertificateCreateWithoutPurchaserCustomerInput[] | GiftCertificateUncheckedCreateWithoutPurchaserCustomerInput[]
    connectOrCreate?: GiftCertificateCreateOrConnectWithoutPurchaserCustomerInput | GiftCertificateCreateOrConnectWithoutPurchaserCustomerInput[]
    upsert?: GiftCertificateUpsertWithWhereUniqueWithoutPurchaserCustomerInput | GiftCertificateUpsertWithWhereUniqueWithoutPurchaserCustomerInput[]
    createMany?: GiftCertificateCreateManyPurchaserCustomerInputEnvelope
    set?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    disconnect?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    delete?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    connect?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    update?: GiftCertificateUpdateWithWhereUniqueWithoutPurchaserCustomerInput | GiftCertificateUpdateWithWhereUniqueWithoutPurchaserCustomerInput[]
    updateMany?: GiftCertificateUpdateManyWithWhereWithoutPurchaserCustomerInput | GiftCertificateUpdateManyWithWhereWithoutPurchaserCustomerInput[]
    deleteMany?: GiftCertificateScalarWhereInput | GiftCertificateScalarWhereInput[]
  }

  export type RecommendedAppointmentUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutCustomerInput, RecommendedAppointmentUncheckedCreateWithoutCustomerInput> | RecommendedAppointmentCreateWithoutCustomerInput[] | RecommendedAppointmentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutCustomerInput | RecommendedAppointmentCreateOrConnectWithoutCustomerInput[]
    upsert?: RecommendedAppointmentUpsertWithWhereUniqueWithoutCustomerInput | RecommendedAppointmentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: RecommendedAppointmentCreateManyCustomerInputEnvelope
    set?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    disconnect?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    delete?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    connect?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    update?: RecommendedAppointmentUpdateWithWhereUniqueWithoutCustomerInput | RecommendedAppointmentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: RecommendedAppointmentUpdateManyWithWhereWithoutCustomerInput | RecommendedAppointmentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: RecommendedAppointmentScalarWhereInput | RecommendedAppointmentScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCustomerInput | TransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCustomerInput | TransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCustomerInput | TransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type GiftCertificateUncheckedUpdateManyWithoutPurchaserCustomerNestedInput = {
    create?: XOR<GiftCertificateCreateWithoutPurchaserCustomerInput, GiftCertificateUncheckedCreateWithoutPurchaserCustomerInput> | GiftCertificateCreateWithoutPurchaserCustomerInput[] | GiftCertificateUncheckedCreateWithoutPurchaserCustomerInput[]
    connectOrCreate?: GiftCertificateCreateOrConnectWithoutPurchaserCustomerInput | GiftCertificateCreateOrConnectWithoutPurchaserCustomerInput[]
    upsert?: GiftCertificateUpsertWithWhereUniqueWithoutPurchaserCustomerInput | GiftCertificateUpsertWithWhereUniqueWithoutPurchaserCustomerInput[]
    createMany?: GiftCertificateCreateManyPurchaserCustomerInputEnvelope
    set?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    disconnect?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    delete?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    connect?: GiftCertificateWhereUniqueInput | GiftCertificateWhereUniqueInput[]
    update?: GiftCertificateUpdateWithWhereUniqueWithoutPurchaserCustomerInput | GiftCertificateUpdateWithWhereUniqueWithoutPurchaserCustomerInput[]
    updateMany?: GiftCertificateUpdateManyWithWhereWithoutPurchaserCustomerInput | GiftCertificateUpdateManyWithWhereWithoutPurchaserCustomerInput[]
    deleteMany?: GiftCertificateScalarWhereInput | GiftCertificateScalarWhereInput[]
  }

  export type TransactionCreateNestedManyWithoutVoucherUsedInput = {
    create?: XOR<TransactionCreateWithoutVoucherUsedInput, TransactionUncheckedCreateWithoutVoucherUsedInput> | TransactionCreateWithoutVoucherUsedInput[] | TransactionUncheckedCreateWithoutVoucherUsedInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVoucherUsedInput | TransactionCreateOrConnectWithoutVoucherUsedInput[]
    createMany?: TransactionCreateManyVoucherUsedInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutVoucherUsedInput = {
    create?: XOR<TransactionCreateWithoutVoucherUsedInput, TransactionUncheckedCreateWithoutVoucherUsedInput> | TransactionCreateWithoutVoucherUsedInput[] | TransactionUncheckedCreateWithoutVoucherUsedInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVoucherUsedInput | TransactionCreateOrConnectWithoutVoucherUsedInput[]
    createMany?: TransactionCreateManyVoucherUsedInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUpdateManyWithoutVoucherUsedNestedInput = {
    create?: XOR<TransactionCreateWithoutVoucherUsedInput, TransactionUncheckedCreateWithoutVoucherUsedInput> | TransactionCreateWithoutVoucherUsedInput[] | TransactionUncheckedCreateWithoutVoucherUsedInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVoucherUsedInput | TransactionCreateOrConnectWithoutVoucherUsedInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutVoucherUsedInput | TransactionUpsertWithWhereUniqueWithoutVoucherUsedInput[]
    createMany?: TransactionCreateManyVoucherUsedInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutVoucherUsedInput | TransactionUpdateWithWhereUniqueWithoutVoucherUsedInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutVoucherUsedInput | TransactionUpdateManyWithWhereWithoutVoucherUsedInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutVoucherUsedNestedInput = {
    create?: XOR<TransactionCreateWithoutVoucherUsedInput, TransactionUncheckedCreateWithoutVoucherUsedInput> | TransactionCreateWithoutVoucherUsedInput[] | TransactionUncheckedCreateWithoutVoucherUsedInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVoucherUsedInput | TransactionCreateOrConnectWithoutVoucherUsedInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutVoucherUsedInput | TransactionUpsertWithWhereUniqueWithoutVoucherUsedInput[]
    createMany?: TransactionCreateManyVoucherUsedInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutVoucherUsedInput | TransactionUpdateWithWhereUniqueWithoutVoucherUsedInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutVoucherUsedInput | TransactionUpdateManyWithWhereWithoutVoucherUsedInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutTransactionHistoryInput = {
    create?: XOR<CustomerCreateWithoutTransactionHistoryInput, CustomerUncheckedCreateWithoutTransactionHistoryInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionHistoryInput
    connect?: CustomerWhereUniqueInput
  }

  export type AvailedServiceCreateNestedManyWithoutTransactionInput = {
    create?: XOR<AvailedServiceCreateWithoutTransactionInput, AvailedServiceUncheckedCreateWithoutTransactionInput> | AvailedServiceCreateWithoutTransactionInput[] | AvailedServiceUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutTransactionInput | AvailedServiceCreateOrConnectWithoutTransactionInput[]
    createMany?: AvailedServiceCreateManyTransactionInputEnvelope
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
  }

  export type VoucherCreateNestedOneWithoutTransactionInput = {
    create?: XOR<VoucherCreateWithoutTransactionInput, VoucherUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutTransactionInput
    connect?: VoucherWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutTransactionInput = {
    create?: XOR<BranchCreateWithoutTransactionInput, BranchUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: BranchCreateOrConnectWithoutTransactionInput
    connect?: BranchWhereUniqueInput
  }

  export type GiftCertificateCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<GiftCertificateCreateWithoutTransactionsInput, GiftCertificateUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: GiftCertificateCreateOrConnectWithoutTransactionsInput
    connect?: GiftCertificateWhereUniqueInput
  }

  export type RecommendedAppointmentCreateNestedManyWithoutOriginatingTransactionInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutOriginatingTransactionInput, RecommendedAppointmentUncheckedCreateWithoutOriginatingTransactionInput> | RecommendedAppointmentCreateWithoutOriginatingTransactionInput[] | RecommendedAppointmentUncheckedCreateWithoutOriginatingTransactionInput[]
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutOriginatingTransactionInput | RecommendedAppointmentCreateOrConnectWithoutOriginatingTransactionInput[]
    createMany?: RecommendedAppointmentCreateManyOriginatingTransactionInputEnvelope
    connect?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
  }

  export type RecommendedAppointmentCreateNestedOneWithoutAttendedTransactionInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutAttendedTransactionInput, RecommendedAppointmentUncheckedCreateWithoutAttendedTransactionInput>
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutAttendedTransactionInput
    connect?: RecommendedAppointmentWhereUniqueInput
  }

  export type AvailedServiceUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<AvailedServiceCreateWithoutTransactionInput, AvailedServiceUncheckedCreateWithoutTransactionInput> | AvailedServiceCreateWithoutTransactionInput[] | AvailedServiceUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutTransactionInput | AvailedServiceCreateOrConnectWithoutTransactionInput[]
    createMany?: AvailedServiceCreateManyTransactionInputEnvelope
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
  }

  export type RecommendedAppointmentUncheckedCreateNestedManyWithoutOriginatingTransactionInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutOriginatingTransactionInput, RecommendedAppointmentUncheckedCreateWithoutOriginatingTransactionInput> | RecommendedAppointmentCreateWithoutOriginatingTransactionInput[] | RecommendedAppointmentUncheckedCreateWithoutOriginatingTransactionInput[]
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutOriginatingTransactionInput | RecommendedAppointmentCreateOrConnectWithoutOriginatingTransactionInput[]
    createMany?: RecommendedAppointmentCreateManyOriginatingTransactionInputEnvelope
    connect?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
  }

  export type RecommendedAppointmentUncheckedCreateNestedOneWithoutAttendedTransactionInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutAttendedTransactionInput, RecommendedAppointmentUncheckedCreateWithoutAttendedTransactionInput>
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutAttendedTransactionInput
    connect?: RecommendedAppointmentWhereUniqueInput
  }

  export type NullableEnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod | null
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type CustomerUpdateOneRequiredWithoutTransactionHistoryNestedInput = {
    create?: XOR<CustomerCreateWithoutTransactionHistoryInput, CustomerUncheckedCreateWithoutTransactionHistoryInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionHistoryInput
    upsert?: CustomerUpsertWithoutTransactionHistoryInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutTransactionHistoryInput, CustomerUpdateWithoutTransactionHistoryInput>, CustomerUncheckedUpdateWithoutTransactionHistoryInput>
  }

  export type AvailedServiceUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<AvailedServiceCreateWithoutTransactionInput, AvailedServiceUncheckedCreateWithoutTransactionInput> | AvailedServiceCreateWithoutTransactionInput[] | AvailedServiceUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutTransactionInput | AvailedServiceCreateOrConnectWithoutTransactionInput[]
    upsert?: AvailedServiceUpsertWithWhereUniqueWithoutTransactionInput | AvailedServiceUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: AvailedServiceCreateManyTransactionInputEnvelope
    set?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    disconnect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    delete?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    update?: AvailedServiceUpdateWithWhereUniqueWithoutTransactionInput | AvailedServiceUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: AvailedServiceUpdateManyWithWhereWithoutTransactionInput | AvailedServiceUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: AvailedServiceScalarWhereInput | AvailedServiceScalarWhereInput[]
  }

  export type VoucherUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<VoucherCreateWithoutTransactionInput, VoucherUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutTransactionInput
    upsert?: VoucherUpsertWithoutTransactionInput
    disconnect?: VoucherWhereInput | boolean
    delete?: VoucherWhereInput | boolean
    connect?: VoucherWhereUniqueInput
    update?: XOR<XOR<VoucherUpdateToOneWithWhereWithoutTransactionInput, VoucherUpdateWithoutTransactionInput>, VoucherUncheckedUpdateWithoutTransactionInput>
  }

  export type BranchUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<BranchCreateWithoutTransactionInput, BranchUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: BranchCreateOrConnectWithoutTransactionInput
    upsert?: BranchUpsertWithoutTransactionInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutTransactionInput, BranchUpdateWithoutTransactionInput>, BranchUncheckedUpdateWithoutTransactionInput>
  }

  export type GiftCertificateUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<GiftCertificateCreateWithoutTransactionsInput, GiftCertificateUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: GiftCertificateCreateOrConnectWithoutTransactionsInput
    upsert?: GiftCertificateUpsertWithoutTransactionsInput
    disconnect?: GiftCertificateWhereInput | boolean
    delete?: GiftCertificateWhereInput | boolean
    connect?: GiftCertificateWhereUniqueInput
    update?: XOR<XOR<GiftCertificateUpdateToOneWithWhereWithoutTransactionsInput, GiftCertificateUpdateWithoutTransactionsInput>, GiftCertificateUncheckedUpdateWithoutTransactionsInput>
  }

  export type RecommendedAppointmentUpdateManyWithoutOriginatingTransactionNestedInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutOriginatingTransactionInput, RecommendedAppointmentUncheckedCreateWithoutOriginatingTransactionInput> | RecommendedAppointmentCreateWithoutOriginatingTransactionInput[] | RecommendedAppointmentUncheckedCreateWithoutOriginatingTransactionInput[]
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutOriginatingTransactionInput | RecommendedAppointmentCreateOrConnectWithoutOriginatingTransactionInput[]
    upsert?: RecommendedAppointmentUpsertWithWhereUniqueWithoutOriginatingTransactionInput | RecommendedAppointmentUpsertWithWhereUniqueWithoutOriginatingTransactionInput[]
    createMany?: RecommendedAppointmentCreateManyOriginatingTransactionInputEnvelope
    set?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    disconnect?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    delete?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    connect?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    update?: RecommendedAppointmentUpdateWithWhereUniqueWithoutOriginatingTransactionInput | RecommendedAppointmentUpdateWithWhereUniqueWithoutOriginatingTransactionInput[]
    updateMany?: RecommendedAppointmentUpdateManyWithWhereWithoutOriginatingTransactionInput | RecommendedAppointmentUpdateManyWithWhereWithoutOriginatingTransactionInput[]
    deleteMany?: RecommendedAppointmentScalarWhereInput | RecommendedAppointmentScalarWhereInput[]
  }

  export type RecommendedAppointmentUpdateOneWithoutAttendedTransactionNestedInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutAttendedTransactionInput, RecommendedAppointmentUncheckedCreateWithoutAttendedTransactionInput>
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutAttendedTransactionInput
    upsert?: RecommendedAppointmentUpsertWithoutAttendedTransactionInput
    disconnect?: RecommendedAppointmentWhereInput | boolean
    delete?: RecommendedAppointmentWhereInput | boolean
    connect?: RecommendedAppointmentWhereUniqueInput
    update?: XOR<XOR<RecommendedAppointmentUpdateToOneWithWhereWithoutAttendedTransactionInput, RecommendedAppointmentUpdateWithoutAttendedTransactionInput>, RecommendedAppointmentUncheckedUpdateWithoutAttendedTransactionInput>
  }

  export type AvailedServiceUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<AvailedServiceCreateWithoutTransactionInput, AvailedServiceUncheckedCreateWithoutTransactionInput> | AvailedServiceCreateWithoutTransactionInput[] | AvailedServiceUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: AvailedServiceCreateOrConnectWithoutTransactionInput | AvailedServiceCreateOrConnectWithoutTransactionInput[]
    upsert?: AvailedServiceUpsertWithWhereUniqueWithoutTransactionInput | AvailedServiceUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: AvailedServiceCreateManyTransactionInputEnvelope
    set?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    disconnect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    delete?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    connect?: AvailedServiceWhereUniqueInput | AvailedServiceWhereUniqueInput[]
    update?: AvailedServiceUpdateWithWhereUniqueWithoutTransactionInput | AvailedServiceUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: AvailedServiceUpdateManyWithWhereWithoutTransactionInput | AvailedServiceUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: AvailedServiceScalarWhereInput | AvailedServiceScalarWhereInput[]
  }

  export type RecommendedAppointmentUncheckedUpdateManyWithoutOriginatingTransactionNestedInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutOriginatingTransactionInput, RecommendedAppointmentUncheckedCreateWithoutOriginatingTransactionInput> | RecommendedAppointmentCreateWithoutOriginatingTransactionInput[] | RecommendedAppointmentUncheckedCreateWithoutOriginatingTransactionInput[]
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutOriginatingTransactionInput | RecommendedAppointmentCreateOrConnectWithoutOriginatingTransactionInput[]
    upsert?: RecommendedAppointmentUpsertWithWhereUniqueWithoutOriginatingTransactionInput | RecommendedAppointmentUpsertWithWhereUniqueWithoutOriginatingTransactionInput[]
    createMany?: RecommendedAppointmentCreateManyOriginatingTransactionInputEnvelope
    set?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    disconnect?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    delete?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    connect?: RecommendedAppointmentWhereUniqueInput | RecommendedAppointmentWhereUniqueInput[]
    update?: RecommendedAppointmentUpdateWithWhereUniqueWithoutOriginatingTransactionInput | RecommendedAppointmentUpdateWithWhereUniqueWithoutOriginatingTransactionInput[]
    updateMany?: RecommendedAppointmentUpdateManyWithWhereWithoutOriginatingTransactionInput | RecommendedAppointmentUpdateManyWithWhereWithoutOriginatingTransactionInput[]
    deleteMany?: RecommendedAppointmentScalarWhereInput | RecommendedAppointmentScalarWhereInput[]
  }

  export type RecommendedAppointmentUncheckedUpdateOneWithoutAttendedTransactionNestedInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutAttendedTransactionInput, RecommendedAppointmentUncheckedCreateWithoutAttendedTransactionInput>
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutAttendedTransactionInput
    upsert?: RecommendedAppointmentUpsertWithoutAttendedTransactionInput
    disconnect?: RecommendedAppointmentWhereInput | boolean
    delete?: RecommendedAppointmentWhereInput | boolean
    connect?: RecommendedAppointmentWhereUniqueInput
    update?: XOR<XOR<RecommendedAppointmentUpdateToOneWithWhereWithoutAttendedTransactionInput, RecommendedAppointmentUpdateWithoutAttendedTransactionInput>, RecommendedAppointmentUncheckedUpdateWithoutAttendedTransactionInput>
  }

  export type TransactionCreateNestedOneWithoutAvailedServicesInput = {
    create?: XOR<TransactionCreateWithoutAvailedServicesInput, TransactionUncheckedCreateWithoutAvailedServicesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutAvailedServicesInput
    connect?: TransactionWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutAvailedServiceInput = {
    create?: XOR<ServiceCreateWithoutAvailedServiceInput, ServiceUncheckedCreateWithoutAvailedServiceInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAvailedServiceInput
    connect?: ServiceWhereUniqueInput
  }

  export type ServiceSetCreateNestedOneWithoutAvailedServiceInput = {
    create?: XOR<ServiceSetCreateWithoutAvailedServiceInput, ServiceSetUncheckedCreateWithoutAvailedServiceInput>
    connectOrCreate?: ServiceSetCreateOrConnectWithoutAvailedServiceInput
    connect?: ServiceSetWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutServicesCheckedInput = {
    create?: XOR<AccountCreateWithoutServicesCheckedInput, AccountUncheckedCreateWithoutServicesCheckedInput>
    connectOrCreate?: AccountCreateOrConnectWithoutServicesCheckedInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutServicesServedInput = {
    create?: XOR<AccountCreateWithoutServicesServedInput, AccountUncheckedCreateWithoutServicesServedInput>
    connectOrCreate?: AccountCreateOrConnectWithoutServicesServedInput
    connect?: AccountWhereUniqueInput
  }

  export type RecommendedAppointmentCreateNestedOneWithoutOriginatingAvailedServiceInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutOriginatingAvailedServiceInput, RecommendedAppointmentUncheckedCreateWithoutOriginatingAvailedServiceInput>
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutOriginatingAvailedServiceInput
    connect?: RecommendedAppointmentWhereUniqueInput
  }

  export type RecommendedAppointmentUncheckedCreateNestedOneWithoutOriginatingAvailedServiceInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutOriginatingAvailedServiceInput, RecommendedAppointmentUncheckedCreateWithoutOriginatingAvailedServiceInput>
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutOriginatingAvailedServiceInput
    connect?: RecommendedAppointmentWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutAvailedServicesNestedInput = {
    create?: XOR<TransactionCreateWithoutAvailedServicesInput, TransactionUncheckedCreateWithoutAvailedServicesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutAvailedServicesInput
    upsert?: TransactionUpsertWithoutAvailedServicesInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutAvailedServicesInput, TransactionUpdateWithoutAvailedServicesInput>, TransactionUncheckedUpdateWithoutAvailedServicesInput>
  }

  export type ServiceUpdateOneWithoutAvailedServiceNestedInput = {
    create?: XOR<ServiceCreateWithoutAvailedServiceInput, ServiceUncheckedCreateWithoutAvailedServiceInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAvailedServiceInput
    upsert?: ServiceUpsertWithoutAvailedServiceInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutAvailedServiceInput, ServiceUpdateWithoutAvailedServiceInput>, ServiceUncheckedUpdateWithoutAvailedServiceInput>
  }

  export type ServiceSetUpdateOneWithoutAvailedServiceNestedInput = {
    create?: XOR<ServiceSetCreateWithoutAvailedServiceInput, ServiceSetUncheckedCreateWithoutAvailedServiceInput>
    connectOrCreate?: ServiceSetCreateOrConnectWithoutAvailedServiceInput
    upsert?: ServiceSetUpsertWithoutAvailedServiceInput
    disconnect?: ServiceSetWhereInput | boolean
    delete?: ServiceSetWhereInput | boolean
    connect?: ServiceSetWhereUniqueInput
    update?: XOR<XOR<ServiceSetUpdateToOneWithWhereWithoutAvailedServiceInput, ServiceSetUpdateWithoutAvailedServiceInput>, ServiceSetUncheckedUpdateWithoutAvailedServiceInput>
  }

  export type AccountUpdateOneWithoutServicesCheckedNestedInput = {
    create?: XOR<AccountCreateWithoutServicesCheckedInput, AccountUncheckedCreateWithoutServicesCheckedInput>
    connectOrCreate?: AccountCreateOrConnectWithoutServicesCheckedInput
    upsert?: AccountUpsertWithoutServicesCheckedInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutServicesCheckedInput, AccountUpdateWithoutServicesCheckedInput>, AccountUncheckedUpdateWithoutServicesCheckedInput>
  }

  export type AccountUpdateOneWithoutServicesServedNestedInput = {
    create?: XOR<AccountCreateWithoutServicesServedInput, AccountUncheckedCreateWithoutServicesServedInput>
    connectOrCreate?: AccountCreateOrConnectWithoutServicesServedInput
    upsert?: AccountUpsertWithoutServicesServedInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutServicesServedInput, AccountUpdateWithoutServicesServedInput>, AccountUncheckedUpdateWithoutServicesServedInput>
  }

  export type RecommendedAppointmentUpdateOneWithoutOriginatingAvailedServiceNestedInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutOriginatingAvailedServiceInput, RecommendedAppointmentUncheckedCreateWithoutOriginatingAvailedServiceInput>
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutOriginatingAvailedServiceInput
    upsert?: RecommendedAppointmentUpsertWithoutOriginatingAvailedServiceInput
    disconnect?: RecommendedAppointmentWhereInput | boolean
    delete?: RecommendedAppointmentWhereInput | boolean
    connect?: RecommendedAppointmentWhereUniqueInput
    update?: XOR<XOR<RecommendedAppointmentUpdateToOneWithWhereWithoutOriginatingAvailedServiceInput, RecommendedAppointmentUpdateWithoutOriginatingAvailedServiceInput>, RecommendedAppointmentUncheckedUpdateWithoutOriginatingAvailedServiceInput>
  }

  export type RecommendedAppointmentUncheckedUpdateOneWithoutOriginatingAvailedServiceNestedInput = {
    create?: XOR<RecommendedAppointmentCreateWithoutOriginatingAvailedServiceInput, RecommendedAppointmentUncheckedCreateWithoutOriginatingAvailedServiceInput>
    connectOrCreate?: RecommendedAppointmentCreateOrConnectWithoutOriginatingAvailedServiceInput
    upsert?: RecommendedAppointmentUpsertWithoutOriginatingAvailedServiceInput
    disconnect?: RecommendedAppointmentWhereInput | boolean
    delete?: RecommendedAppointmentWhereInput | boolean
    connect?: RecommendedAppointmentWhereUniqueInput
    update?: XOR<XOR<RecommendedAppointmentUpdateToOneWithWhereWithoutOriginatingAvailedServiceInput, RecommendedAppointmentUpdateWithoutOriginatingAvailedServiceInput>, RecommendedAppointmentUncheckedUpdateWithoutOriginatingAvailedServiceInput>
  }

  export type CustomerCreateNestedOneWithoutPurchasedGiftCertificatesInput = {
    create?: XOR<CustomerCreateWithoutPurchasedGiftCertificatesInput, CustomerUncheckedCreateWithoutPurchasedGiftCertificatesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPurchasedGiftCertificatesInput
    connect?: CustomerWhereUniqueInput
  }

  export type ServiceCreateNestedManyWithoutGiftCertificatesInput = {
    create?: XOR<ServiceCreateWithoutGiftCertificatesInput, ServiceUncheckedCreateWithoutGiftCertificatesInput> | ServiceCreateWithoutGiftCertificatesInput[] | ServiceUncheckedCreateWithoutGiftCertificatesInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutGiftCertificatesInput | ServiceCreateOrConnectWithoutGiftCertificatesInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceSetCreateNestedManyWithoutGiftCertificatesInput = {
    create?: XOR<ServiceSetCreateWithoutGiftCertificatesInput, ServiceSetUncheckedCreateWithoutGiftCertificatesInput> | ServiceSetCreateWithoutGiftCertificatesInput[] | ServiceSetUncheckedCreateWithoutGiftCertificatesInput[]
    connectOrCreate?: ServiceSetCreateOrConnectWithoutGiftCertificatesInput | ServiceSetCreateOrConnectWithoutGiftCertificatesInput[]
    connect?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutGiftCertificateUsedInput = {
    create?: XOR<TransactionCreateWithoutGiftCertificateUsedInput, TransactionUncheckedCreateWithoutGiftCertificateUsedInput> | TransactionCreateWithoutGiftCertificateUsedInput[] | TransactionUncheckedCreateWithoutGiftCertificateUsedInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGiftCertificateUsedInput | TransactionCreateOrConnectWithoutGiftCertificateUsedInput[]
    createMany?: TransactionCreateManyGiftCertificateUsedInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutGiftCertificatesInput = {
    create?: XOR<ServiceCreateWithoutGiftCertificatesInput, ServiceUncheckedCreateWithoutGiftCertificatesInput> | ServiceCreateWithoutGiftCertificatesInput[] | ServiceUncheckedCreateWithoutGiftCertificatesInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutGiftCertificatesInput | ServiceCreateOrConnectWithoutGiftCertificatesInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceSetUncheckedCreateNestedManyWithoutGiftCertificatesInput = {
    create?: XOR<ServiceSetCreateWithoutGiftCertificatesInput, ServiceSetUncheckedCreateWithoutGiftCertificatesInput> | ServiceSetCreateWithoutGiftCertificatesInput[] | ServiceSetUncheckedCreateWithoutGiftCertificatesInput[]
    connectOrCreate?: ServiceSetCreateOrConnectWithoutGiftCertificatesInput | ServiceSetCreateOrConnectWithoutGiftCertificatesInput[]
    connect?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutGiftCertificateUsedInput = {
    create?: XOR<TransactionCreateWithoutGiftCertificateUsedInput, TransactionUncheckedCreateWithoutGiftCertificateUsedInput> | TransactionCreateWithoutGiftCertificateUsedInput[] | TransactionUncheckedCreateWithoutGiftCertificateUsedInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGiftCertificateUsedInput | TransactionCreateOrConnectWithoutGiftCertificateUsedInput[]
    createMany?: TransactionCreateManyGiftCertificateUsedInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type CustomerUpdateOneWithoutPurchasedGiftCertificatesNestedInput = {
    create?: XOR<CustomerCreateWithoutPurchasedGiftCertificatesInput, CustomerUncheckedCreateWithoutPurchasedGiftCertificatesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPurchasedGiftCertificatesInput
    upsert?: CustomerUpsertWithoutPurchasedGiftCertificatesInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPurchasedGiftCertificatesInput, CustomerUpdateWithoutPurchasedGiftCertificatesInput>, CustomerUncheckedUpdateWithoutPurchasedGiftCertificatesInput>
  }

  export type ServiceUpdateManyWithoutGiftCertificatesNestedInput = {
    create?: XOR<ServiceCreateWithoutGiftCertificatesInput, ServiceUncheckedCreateWithoutGiftCertificatesInput> | ServiceCreateWithoutGiftCertificatesInput[] | ServiceUncheckedCreateWithoutGiftCertificatesInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutGiftCertificatesInput | ServiceCreateOrConnectWithoutGiftCertificatesInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutGiftCertificatesInput | ServiceUpsertWithWhereUniqueWithoutGiftCertificatesInput[]
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutGiftCertificatesInput | ServiceUpdateWithWhereUniqueWithoutGiftCertificatesInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutGiftCertificatesInput | ServiceUpdateManyWithWhereWithoutGiftCertificatesInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceSetUpdateManyWithoutGiftCertificatesNestedInput = {
    create?: XOR<ServiceSetCreateWithoutGiftCertificatesInput, ServiceSetUncheckedCreateWithoutGiftCertificatesInput> | ServiceSetCreateWithoutGiftCertificatesInput[] | ServiceSetUncheckedCreateWithoutGiftCertificatesInput[]
    connectOrCreate?: ServiceSetCreateOrConnectWithoutGiftCertificatesInput | ServiceSetCreateOrConnectWithoutGiftCertificatesInput[]
    upsert?: ServiceSetUpsertWithWhereUniqueWithoutGiftCertificatesInput | ServiceSetUpsertWithWhereUniqueWithoutGiftCertificatesInput[]
    set?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
    disconnect?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
    delete?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
    connect?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
    update?: ServiceSetUpdateWithWhereUniqueWithoutGiftCertificatesInput | ServiceSetUpdateWithWhereUniqueWithoutGiftCertificatesInput[]
    updateMany?: ServiceSetUpdateManyWithWhereWithoutGiftCertificatesInput | ServiceSetUpdateManyWithWhereWithoutGiftCertificatesInput[]
    deleteMany?: ServiceSetScalarWhereInput | ServiceSetScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutGiftCertificateUsedNestedInput = {
    create?: XOR<TransactionCreateWithoutGiftCertificateUsedInput, TransactionUncheckedCreateWithoutGiftCertificateUsedInput> | TransactionCreateWithoutGiftCertificateUsedInput[] | TransactionUncheckedCreateWithoutGiftCertificateUsedInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGiftCertificateUsedInput | TransactionCreateOrConnectWithoutGiftCertificateUsedInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutGiftCertificateUsedInput | TransactionUpsertWithWhereUniqueWithoutGiftCertificateUsedInput[]
    createMany?: TransactionCreateManyGiftCertificateUsedInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutGiftCertificateUsedInput | TransactionUpdateWithWhereUniqueWithoutGiftCertificateUsedInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutGiftCertificateUsedInput | TransactionUpdateManyWithWhereWithoutGiftCertificateUsedInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutGiftCertificatesNestedInput = {
    create?: XOR<ServiceCreateWithoutGiftCertificatesInput, ServiceUncheckedCreateWithoutGiftCertificatesInput> | ServiceCreateWithoutGiftCertificatesInput[] | ServiceUncheckedCreateWithoutGiftCertificatesInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutGiftCertificatesInput | ServiceCreateOrConnectWithoutGiftCertificatesInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutGiftCertificatesInput | ServiceUpsertWithWhereUniqueWithoutGiftCertificatesInput[]
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutGiftCertificatesInput | ServiceUpdateWithWhereUniqueWithoutGiftCertificatesInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutGiftCertificatesInput | ServiceUpdateManyWithWhereWithoutGiftCertificatesInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceSetUncheckedUpdateManyWithoutGiftCertificatesNestedInput = {
    create?: XOR<ServiceSetCreateWithoutGiftCertificatesInput, ServiceSetUncheckedCreateWithoutGiftCertificatesInput> | ServiceSetCreateWithoutGiftCertificatesInput[] | ServiceSetUncheckedCreateWithoutGiftCertificatesInput[]
    connectOrCreate?: ServiceSetCreateOrConnectWithoutGiftCertificatesInput | ServiceSetCreateOrConnectWithoutGiftCertificatesInput[]
    upsert?: ServiceSetUpsertWithWhereUniqueWithoutGiftCertificatesInput | ServiceSetUpsertWithWhereUniqueWithoutGiftCertificatesInput[]
    set?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
    disconnect?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
    delete?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
    connect?: ServiceSetWhereUniqueInput | ServiceSetWhereUniqueInput[]
    update?: ServiceSetUpdateWithWhereUniqueWithoutGiftCertificatesInput | ServiceSetUpdateWithWhereUniqueWithoutGiftCertificatesInput[]
    updateMany?: ServiceSetUpdateManyWithWhereWithoutGiftCertificatesInput | ServiceSetUpdateManyWithWhereWithoutGiftCertificatesInput[]
    deleteMany?: ServiceSetScalarWhereInput | ServiceSetScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutGiftCertificateUsedNestedInput = {
    create?: XOR<TransactionCreateWithoutGiftCertificateUsedInput, TransactionUncheckedCreateWithoutGiftCertificateUsedInput> | TransactionCreateWithoutGiftCertificateUsedInput[] | TransactionUncheckedCreateWithoutGiftCertificateUsedInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGiftCertificateUsedInput | TransactionCreateOrConnectWithoutGiftCertificateUsedInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutGiftCertificateUsedInput | TransactionUpsertWithWhereUniqueWithoutGiftCertificateUsedInput[]
    createMany?: TransactionCreateManyGiftCertificateUsedInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutGiftCertificateUsedInput | TransactionUpdateWithWhereUniqueWithoutGiftCertificateUsedInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutGiftCertificateUsedInput | TransactionUpdateManyWithWhereWithoutGiftCertificateUsedInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutManualSalesInput = {
    create?: XOR<AccountCreateWithoutManualSalesInput, AccountUncheckedCreateWithoutManualSalesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutManualSalesInput
    connect?: AccountWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutManualSalesInput = {
    create?: XOR<BranchCreateWithoutManualSalesInput, BranchUncheckedCreateWithoutManualSalesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutManualSalesInput
    connect?: BranchWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutManualSalesNestedInput = {
    create?: XOR<AccountCreateWithoutManualSalesInput, AccountUncheckedCreateWithoutManualSalesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutManualSalesInput
    upsert?: AccountUpsertWithoutManualSalesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutManualSalesInput, AccountUpdateWithoutManualSalesInput>, AccountUncheckedUpdateWithoutManualSalesInput>
  }

  export type BranchUpdateOneWithoutManualSalesNestedInput = {
    create?: XOR<BranchCreateWithoutManualSalesInput, BranchUncheckedCreateWithoutManualSalesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutManualSalesInput
    upsert?: BranchUpsertWithoutManualSalesInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutManualSalesInput, BranchUpdateWithoutManualSalesInput>, BranchUncheckedUpdateWithoutManualSalesInput>
  }

  export type AccountCreateNestedOneWithoutExpensesInput = {
    create?: XOR<AccountCreateWithoutExpensesInput, AccountUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutExpensesInput
    connect?: AccountWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutExpensesInput = {
    create?: XOR<BranchCreateWithoutExpensesInput, BranchUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutExpensesInput
    connect?: BranchWhereUniqueInput
  }

  export type EnumExpenseCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ExpenseCategory
  }

  export type AccountUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<AccountCreateWithoutExpensesInput, AccountUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutExpensesInput
    upsert?: AccountUpsertWithoutExpensesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutExpensesInput, AccountUpdateWithoutExpensesInput>, AccountUncheckedUpdateWithoutExpensesInput>
  }

  export type BranchUpdateOneWithoutExpensesNestedInput = {
    create?: XOR<BranchCreateWithoutExpensesInput, BranchUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutExpensesInput
    upsert?: BranchUpsertWithoutExpensesInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutExpensesInput, BranchUpdateWithoutExpensesInput>, BranchUncheckedUpdateWithoutExpensesInput>
  }

  export type EmailTemplateCreateplaceholdersInput = {
    set: string[]
  }

  export type EmailTemplateUpdateplaceholdersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumPayslipRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayslipRequestStatus | EnumPayslipRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayslipRequestStatus[] | ListEnumPayslipRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayslipRequestStatus[] | ListEnumPayslipRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayslipRequestStatusFilter<$PrismaModel> | $Enums.PayslipRequestStatus
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumPayslipRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayslipRequestStatus | EnumPayslipRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayslipRequestStatus[] | ListEnumPayslipRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayslipRequestStatus[] | ListEnumPayslipRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayslipRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayslipRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayslipRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumPayslipRequestStatusFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPayslipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayslipStatus | EnumPayslipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayslipStatus[] | ListEnumPayslipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayslipStatus[] | ListEnumPayslipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayslipStatusFilter<$PrismaModel> | $Enums.PayslipStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumPayslipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayslipStatus | EnumPayslipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayslipStatus[] | ListEnumPayslipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayslipStatus[] | ListEnumPayslipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayslipStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayslipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayslipStatusFilter<$PrismaModel>
    _max?: NestedEnumPayslipStatusFilter<$PrismaModel>
  }

  export type NestedEnumRecommendedAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RecommendedAppointmentStatus | EnumRecommendedAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecommendedAppointmentStatus[] | ListEnumRecommendedAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecommendedAppointmentStatus[] | ListEnumRecommendedAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecommendedAppointmentStatusFilter<$PrismaModel> | $Enums.RecommendedAppointmentStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumRecommendedAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecommendedAppointmentStatus | EnumRecommendedAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecommendedAppointmentStatus[] | ListEnumRecommendedAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecommendedAppointmentStatus[] | ListEnumRecommendedAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecommendedAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.RecommendedAppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecommendedAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumRecommendedAppointmentStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumFollowUpPolicyFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowUpPolicy | EnumFollowUpPolicyFieldRefInput<$PrismaModel>
    in?: $Enums.FollowUpPolicy[] | ListEnumFollowUpPolicyFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowUpPolicy[] | ListEnumFollowUpPolicyFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowUpPolicyFilter<$PrismaModel> | $Enums.FollowUpPolicy
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumFollowUpPolicyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowUpPolicy | EnumFollowUpPolicyFieldRefInput<$PrismaModel>
    in?: $Enums.FollowUpPolicy[] | ListEnumFollowUpPolicyFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowUpPolicy[] | ListEnumFollowUpPolicyFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowUpPolicyWithAggregatesFilter<$PrismaModel> | $Enums.FollowUpPolicy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFollowUpPolicyFilter<$PrismaModel>
    _max?: NestedEnumFollowUpPolicyFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedEnumExpenseCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseCategoryFilter<$PrismaModel> | $Enums.ExpenseCategory
  }

  export type NestedEnumExpenseCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseCategoryFilter<$PrismaModel>
    _max?: NestedEnumExpenseCategoryFilter<$PrismaModel>
  }

  export type AccountCreateWithoutPayslipRequestsInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    branch?: BranchCreateNestedOneWithoutAccountsInput
    servicesServed?: AvailedServiceCreateNestedManyWithoutServedByInput
    servicesChecked?: AvailedServiceCreateNestedManyWithoutCheckedByInput
    attendances?: AttendanceCreateNestedManyWithoutAccountInput
    attendancesChecked?: AttendanceCreateNestedManyWithoutCheckedByInput
    payslips?: PayslipCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestCreateNestedManyWithoutProcessedByInput
    manualSales?: ManualSaleCreateNestedManyWithoutRecordedByInput
    expenses?: ExpenseCreateNestedManyWithoutRecordedByInput
  }

  export type AccountUncheckedCreateWithoutPayslipRequestsInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    branchId?: string | null
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    servicesServed?: AvailedServiceUncheckedCreateNestedManyWithoutServedByInput
    servicesChecked?: AvailedServiceUncheckedCreateNestedManyWithoutCheckedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutAccountInput
    attendancesChecked?: AttendanceUncheckedCreateNestedManyWithoutCheckedByInput
    payslips?: PayslipUncheckedCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutProcessedByInput
    manualSales?: ManualSaleUncheckedCreateNestedManyWithoutRecordedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type AccountCreateOrConnectWithoutPayslipRequestsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutPayslipRequestsInput, AccountUncheckedCreateWithoutPayslipRequestsInput>
  }

  export type AccountCreateWithoutManagedPayslipRequestsInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    branch?: BranchCreateNestedOneWithoutAccountsInput
    servicesServed?: AvailedServiceCreateNestedManyWithoutServedByInput
    servicesChecked?: AvailedServiceCreateNestedManyWithoutCheckedByInput
    attendances?: AttendanceCreateNestedManyWithoutAccountInput
    attendancesChecked?: AttendanceCreateNestedManyWithoutCheckedByInput
    payslips?: PayslipCreateNestedManyWithoutAccountInput
    payslipRequests?: PayslipRequestCreateNestedManyWithoutAccountInput
    manualSales?: ManualSaleCreateNestedManyWithoutRecordedByInput
    expenses?: ExpenseCreateNestedManyWithoutRecordedByInput
  }

  export type AccountUncheckedCreateWithoutManagedPayslipRequestsInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    branchId?: string | null
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    servicesServed?: AvailedServiceUncheckedCreateNestedManyWithoutServedByInput
    servicesChecked?: AvailedServiceUncheckedCreateNestedManyWithoutCheckedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutAccountInput
    attendancesChecked?: AttendanceUncheckedCreateNestedManyWithoutCheckedByInput
    payslips?: PayslipUncheckedCreateNestedManyWithoutAccountInput
    payslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutAccountInput
    manualSales?: ManualSaleUncheckedCreateNestedManyWithoutRecordedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type AccountCreateOrConnectWithoutManagedPayslipRequestsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutManagedPayslipRequestsInput, AccountUncheckedCreateWithoutManagedPayslipRequestsInput>
  }

  export type PayslipCreateWithoutPayslipRequestInput = {
    id?: string
    periodStartDate: Date | string
    periodEndDate: Date | string
    baseSalary: number
    totalCommissions: number
    totalDeductions?: number
    totalBonuses?: number
    netPay: number
    status?: $Enums.PayslipStatus
    releasedDate?: Date | string | null
    generatedAt?: Date | string
    account: AccountCreateNestedOneWithoutPayslipsInput
  }

  export type PayslipUncheckedCreateWithoutPayslipRequestInput = {
    id?: string
    accountId: string
    periodStartDate: Date | string
    periodEndDate: Date | string
    baseSalary: number
    totalCommissions: number
    totalDeductions?: number
    totalBonuses?: number
    netPay: number
    status?: $Enums.PayslipStatus
    releasedDate?: Date | string | null
    generatedAt?: Date | string
  }

  export type PayslipCreateOrConnectWithoutPayslipRequestInput = {
    where: PayslipWhereUniqueInput
    create: XOR<PayslipCreateWithoutPayslipRequestInput, PayslipUncheckedCreateWithoutPayslipRequestInput>
  }

  export type AccountUpsertWithoutPayslipRequestsInput = {
    update: XOR<AccountUpdateWithoutPayslipRequestsInput, AccountUncheckedUpdateWithoutPayslipRequestsInput>
    create: XOR<AccountCreateWithoutPayslipRequestsInput, AccountUncheckedCreateWithoutPayslipRequestsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutPayslipRequestsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutPayslipRequestsInput, AccountUncheckedUpdateWithoutPayslipRequestsInput>
  }

  export type AccountUpdateWithoutPayslipRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    branch?: BranchUpdateOneWithoutAccountsNestedInput
    servicesServed?: AvailedServiceUpdateManyWithoutServedByNestedInput
    servicesChecked?: AvailedServiceUpdateManyWithoutCheckedByNestedInput
    attendances?: AttendanceUpdateManyWithoutAccountNestedInput
    attendancesChecked?: AttendanceUpdateManyWithoutCheckedByNestedInput
    payslips?: PayslipUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUpdateManyWithoutProcessedByNestedInput
    manualSales?: ManualSaleUpdateManyWithoutRecordedByNestedInput
    expenses?: ExpenseUpdateManyWithoutRecordedByNestedInput
  }

  export type AccountUncheckedUpdateWithoutPayslipRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    servicesServed?: AvailedServiceUncheckedUpdateManyWithoutServedByNestedInput
    servicesChecked?: AvailedServiceUncheckedUpdateManyWithoutCheckedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutAccountNestedInput
    attendancesChecked?: AttendanceUncheckedUpdateManyWithoutCheckedByNestedInput
    payslips?: PayslipUncheckedUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    manualSales?: ManualSaleUncheckedUpdateManyWithoutRecordedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type AccountUpsertWithoutManagedPayslipRequestsInput = {
    update: XOR<AccountUpdateWithoutManagedPayslipRequestsInput, AccountUncheckedUpdateWithoutManagedPayslipRequestsInput>
    create: XOR<AccountCreateWithoutManagedPayslipRequestsInput, AccountUncheckedCreateWithoutManagedPayslipRequestsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutManagedPayslipRequestsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutManagedPayslipRequestsInput, AccountUncheckedUpdateWithoutManagedPayslipRequestsInput>
  }

  export type AccountUpdateWithoutManagedPayslipRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    branch?: BranchUpdateOneWithoutAccountsNestedInput
    servicesServed?: AvailedServiceUpdateManyWithoutServedByNestedInput
    servicesChecked?: AvailedServiceUpdateManyWithoutCheckedByNestedInput
    attendances?: AttendanceUpdateManyWithoutAccountNestedInput
    attendancesChecked?: AttendanceUpdateManyWithoutCheckedByNestedInput
    payslips?: PayslipUpdateManyWithoutAccountNestedInput
    payslipRequests?: PayslipRequestUpdateManyWithoutAccountNestedInput
    manualSales?: ManualSaleUpdateManyWithoutRecordedByNestedInput
    expenses?: ExpenseUpdateManyWithoutRecordedByNestedInput
  }

  export type AccountUncheckedUpdateWithoutManagedPayslipRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    servicesServed?: AvailedServiceUncheckedUpdateManyWithoutServedByNestedInput
    servicesChecked?: AvailedServiceUncheckedUpdateManyWithoutCheckedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutAccountNestedInput
    attendancesChecked?: AttendanceUncheckedUpdateManyWithoutCheckedByNestedInput
    payslips?: PayslipUncheckedUpdateManyWithoutAccountNestedInput
    payslipRequests?: PayslipRequestUncheckedUpdateManyWithoutAccountNestedInput
    manualSales?: ManualSaleUncheckedUpdateManyWithoutRecordedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type PayslipUpsertWithoutPayslipRequestInput = {
    update: XOR<PayslipUpdateWithoutPayslipRequestInput, PayslipUncheckedUpdateWithoutPayslipRequestInput>
    create: XOR<PayslipCreateWithoutPayslipRequestInput, PayslipUncheckedCreateWithoutPayslipRequestInput>
    where?: PayslipWhereInput
  }

  export type PayslipUpdateToOneWithWhereWithoutPayslipRequestInput = {
    where?: PayslipWhereInput
    data: XOR<PayslipUpdateWithoutPayslipRequestInput, PayslipUncheckedUpdateWithoutPayslipRequestInput>
  }

  export type PayslipUpdateWithoutPayslipRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    baseSalary?: IntFieldUpdateOperationsInput | number
    totalCommissions?: IntFieldUpdateOperationsInput | number
    totalDeductions?: IntFieldUpdateOperationsInput | number
    totalBonuses?: IntFieldUpdateOperationsInput | number
    netPay?: IntFieldUpdateOperationsInput | number
    status?: EnumPayslipStatusFieldUpdateOperationsInput | $Enums.PayslipStatus
    releasedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutPayslipsNestedInput
  }

  export type PayslipUncheckedUpdateWithoutPayslipRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    baseSalary?: IntFieldUpdateOperationsInput | number
    totalCommissions?: IntFieldUpdateOperationsInput | number
    totalDeductions?: IntFieldUpdateOperationsInput | number
    totalBonuses?: IntFieldUpdateOperationsInput | number
    netPay?: IntFieldUpdateOperationsInput | number
    status?: EnumPayslipStatusFieldUpdateOperationsInput | $Enums.PayslipStatus
    releasedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateWithoutPayslipsInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    branch?: BranchCreateNestedOneWithoutAccountsInput
    servicesServed?: AvailedServiceCreateNestedManyWithoutServedByInput
    servicesChecked?: AvailedServiceCreateNestedManyWithoutCheckedByInput
    attendances?: AttendanceCreateNestedManyWithoutAccountInput
    attendancesChecked?: AttendanceCreateNestedManyWithoutCheckedByInput
    payslipRequests?: PayslipRequestCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestCreateNestedManyWithoutProcessedByInput
    manualSales?: ManualSaleCreateNestedManyWithoutRecordedByInput
    expenses?: ExpenseCreateNestedManyWithoutRecordedByInput
  }

  export type AccountUncheckedCreateWithoutPayslipsInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    branchId?: string | null
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    servicesServed?: AvailedServiceUncheckedCreateNestedManyWithoutServedByInput
    servicesChecked?: AvailedServiceUncheckedCreateNestedManyWithoutCheckedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutAccountInput
    attendancesChecked?: AttendanceUncheckedCreateNestedManyWithoutCheckedByInput
    payslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutProcessedByInput
    manualSales?: ManualSaleUncheckedCreateNestedManyWithoutRecordedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type AccountCreateOrConnectWithoutPayslipsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutPayslipsInput, AccountUncheckedCreateWithoutPayslipsInput>
  }

  export type PayslipRequestCreateWithoutRelatedPayslipInput = {
    id?: string
    requestTimestamp?: Date | string
    periodStartDate: Date | string
    periodEndDate: Date | string
    status?: $Enums.PayslipRequestStatus
    notes?: string | null
    processedTimestamp?: Date | string | null
    account: AccountCreateNestedOneWithoutPayslipRequestsInput
    processedBy?: AccountCreateNestedOneWithoutManagedPayslipRequestsInput
  }

  export type PayslipRequestUncheckedCreateWithoutRelatedPayslipInput = {
    id?: string
    accountId: string
    requestTimestamp?: Date | string
    periodStartDate: Date | string
    periodEndDate: Date | string
    status?: $Enums.PayslipRequestStatus
    notes?: string | null
    processedById?: string | null
    processedTimestamp?: Date | string | null
  }

  export type PayslipRequestCreateOrConnectWithoutRelatedPayslipInput = {
    where: PayslipRequestWhereUniqueInput
    create: XOR<PayslipRequestCreateWithoutRelatedPayslipInput, PayslipRequestUncheckedCreateWithoutRelatedPayslipInput>
  }

  export type AccountUpsertWithoutPayslipsInput = {
    update: XOR<AccountUpdateWithoutPayslipsInput, AccountUncheckedUpdateWithoutPayslipsInput>
    create: XOR<AccountCreateWithoutPayslipsInput, AccountUncheckedCreateWithoutPayslipsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutPayslipsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutPayslipsInput, AccountUncheckedUpdateWithoutPayslipsInput>
  }

  export type AccountUpdateWithoutPayslipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    branch?: BranchUpdateOneWithoutAccountsNestedInput
    servicesServed?: AvailedServiceUpdateManyWithoutServedByNestedInput
    servicesChecked?: AvailedServiceUpdateManyWithoutCheckedByNestedInput
    attendances?: AttendanceUpdateManyWithoutAccountNestedInput
    attendancesChecked?: AttendanceUpdateManyWithoutCheckedByNestedInput
    payslipRequests?: PayslipRequestUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUpdateManyWithoutProcessedByNestedInput
    manualSales?: ManualSaleUpdateManyWithoutRecordedByNestedInput
    expenses?: ExpenseUpdateManyWithoutRecordedByNestedInput
  }

  export type AccountUncheckedUpdateWithoutPayslipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    servicesServed?: AvailedServiceUncheckedUpdateManyWithoutServedByNestedInput
    servicesChecked?: AvailedServiceUncheckedUpdateManyWithoutCheckedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutAccountNestedInput
    attendancesChecked?: AttendanceUncheckedUpdateManyWithoutCheckedByNestedInput
    payslipRequests?: PayslipRequestUncheckedUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    manualSales?: ManualSaleUncheckedUpdateManyWithoutRecordedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type PayslipRequestUpsertWithoutRelatedPayslipInput = {
    update: XOR<PayslipRequestUpdateWithoutRelatedPayslipInput, PayslipRequestUncheckedUpdateWithoutRelatedPayslipInput>
    create: XOR<PayslipRequestCreateWithoutRelatedPayslipInput, PayslipRequestUncheckedCreateWithoutRelatedPayslipInput>
    where?: PayslipRequestWhereInput
  }

  export type PayslipRequestUpdateToOneWithWhereWithoutRelatedPayslipInput = {
    where?: PayslipRequestWhereInput
    data: XOR<PayslipRequestUpdateWithoutRelatedPayslipInput, PayslipRequestUncheckedUpdateWithoutRelatedPayslipInput>
  }

  export type PayslipRequestUpdateWithoutRelatedPayslipInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayslipRequestStatusFieldUpdateOperationsInput | $Enums.PayslipRequestStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUpdateOneRequiredWithoutPayslipRequestsNestedInput
    processedBy?: AccountUpdateOneWithoutManagedPayslipRequestsNestedInput
  }

  export type PayslipRequestUncheckedUpdateWithoutRelatedPayslipInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayslipRequestStatusFieldUpdateOperationsInput | $Enums.PayslipRequestStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerCreateWithoutRecommendedAppointmentsInput = {
    id?: string
    name: string
    email?: string | null
    totalPaid?: number
    nextAppointment?: Date | string | null
    transactionHistory?: TransactionCreateNestedManyWithoutCustomerInput
    purchasedGiftCertificates?: GiftCertificateCreateNestedManyWithoutPurchaserCustomerInput
  }

  export type CustomerUncheckedCreateWithoutRecommendedAppointmentsInput = {
    id?: string
    name: string
    email?: string | null
    totalPaid?: number
    nextAppointment?: Date | string | null
    transactionHistory?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    purchasedGiftCertificates?: GiftCertificateUncheckedCreateNestedManyWithoutPurchaserCustomerInput
  }

  export type CustomerCreateOrConnectWithoutRecommendedAppointmentsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutRecommendedAppointmentsInput, CustomerUncheckedCreateWithoutRecommendedAppointmentsInput>
  }

  export type TransactionCreateWithoutOriginatingRecommendationsInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    bookingReminderSentAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutTransactionHistoryInput
    availedServices?: AvailedServiceCreateNestedManyWithoutTransactionInput
    voucherUsed?: VoucherCreateNestedOneWithoutTransactionInput
    branch?: BranchCreateNestedOneWithoutTransactionInput
    giftCertificateUsed?: GiftCertificateCreateNestedOneWithoutTransactionsInput
    attendedAppointment?: RecommendedAppointmentCreateNestedOneWithoutAttendedTransactionInput
  }

  export type TransactionUncheckedCreateWithoutOriginatingRecommendationsInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    customerId: string
    voucherId?: string | null
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    branchId?: string | null
    bookingReminderSentAt?: Date | string | null
    giftCertificateId?: string | null
    availedServices?: AvailedServiceUncheckedCreateNestedManyWithoutTransactionInput
    attendedAppointment?: RecommendedAppointmentUncheckedCreateNestedOneWithoutAttendedTransactionInput
  }

  export type TransactionCreateOrConnectWithoutOriginatingRecommendationsInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutOriginatingRecommendationsInput, TransactionUncheckedCreateWithoutOriginatingRecommendationsInput>
  }

  export type AvailedServiceCreateWithoutRecommendedAppointmentInput = {
    id?: string
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetTitle?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutAvailedServicesInput
    service?: ServiceCreateNestedOneWithoutAvailedServiceInput
    originatingSet?: ServiceSetCreateNestedOneWithoutAvailedServiceInput
    checkedBy?: AccountCreateNestedOneWithoutServicesCheckedInput
    servedBy?: AccountCreateNestedOneWithoutServicesServedInput
  }

  export type AvailedServiceUncheckedCreateWithoutRecommendedAppointmentInput = {
    id?: string
    transactionId: string
    serviceId?: string | null
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetId?: string | null
    originatingSetTitle?: string | null
    checkedById?: string | null
    servedById?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailedServiceCreateOrConnectWithoutRecommendedAppointmentInput = {
    where: AvailedServiceWhereUniqueInput
    create: XOR<AvailedServiceCreateWithoutRecommendedAppointmentInput, AvailedServiceUncheckedCreateWithoutRecommendedAppointmentInput>
  }

  export type ServiceCreateWithoutRecommendedAppointmentsInput = {
    id?: string
    title: string
    description?: string | null
    price?: number
    totalSales?: number
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: number | null
    followUpPolicy?: $Enums.FollowUpPolicy
    branch: BranchCreateNestedOneWithoutServicesInput
    AvailedService?: AvailedServiceCreateNestedManyWithoutServiceInput
    serviceSets?: ServiceSetCreateNestedManyWithoutServicesInput
    giftCertificates?: GiftCertificateCreateNestedManyWithoutServicesInput
    discountRules?: DiscountRuleCreateNestedManyWithoutServicesInput
  }

  export type ServiceUncheckedCreateWithoutRecommendedAppointmentsInput = {
    id?: string
    title: string
    description?: string | null
    price?: number
    branchId: string
    totalSales?: number
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: number | null
    followUpPolicy?: $Enums.FollowUpPolicy
    AvailedService?: AvailedServiceUncheckedCreateNestedManyWithoutServiceInput
    serviceSets?: ServiceSetUncheckedCreateNestedManyWithoutServicesInput
    giftCertificates?: GiftCertificateUncheckedCreateNestedManyWithoutServicesInput
    discountRules?: DiscountRuleUncheckedCreateNestedManyWithoutServicesInput
  }

  export type ServiceCreateOrConnectWithoutRecommendedAppointmentsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutRecommendedAppointmentsInput, ServiceUncheckedCreateWithoutRecommendedAppointmentsInput>
  }

  export type TransactionCreateWithoutAttendedAppointmentInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    bookingReminderSentAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutTransactionHistoryInput
    availedServices?: AvailedServiceCreateNestedManyWithoutTransactionInput
    voucherUsed?: VoucherCreateNestedOneWithoutTransactionInput
    branch?: BranchCreateNestedOneWithoutTransactionInput
    giftCertificateUsed?: GiftCertificateCreateNestedOneWithoutTransactionsInput
    originatingRecommendations?: RecommendedAppointmentCreateNestedManyWithoutOriginatingTransactionInput
  }

  export type TransactionUncheckedCreateWithoutAttendedAppointmentInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    customerId: string
    voucherId?: string | null
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    branchId?: string | null
    bookingReminderSentAt?: Date | string | null
    giftCertificateId?: string | null
    availedServices?: AvailedServiceUncheckedCreateNestedManyWithoutTransactionInput
    originatingRecommendations?: RecommendedAppointmentUncheckedCreateNestedManyWithoutOriginatingTransactionInput
  }

  export type TransactionCreateOrConnectWithoutAttendedAppointmentInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutAttendedAppointmentInput, TransactionUncheckedCreateWithoutAttendedAppointmentInput>
  }

  export type CustomerUpsertWithoutRecommendedAppointmentsInput = {
    update: XOR<CustomerUpdateWithoutRecommendedAppointmentsInput, CustomerUncheckedUpdateWithoutRecommendedAppointmentsInput>
    create: XOR<CustomerCreateWithoutRecommendedAppointmentsInput, CustomerUncheckedCreateWithoutRecommendedAppointmentsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutRecommendedAppointmentsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutRecommendedAppointmentsInput, CustomerUncheckedUpdateWithoutRecommendedAppointmentsInput>
  }

  export type CustomerUpdateWithoutRecommendedAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: FloatFieldUpdateOperationsInput | number
    nextAppointment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionHistory?: TransactionUpdateManyWithoutCustomerNestedInput
    purchasedGiftCertificates?: GiftCertificateUpdateManyWithoutPurchaserCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutRecommendedAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: FloatFieldUpdateOperationsInput | number
    nextAppointment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionHistory?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    purchasedGiftCertificates?: GiftCertificateUncheckedUpdateManyWithoutPurchaserCustomerNestedInput
  }

  export type TransactionUpsertWithoutOriginatingRecommendationsInput = {
    update: XOR<TransactionUpdateWithoutOriginatingRecommendationsInput, TransactionUncheckedUpdateWithoutOriginatingRecommendationsInput>
    create: XOR<TransactionCreateWithoutOriginatingRecommendationsInput, TransactionUncheckedCreateWithoutOriginatingRecommendationsInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutOriginatingRecommendationsInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutOriginatingRecommendationsInput, TransactionUncheckedUpdateWithoutOriginatingRecommendationsInput>
  }

  export type TransactionUpdateWithoutOriginatingRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutTransactionHistoryNestedInput
    availedServices?: AvailedServiceUpdateManyWithoutTransactionNestedInput
    voucherUsed?: VoucherUpdateOneWithoutTransactionNestedInput
    branch?: BranchUpdateOneWithoutTransactionNestedInput
    giftCertificateUsed?: GiftCertificateUpdateOneWithoutTransactionsNestedInput
    attendedAppointment?: RecommendedAppointmentUpdateOneWithoutAttendedTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutOriginatingRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    giftCertificateId?: NullableStringFieldUpdateOperationsInput | string | null
    availedServices?: AvailedServiceUncheckedUpdateManyWithoutTransactionNestedInput
    attendedAppointment?: RecommendedAppointmentUncheckedUpdateOneWithoutAttendedTransactionNestedInput
  }

  export type AvailedServiceUpsertWithoutRecommendedAppointmentInput = {
    update: XOR<AvailedServiceUpdateWithoutRecommendedAppointmentInput, AvailedServiceUncheckedUpdateWithoutRecommendedAppointmentInput>
    create: XOR<AvailedServiceCreateWithoutRecommendedAppointmentInput, AvailedServiceUncheckedCreateWithoutRecommendedAppointmentInput>
    where?: AvailedServiceWhereInput
  }

  export type AvailedServiceUpdateToOneWithWhereWithoutRecommendedAppointmentInput = {
    where?: AvailedServiceWhereInput
    data: XOR<AvailedServiceUpdateWithoutRecommendedAppointmentInput, AvailedServiceUncheckedUpdateWithoutRecommendedAppointmentInput>
  }

  export type AvailedServiceUpdateWithoutRecommendedAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutAvailedServicesNestedInput
    service?: ServiceUpdateOneWithoutAvailedServiceNestedInput
    originatingSet?: ServiceSetUpdateOneWithoutAvailedServiceNestedInput
    checkedBy?: AccountUpdateOneWithoutServicesCheckedNestedInput
    servedBy?: AccountUpdateOneWithoutServicesServedNestedInput
  }

  export type AvailedServiceUncheckedUpdateWithoutRecommendedAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    checkedById?: NullableStringFieldUpdateOperationsInput | string | null
    servedById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUpsertWithoutRecommendedAppointmentsInput = {
    update: XOR<ServiceUpdateWithoutRecommendedAppointmentsInput, ServiceUncheckedUpdateWithoutRecommendedAppointmentsInput>
    create: XOR<ServiceCreateWithoutRecommendedAppointmentsInput, ServiceUncheckedCreateWithoutRecommendedAppointmentsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutRecommendedAppointmentsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutRecommendedAppointmentsInput, ServiceUncheckedUpdateWithoutRecommendedAppointmentsInput>
  }

  export type ServiceUpdateWithoutRecommendedAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
    branch?: BranchUpdateOneRequiredWithoutServicesNestedInput
    AvailedService?: AvailedServiceUpdateManyWithoutServiceNestedInput
    serviceSets?: ServiceSetUpdateManyWithoutServicesNestedInput
    giftCertificates?: GiftCertificateUpdateManyWithoutServicesNestedInput
    discountRules?: DiscountRuleUpdateManyWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateWithoutRecommendedAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    branchId?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
    AvailedService?: AvailedServiceUncheckedUpdateManyWithoutServiceNestedInput
    serviceSets?: ServiceSetUncheckedUpdateManyWithoutServicesNestedInput
    giftCertificates?: GiftCertificateUncheckedUpdateManyWithoutServicesNestedInput
    discountRules?: DiscountRuleUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type TransactionUpsertWithoutAttendedAppointmentInput = {
    update: XOR<TransactionUpdateWithoutAttendedAppointmentInput, TransactionUncheckedUpdateWithoutAttendedAppointmentInput>
    create: XOR<TransactionCreateWithoutAttendedAppointmentInput, TransactionUncheckedCreateWithoutAttendedAppointmentInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutAttendedAppointmentInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutAttendedAppointmentInput, TransactionUncheckedUpdateWithoutAttendedAppointmentInput>
  }

  export type TransactionUpdateWithoutAttendedAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutTransactionHistoryNestedInput
    availedServices?: AvailedServiceUpdateManyWithoutTransactionNestedInput
    voucherUsed?: VoucherUpdateOneWithoutTransactionNestedInput
    branch?: BranchUpdateOneWithoutTransactionNestedInput
    giftCertificateUsed?: GiftCertificateUpdateOneWithoutTransactionsNestedInput
    originatingRecommendations?: RecommendedAppointmentUpdateManyWithoutOriginatingTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutAttendedAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    giftCertificateId?: NullableStringFieldUpdateOperationsInput | string | null
    availedServices?: AvailedServiceUncheckedUpdateManyWithoutTransactionNestedInput
    originatingRecommendations?: RecommendedAppointmentUncheckedUpdateManyWithoutOriginatingTransactionNestedInput
  }

  export type ServiceCreateWithoutDiscountRulesInput = {
    id?: string
    title: string
    description?: string | null
    price?: number
    totalSales?: number
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: number | null
    followUpPolicy?: $Enums.FollowUpPolicy
    branch: BranchCreateNestedOneWithoutServicesInput
    AvailedService?: AvailedServiceCreateNestedManyWithoutServiceInput
    serviceSets?: ServiceSetCreateNestedManyWithoutServicesInput
    giftCertificates?: GiftCertificateCreateNestedManyWithoutServicesInput
    recommendedAppointments?: RecommendedAppointmentCreateNestedManyWithoutOriginatingServiceInput
  }

  export type ServiceUncheckedCreateWithoutDiscountRulesInput = {
    id?: string
    title: string
    description?: string | null
    price?: number
    branchId: string
    totalSales?: number
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: number | null
    followUpPolicy?: $Enums.FollowUpPolicy
    AvailedService?: AvailedServiceUncheckedCreateNestedManyWithoutServiceInput
    serviceSets?: ServiceSetUncheckedCreateNestedManyWithoutServicesInput
    giftCertificates?: GiftCertificateUncheckedCreateNestedManyWithoutServicesInput
    recommendedAppointments?: RecommendedAppointmentUncheckedCreateNestedManyWithoutOriginatingServiceInput
  }

  export type ServiceCreateOrConnectWithoutDiscountRulesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutDiscountRulesInput, ServiceUncheckedCreateWithoutDiscountRulesInput>
  }

  export type ServiceUpsertWithWhereUniqueWithoutDiscountRulesInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutDiscountRulesInput, ServiceUncheckedUpdateWithoutDiscountRulesInput>
    create: XOR<ServiceCreateWithoutDiscountRulesInput, ServiceUncheckedCreateWithoutDiscountRulesInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutDiscountRulesInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutDiscountRulesInput, ServiceUncheckedUpdateWithoutDiscountRulesInput>
  }

  export type ServiceUpdateManyWithWhereWithoutDiscountRulesInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutDiscountRulesInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    title?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    price?: IntFilter<"Service"> | number
    branchId?: StringFilter<"Service"> | string
    totalSales?: IntFilter<"Service"> | number
    recommendFollowUp?: BoolFilter<"Service"> | boolean
    recommendedFollowUpDays?: IntNullableFilter<"Service"> | number | null
    followUpPolicy?: EnumFollowUpPolicyFilter<"Service"> | $Enums.FollowUpPolicy
  }

  export type ServiceCreateWithoutBranchInput = {
    id?: string
    title: string
    description?: string | null
    price?: number
    totalSales?: number
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: number | null
    followUpPolicy?: $Enums.FollowUpPolicy
    AvailedService?: AvailedServiceCreateNestedManyWithoutServiceInput
    serviceSets?: ServiceSetCreateNestedManyWithoutServicesInput
    giftCertificates?: GiftCertificateCreateNestedManyWithoutServicesInput
    discountRules?: DiscountRuleCreateNestedManyWithoutServicesInput
    recommendedAppointments?: RecommendedAppointmentCreateNestedManyWithoutOriginatingServiceInput
  }

  export type ServiceUncheckedCreateWithoutBranchInput = {
    id?: string
    title: string
    description?: string | null
    price?: number
    totalSales?: number
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: number | null
    followUpPolicy?: $Enums.FollowUpPolicy
    AvailedService?: AvailedServiceUncheckedCreateNestedManyWithoutServiceInput
    serviceSets?: ServiceSetUncheckedCreateNestedManyWithoutServicesInput
    giftCertificates?: GiftCertificateUncheckedCreateNestedManyWithoutServicesInput
    discountRules?: DiscountRuleUncheckedCreateNestedManyWithoutServicesInput
    recommendedAppointments?: RecommendedAppointmentUncheckedCreateNestedManyWithoutOriginatingServiceInput
  }

  export type ServiceCreateOrConnectWithoutBranchInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutBranchInput, ServiceUncheckedCreateWithoutBranchInput>
  }

  export type ServiceCreateManyBranchInputEnvelope = {
    data: ServiceCreateManyBranchInput | ServiceCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutBranchInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    servicesServed?: AvailedServiceCreateNestedManyWithoutServedByInput
    servicesChecked?: AvailedServiceCreateNestedManyWithoutCheckedByInput
    attendances?: AttendanceCreateNestedManyWithoutAccountInput
    attendancesChecked?: AttendanceCreateNestedManyWithoutCheckedByInput
    payslips?: PayslipCreateNestedManyWithoutAccountInput
    payslipRequests?: PayslipRequestCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestCreateNestedManyWithoutProcessedByInput
    manualSales?: ManualSaleCreateNestedManyWithoutRecordedByInput
    expenses?: ExpenseCreateNestedManyWithoutRecordedByInput
  }

  export type AccountUncheckedCreateWithoutBranchInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    servicesServed?: AvailedServiceUncheckedCreateNestedManyWithoutServedByInput
    servicesChecked?: AvailedServiceUncheckedCreateNestedManyWithoutCheckedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutAccountInput
    attendancesChecked?: AttendanceUncheckedCreateNestedManyWithoutCheckedByInput
    payslips?: PayslipUncheckedCreateNestedManyWithoutAccountInput
    payslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutProcessedByInput
    manualSales?: ManualSaleUncheckedCreateNestedManyWithoutRecordedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type AccountCreateOrConnectWithoutBranchInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutBranchInput, AccountUncheckedCreateWithoutBranchInput>
  }

  export type AccountCreateManyBranchInputEnvelope = {
    data: AccountCreateManyBranchInput | AccountCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ManualSaleCreateWithoutBranchInput = {
    id?: string
    date: Date | string
    amount: number
    paymentMethod?: $Enums.PaymentMethod | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedBy: AccountCreateNestedOneWithoutManualSalesInput
  }

  export type ManualSaleUncheckedCreateWithoutBranchInput = {
    id?: string
    date: Date | string
    amount: number
    paymentMethod?: $Enums.PaymentMethod | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedById: string
  }

  export type ManualSaleCreateOrConnectWithoutBranchInput = {
    where: ManualSaleWhereUniqueInput
    create: XOR<ManualSaleCreateWithoutBranchInput, ManualSaleUncheckedCreateWithoutBranchInput>
  }

  export type ManualSaleCreateManyBranchInputEnvelope = {
    data: ManualSaleCreateManyBranchInput | ManualSaleCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutBranchInput = {
    id?: string
    date: Date | string
    amount: number
    category: $Enums.ExpenseCategory
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedBy: AccountCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutBranchInput = {
    id?: string
    date: Date | string
    amount: number
    category: $Enums.ExpenseCategory
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedById: string
  }

  export type ExpenseCreateOrConnectWithoutBranchInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutBranchInput, ExpenseUncheckedCreateWithoutBranchInput>
  }

  export type ExpenseCreateManyBranchInputEnvelope = {
    data: ExpenseCreateManyBranchInput | ExpenseCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutBranchInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    bookingReminderSentAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutTransactionHistoryInput
    availedServices?: AvailedServiceCreateNestedManyWithoutTransactionInput
    voucherUsed?: VoucherCreateNestedOneWithoutTransactionInput
    giftCertificateUsed?: GiftCertificateCreateNestedOneWithoutTransactionsInput
    originatingRecommendations?: RecommendedAppointmentCreateNestedManyWithoutOriginatingTransactionInput
    attendedAppointment?: RecommendedAppointmentCreateNestedOneWithoutAttendedTransactionInput
  }

  export type TransactionUncheckedCreateWithoutBranchInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    customerId: string
    voucherId?: string | null
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    bookingReminderSentAt?: Date | string | null
    giftCertificateId?: string | null
    availedServices?: AvailedServiceUncheckedCreateNestedManyWithoutTransactionInput
    originatingRecommendations?: RecommendedAppointmentUncheckedCreateNestedManyWithoutOriginatingTransactionInput
    attendedAppointment?: RecommendedAppointmentUncheckedCreateNestedOneWithoutAttendedTransactionInput
  }

  export type TransactionCreateOrConnectWithoutBranchInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutBranchInput, TransactionUncheckedCreateWithoutBranchInput>
  }

  export type TransactionCreateManyBranchInputEnvelope = {
    data: TransactionCreateManyBranchInput | TransactionCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithWhereUniqueWithoutBranchInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutBranchInput, ServiceUncheckedUpdateWithoutBranchInput>
    create: XOR<ServiceCreateWithoutBranchInput, ServiceUncheckedCreateWithoutBranchInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutBranchInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutBranchInput, ServiceUncheckedUpdateWithoutBranchInput>
  }

  export type ServiceUpdateManyWithWhereWithoutBranchInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutBranchInput>
  }

  export type AccountUpsertWithWhereUniqueWithoutBranchInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutBranchInput, AccountUncheckedUpdateWithoutBranchInput>
    create: XOR<AccountCreateWithoutBranchInput, AccountUncheckedCreateWithoutBranchInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutBranchInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutBranchInput, AccountUncheckedUpdateWithoutBranchInput>
  }

  export type AccountUpdateManyWithWhereWithoutBranchInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutBranchInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    username?: StringFilter<"Account"> | string
    password?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    email?: StringNullableFilter<"Account"> | string | null
    role?: EnumRoleNullableListFilter<"Account">
    salary?: IntFilter<"Account"> | number
    dailyRate?: IntFilter<"Account"> | number
    branchId?: StringNullableFilter<"Account"> | string | null
    canRequestPayslip?: BoolFilter<"Account"> | boolean
    mustChangePassword?: BoolFilter<"Account"> | boolean
  }

  export type ManualSaleUpsertWithWhereUniqueWithoutBranchInput = {
    where: ManualSaleWhereUniqueInput
    update: XOR<ManualSaleUpdateWithoutBranchInput, ManualSaleUncheckedUpdateWithoutBranchInput>
    create: XOR<ManualSaleCreateWithoutBranchInput, ManualSaleUncheckedCreateWithoutBranchInput>
  }

  export type ManualSaleUpdateWithWhereUniqueWithoutBranchInput = {
    where: ManualSaleWhereUniqueInput
    data: XOR<ManualSaleUpdateWithoutBranchInput, ManualSaleUncheckedUpdateWithoutBranchInput>
  }

  export type ManualSaleUpdateManyWithWhereWithoutBranchInput = {
    where: ManualSaleScalarWhereInput
    data: XOR<ManualSaleUpdateManyMutationInput, ManualSaleUncheckedUpdateManyWithoutBranchInput>
  }

  export type ManualSaleScalarWhereInput = {
    AND?: ManualSaleScalarWhereInput | ManualSaleScalarWhereInput[]
    OR?: ManualSaleScalarWhereInput[]
    NOT?: ManualSaleScalarWhereInput | ManualSaleScalarWhereInput[]
    id?: StringFilter<"ManualSale"> | string
    date?: DateTimeFilter<"ManualSale"> | Date | string
    amount?: IntFilter<"ManualSale"> | number
    paymentMethod?: EnumPaymentMethodNullableFilter<"ManualSale"> | $Enums.PaymentMethod | null
    description?: StringNullableFilter<"ManualSale"> | string | null
    createdAt?: DateTimeFilter<"ManualSale"> | Date | string
    updatedAt?: DateTimeFilter<"ManualSale"> | Date | string
    recordedById?: StringFilter<"ManualSale"> | string
    branchId?: StringNullableFilter<"ManualSale"> | string | null
  }

  export type ExpenseUpsertWithWhereUniqueWithoutBranchInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutBranchInput, ExpenseUncheckedUpdateWithoutBranchInput>
    create: XOR<ExpenseCreateWithoutBranchInput, ExpenseUncheckedCreateWithoutBranchInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutBranchInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutBranchInput, ExpenseUncheckedUpdateWithoutBranchInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutBranchInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutBranchInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    id?: StringFilter<"Expense"> | string
    date?: DateTimeFilter<"Expense"> | Date | string
    amount?: IntFilter<"Expense"> | number
    category?: EnumExpenseCategoryFilter<"Expense"> | $Enums.ExpenseCategory
    description?: StringNullableFilter<"Expense"> | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    recordedById?: StringFilter<"Expense"> | string
    branchId?: StringNullableFilter<"Expense"> | string | null
  }

  export type TransactionUpsertWithWhereUniqueWithoutBranchInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutBranchInput, TransactionUncheckedUpdateWithoutBranchInput>
    create: XOR<TransactionCreateWithoutBranchInput, TransactionUncheckedCreateWithoutBranchInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutBranchInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutBranchInput, TransactionUncheckedUpdateWithoutBranchInput>
  }

  export type TransactionUpdateManyWithWhereWithoutBranchInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutBranchInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    bookedFor?: DateTimeFilter<"Transaction"> | Date | string
    customerId?: StringFilter<"Transaction"> | string
    voucherId?: StringNullableFilter<"Transaction"> | string | null
    discount?: IntFilter<"Transaction"> | number
    paymentMethod?: EnumPaymentMethodNullableFilter<"Transaction"> | $Enums.PaymentMethod | null
    grandTotal?: IntFilter<"Transaction"> | number
    status?: EnumStatusFilter<"Transaction"> | $Enums.Status
    branchId?: StringNullableFilter<"Transaction"> | string | null
    bookingReminderSentAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    giftCertificateId?: StringNullableFilter<"Transaction"> | string | null
  }

  export type AccountCreateWithoutAttendancesInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    branch?: BranchCreateNestedOneWithoutAccountsInput
    servicesServed?: AvailedServiceCreateNestedManyWithoutServedByInput
    servicesChecked?: AvailedServiceCreateNestedManyWithoutCheckedByInput
    attendancesChecked?: AttendanceCreateNestedManyWithoutCheckedByInput
    payslips?: PayslipCreateNestedManyWithoutAccountInput
    payslipRequests?: PayslipRequestCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestCreateNestedManyWithoutProcessedByInput
    manualSales?: ManualSaleCreateNestedManyWithoutRecordedByInput
    expenses?: ExpenseCreateNestedManyWithoutRecordedByInput
  }

  export type AccountUncheckedCreateWithoutAttendancesInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    branchId?: string | null
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    servicesServed?: AvailedServiceUncheckedCreateNestedManyWithoutServedByInput
    servicesChecked?: AvailedServiceUncheckedCreateNestedManyWithoutCheckedByInput
    attendancesChecked?: AttendanceUncheckedCreateNestedManyWithoutCheckedByInput
    payslips?: PayslipUncheckedCreateNestedManyWithoutAccountInput
    payslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutProcessedByInput
    manualSales?: ManualSaleUncheckedCreateNestedManyWithoutRecordedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type AccountCreateOrConnectWithoutAttendancesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAttendancesInput, AccountUncheckedCreateWithoutAttendancesInput>
  }

  export type AccountCreateWithoutAttendancesCheckedInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    branch?: BranchCreateNestedOneWithoutAccountsInput
    servicesServed?: AvailedServiceCreateNestedManyWithoutServedByInput
    servicesChecked?: AvailedServiceCreateNestedManyWithoutCheckedByInput
    attendances?: AttendanceCreateNestedManyWithoutAccountInput
    payslips?: PayslipCreateNestedManyWithoutAccountInput
    payslipRequests?: PayslipRequestCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestCreateNestedManyWithoutProcessedByInput
    manualSales?: ManualSaleCreateNestedManyWithoutRecordedByInput
    expenses?: ExpenseCreateNestedManyWithoutRecordedByInput
  }

  export type AccountUncheckedCreateWithoutAttendancesCheckedInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    branchId?: string | null
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    servicesServed?: AvailedServiceUncheckedCreateNestedManyWithoutServedByInput
    servicesChecked?: AvailedServiceUncheckedCreateNestedManyWithoutCheckedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutAccountInput
    payslips?: PayslipUncheckedCreateNestedManyWithoutAccountInput
    payslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutProcessedByInput
    manualSales?: ManualSaleUncheckedCreateNestedManyWithoutRecordedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type AccountCreateOrConnectWithoutAttendancesCheckedInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAttendancesCheckedInput, AccountUncheckedCreateWithoutAttendancesCheckedInput>
  }

  export type AccountUpsertWithoutAttendancesInput = {
    update: XOR<AccountUpdateWithoutAttendancesInput, AccountUncheckedUpdateWithoutAttendancesInput>
    create: XOR<AccountCreateWithoutAttendancesInput, AccountUncheckedCreateWithoutAttendancesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutAttendancesInput, AccountUncheckedUpdateWithoutAttendancesInput>
  }

  export type AccountUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    branch?: BranchUpdateOneWithoutAccountsNestedInput
    servicesServed?: AvailedServiceUpdateManyWithoutServedByNestedInput
    servicesChecked?: AvailedServiceUpdateManyWithoutCheckedByNestedInput
    attendancesChecked?: AttendanceUpdateManyWithoutCheckedByNestedInput
    payslips?: PayslipUpdateManyWithoutAccountNestedInput
    payslipRequests?: PayslipRequestUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUpdateManyWithoutProcessedByNestedInput
    manualSales?: ManualSaleUpdateManyWithoutRecordedByNestedInput
    expenses?: ExpenseUpdateManyWithoutRecordedByNestedInput
  }

  export type AccountUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    servicesServed?: AvailedServiceUncheckedUpdateManyWithoutServedByNestedInput
    servicesChecked?: AvailedServiceUncheckedUpdateManyWithoutCheckedByNestedInput
    attendancesChecked?: AttendanceUncheckedUpdateManyWithoutCheckedByNestedInput
    payslips?: PayslipUncheckedUpdateManyWithoutAccountNestedInput
    payslipRequests?: PayslipRequestUncheckedUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    manualSales?: ManualSaleUncheckedUpdateManyWithoutRecordedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type AccountUpsertWithoutAttendancesCheckedInput = {
    update: XOR<AccountUpdateWithoutAttendancesCheckedInput, AccountUncheckedUpdateWithoutAttendancesCheckedInput>
    create: XOR<AccountCreateWithoutAttendancesCheckedInput, AccountUncheckedCreateWithoutAttendancesCheckedInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutAttendancesCheckedInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutAttendancesCheckedInput, AccountUncheckedUpdateWithoutAttendancesCheckedInput>
  }

  export type AccountUpdateWithoutAttendancesCheckedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    branch?: BranchUpdateOneWithoutAccountsNestedInput
    servicesServed?: AvailedServiceUpdateManyWithoutServedByNestedInput
    servicesChecked?: AvailedServiceUpdateManyWithoutCheckedByNestedInput
    attendances?: AttendanceUpdateManyWithoutAccountNestedInput
    payslips?: PayslipUpdateManyWithoutAccountNestedInput
    payslipRequests?: PayslipRequestUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUpdateManyWithoutProcessedByNestedInput
    manualSales?: ManualSaleUpdateManyWithoutRecordedByNestedInput
    expenses?: ExpenseUpdateManyWithoutRecordedByNestedInput
  }

  export type AccountUncheckedUpdateWithoutAttendancesCheckedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    servicesServed?: AvailedServiceUncheckedUpdateManyWithoutServedByNestedInput
    servicesChecked?: AvailedServiceUncheckedUpdateManyWithoutCheckedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutAccountNestedInput
    payslips?: PayslipUncheckedUpdateManyWithoutAccountNestedInput
    payslipRequests?: PayslipRequestUncheckedUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    manualSales?: ManualSaleUncheckedUpdateManyWithoutRecordedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type BranchCreateWithoutAccountsInput = {
    id?: string
    title: string
    code: string
    totalSales?: number
    services?: ServiceCreateNestedManyWithoutBranchInput
    manualSales?: ManualSaleCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    Transaction?: TransactionCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutAccountsInput = {
    id?: string
    title: string
    code: string
    totalSales?: number
    services?: ServiceUncheckedCreateNestedManyWithoutBranchInput
    manualSales?: ManualSaleUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutAccountsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutAccountsInput, BranchUncheckedCreateWithoutAccountsInput>
  }

  export type AvailedServiceCreateWithoutServedByInput = {
    id?: string
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetTitle?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutAvailedServicesInput
    service?: ServiceCreateNestedOneWithoutAvailedServiceInput
    originatingSet?: ServiceSetCreateNestedOneWithoutAvailedServiceInput
    checkedBy?: AccountCreateNestedOneWithoutServicesCheckedInput
    recommendedAppointment?: RecommendedAppointmentCreateNestedOneWithoutOriginatingAvailedServiceInput
  }

  export type AvailedServiceUncheckedCreateWithoutServedByInput = {
    id?: string
    transactionId: string
    serviceId?: string | null
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetId?: string | null
    originatingSetTitle?: string | null
    checkedById?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recommendedAppointment?: RecommendedAppointmentUncheckedCreateNestedOneWithoutOriginatingAvailedServiceInput
  }

  export type AvailedServiceCreateOrConnectWithoutServedByInput = {
    where: AvailedServiceWhereUniqueInput
    create: XOR<AvailedServiceCreateWithoutServedByInput, AvailedServiceUncheckedCreateWithoutServedByInput>
  }

  export type AvailedServiceCreateManyServedByInputEnvelope = {
    data: AvailedServiceCreateManyServedByInput | AvailedServiceCreateManyServedByInput[]
    skipDuplicates?: boolean
  }

  export type AvailedServiceCreateWithoutCheckedByInput = {
    id?: string
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetTitle?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutAvailedServicesInput
    service?: ServiceCreateNestedOneWithoutAvailedServiceInput
    originatingSet?: ServiceSetCreateNestedOneWithoutAvailedServiceInput
    servedBy?: AccountCreateNestedOneWithoutServicesServedInput
    recommendedAppointment?: RecommendedAppointmentCreateNestedOneWithoutOriginatingAvailedServiceInput
  }

  export type AvailedServiceUncheckedCreateWithoutCheckedByInput = {
    id?: string
    transactionId: string
    serviceId?: string | null
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetId?: string | null
    originatingSetTitle?: string | null
    servedById?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recommendedAppointment?: RecommendedAppointmentUncheckedCreateNestedOneWithoutOriginatingAvailedServiceInput
  }

  export type AvailedServiceCreateOrConnectWithoutCheckedByInput = {
    where: AvailedServiceWhereUniqueInput
    create: XOR<AvailedServiceCreateWithoutCheckedByInput, AvailedServiceUncheckedCreateWithoutCheckedByInput>
  }

  export type AvailedServiceCreateManyCheckedByInputEnvelope = {
    data: AvailedServiceCreateManyCheckedByInput | AvailedServiceCreateManyCheckedByInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutAccountInput = {
    id?: string
    date: Date | string
    isPresent?: boolean
    notes?: string | null
    checkedAt?: Date | string
    checkedBy: AccountCreateNestedOneWithoutAttendancesCheckedInput
  }

  export type AttendanceUncheckedCreateWithoutAccountInput = {
    id?: string
    date: Date | string
    isPresent?: boolean
    notes?: string | null
    checkedById: string
    checkedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutAccountInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutAccountInput, AttendanceUncheckedCreateWithoutAccountInput>
  }

  export type AttendanceCreateManyAccountInputEnvelope = {
    data: AttendanceCreateManyAccountInput | AttendanceCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutCheckedByInput = {
    id?: string
    date: Date | string
    isPresent?: boolean
    notes?: string | null
    checkedAt?: Date | string
    account: AccountCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutCheckedByInput = {
    id?: string
    date: Date | string
    accountId: string
    isPresent?: boolean
    notes?: string | null
    checkedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutCheckedByInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutCheckedByInput, AttendanceUncheckedCreateWithoutCheckedByInput>
  }

  export type AttendanceCreateManyCheckedByInputEnvelope = {
    data: AttendanceCreateManyCheckedByInput | AttendanceCreateManyCheckedByInput[]
    skipDuplicates?: boolean
  }

  export type PayslipCreateWithoutAccountInput = {
    id?: string
    periodStartDate: Date | string
    periodEndDate: Date | string
    baseSalary: number
    totalCommissions: number
    totalDeductions?: number
    totalBonuses?: number
    netPay: number
    status?: $Enums.PayslipStatus
    releasedDate?: Date | string | null
    generatedAt?: Date | string
    payslipRequest?: PayslipRequestCreateNestedOneWithoutRelatedPayslipInput
  }

  export type PayslipUncheckedCreateWithoutAccountInput = {
    id?: string
    periodStartDate: Date | string
    periodEndDate: Date | string
    baseSalary: number
    totalCommissions: number
    totalDeductions?: number
    totalBonuses?: number
    netPay: number
    status?: $Enums.PayslipStatus
    releasedDate?: Date | string | null
    generatedAt?: Date | string
    payslipRequest?: PayslipRequestUncheckedCreateNestedOneWithoutRelatedPayslipInput
  }

  export type PayslipCreateOrConnectWithoutAccountInput = {
    where: PayslipWhereUniqueInput
    create: XOR<PayslipCreateWithoutAccountInput, PayslipUncheckedCreateWithoutAccountInput>
  }

  export type PayslipCreateManyAccountInputEnvelope = {
    data: PayslipCreateManyAccountInput | PayslipCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type PayslipRequestCreateWithoutAccountInput = {
    id?: string
    requestTimestamp?: Date | string
    periodStartDate: Date | string
    periodEndDate: Date | string
    status?: $Enums.PayslipRequestStatus
    notes?: string | null
    processedTimestamp?: Date | string | null
    processedBy?: AccountCreateNestedOneWithoutManagedPayslipRequestsInput
    relatedPayslip?: PayslipCreateNestedOneWithoutPayslipRequestInput
  }

  export type PayslipRequestUncheckedCreateWithoutAccountInput = {
    id?: string
    requestTimestamp?: Date | string
    periodStartDate: Date | string
    periodEndDate: Date | string
    status?: $Enums.PayslipRequestStatus
    notes?: string | null
    processedById?: string | null
    processedTimestamp?: Date | string | null
    relatedPayslipId?: string | null
  }

  export type PayslipRequestCreateOrConnectWithoutAccountInput = {
    where: PayslipRequestWhereUniqueInput
    create: XOR<PayslipRequestCreateWithoutAccountInput, PayslipRequestUncheckedCreateWithoutAccountInput>
  }

  export type PayslipRequestCreateManyAccountInputEnvelope = {
    data: PayslipRequestCreateManyAccountInput | PayslipRequestCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type PayslipRequestCreateWithoutProcessedByInput = {
    id?: string
    requestTimestamp?: Date | string
    periodStartDate: Date | string
    periodEndDate: Date | string
    status?: $Enums.PayslipRequestStatus
    notes?: string | null
    processedTimestamp?: Date | string | null
    account: AccountCreateNestedOneWithoutPayslipRequestsInput
    relatedPayslip?: PayslipCreateNestedOneWithoutPayslipRequestInput
  }

  export type PayslipRequestUncheckedCreateWithoutProcessedByInput = {
    id?: string
    accountId: string
    requestTimestamp?: Date | string
    periodStartDate: Date | string
    periodEndDate: Date | string
    status?: $Enums.PayslipRequestStatus
    notes?: string | null
    processedTimestamp?: Date | string | null
    relatedPayslipId?: string | null
  }

  export type PayslipRequestCreateOrConnectWithoutProcessedByInput = {
    where: PayslipRequestWhereUniqueInput
    create: XOR<PayslipRequestCreateWithoutProcessedByInput, PayslipRequestUncheckedCreateWithoutProcessedByInput>
  }

  export type PayslipRequestCreateManyProcessedByInputEnvelope = {
    data: PayslipRequestCreateManyProcessedByInput | PayslipRequestCreateManyProcessedByInput[]
    skipDuplicates?: boolean
  }

  export type ManualSaleCreateWithoutRecordedByInput = {
    id?: string
    date: Date | string
    amount: number
    paymentMethod?: $Enums.PaymentMethod | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutManualSalesInput
  }

  export type ManualSaleUncheckedCreateWithoutRecordedByInput = {
    id?: string
    date: Date | string
    amount: number
    paymentMethod?: $Enums.PaymentMethod | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId?: string | null
  }

  export type ManualSaleCreateOrConnectWithoutRecordedByInput = {
    where: ManualSaleWhereUniqueInput
    create: XOR<ManualSaleCreateWithoutRecordedByInput, ManualSaleUncheckedCreateWithoutRecordedByInput>
  }

  export type ManualSaleCreateManyRecordedByInputEnvelope = {
    data: ManualSaleCreateManyRecordedByInput | ManualSaleCreateManyRecordedByInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutRecordedByInput = {
    id?: string
    date: Date | string
    amount: number
    category: $Enums.ExpenseCategory
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutRecordedByInput = {
    id?: string
    date: Date | string
    amount: number
    category: $Enums.ExpenseCategory
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId?: string | null
  }

  export type ExpenseCreateOrConnectWithoutRecordedByInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutRecordedByInput, ExpenseUncheckedCreateWithoutRecordedByInput>
  }

  export type ExpenseCreateManyRecordedByInputEnvelope = {
    data: ExpenseCreateManyRecordedByInput | ExpenseCreateManyRecordedByInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutAccountsInput = {
    update: XOR<BranchUpdateWithoutAccountsInput, BranchUncheckedUpdateWithoutAccountsInput>
    create: XOR<BranchCreateWithoutAccountsInput, BranchUncheckedCreateWithoutAccountsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutAccountsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutAccountsInput, BranchUncheckedUpdateWithoutAccountsInput>
  }

  export type BranchUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    services?: ServiceUpdateManyWithoutBranchNestedInput
    manualSales?: ManualSaleUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    Transaction?: TransactionUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    services?: ServiceUncheckedUpdateManyWithoutBranchNestedInput
    manualSales?: ManualSaleUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type AvailedServiceUpsertWithWhereUniqueWithoutServedByInput = {
    where: AvailedServiceWhereUniqueInput
    update: XOR<AvailedServiceUpdateWithoutServedByInput, AvailedServiceUncheckedUpdateWithoutServedByInput>
    create: XOR<AvailedServiceCreateWithoutServedByInput, AvailedServiceUncheckedCreateWithoutServedByInput>
  }

  export type AvailedServiceUpdateWithWhereUniqueWithoutServedByInput = {
    where: AvailedServiceWhereUniqueInput
    data: XOR<AvailedServiceUpdateWithoutServedByInput, AvailedServiceUncheckedUpdateWithoutServedByInput>
  }

  export type AvailedServiceUpdateManyWithWhereWithoutServedByInput = {
    where: AvailedServiceScalarWhereInput
    data: XOR<AvailedServiceUpdateManyMutationInput, AvailedServiceUncheckedUpdateManyWithoutServedByInput>
  }

  export type AvailedServiceScalarWhereInput = {
    AND?: AvailedServiceScalarWhereInput | AvailedServiceScalarWhereInput[]
    OR?: AvailedServiceScalarWhereInput[]
    NOT?: AvailedServiceScalarWhereInput | AvailedServiceScalarWhereInput[]
    id?: StringFilter<"AvailedService"> | string
    transactionId?: StringFilter<"AvailedService"> | string
    serviceId?: StringNullableFilter<"AvailedService"> | string | null
    quantity?: IntFilter<"AvailedService"> | number
    price?: IntFilter<"AvailedService"> | number
    commissionValue?: IntFilter<"AvailedService"> | number
    originatingSetId?: StringNullableFilter<"AvailedService"> | string | null
    originatingSetTitle?: StringNullableFilter<"AvailedService"> | string | null
    checkedById?: StringNullableFilter<"AvailedService"> | string | null
    servedById?: StringNullableFilter<"AvailedService"> | string | null
    serviceSetId?: StringNullableFilter<"AvailedService"> | string | null
    status?: EnumStatusFilter<"AvailedService"> | $Enums.Status
    completedAt?: DateTimeNullableFilter<"AvailedService"> | Date | string | null
    createdAt?: DateTimeFilter<"AvailedService"> | Date | string
    updatedAt?: DateTimeFilter<"AvailedService"> | Date | string
  }

  export type AvailedServiceUpsertWithWhereUniqueWithoutCheckedByInput = {
    where: AvailedServiceWhereUniqueInput
    update: XOR<AvailedServiceUpdateWithoutCheckedByInput, AvailedServiceUncheckedUpdateWithoutCheckedByInput>
    create: XOR<AvailedServiceCreateWithoutCheckedByInput, AvailedServiceUncheckedCreateWithoutCheckedByInput>
  }

  export type AvailedServiceUpdateWithWhereUniqueWithoutCheckedByInput = {
    where: AvailedServiceWhereUniqueInput
    data: XOR<AvailedServiceUpdateWithoutCheckedByInput, AvailedServiceUncheckedUpdateWithoutCheckedByInput>
  }

  export type AvailedServiceUpdateManyWithWhereWithoutCheckedByInput = {
    where: AvailedServiceScalarWhereInput
    data: XOR<AvailedServiceUpdateManyMutationInput, AvailedServiceUncheckedUpdateManyWithoutCheckedByInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutAccountInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutAccountInput, AttendanceUncheckedUpdateWithoutAccountInput>
    create: XOR<AttendanceCreateWithoutAccountInput, AttendanceUncheckedCreateWithoutAccountInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutAccountInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutAccountInput, AttendanceUncheckedUpdateWithoutAccountInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutAccountInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutAccountInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    accountId?: StringFilter<"Attendance"> | string
    isPresent?: BoolFilter<"Attendance"> | boolean
    notes?: StringNullableFilter<"Attendance"> | string | null
    checkedById?: StringFilter<"Attendance"> | string
    checkedAt?: DateTimeFilter<"Attendance"> | Date | string
  }

  export type AttendanceUpsertWithWhereUniqueWithoutCheckedByInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutCheckedByInput, AttendanceUncheckedUpdateWithoutCheckedByInput>
    create: XOR<AttendanceCreateWithoutCheckedByInput, AttendanceUncheckedCreateWithoutCheckedByInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutCheckedByInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutCheckedByInput, AttendanceUncheckedUpdateWithoutCheckedByInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutCheckedByInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutCheckedByInput>
  }

  export type PayslipUpsertWithWhereUniqueWithoutAccountInput = {
    where: PayslipWhereUniqueInput
    update: XOR<PayslipUpdateWithoutAccountInput, PayslipUncheckedUpdateWithoutAccountInput>
    create: XOR<PayslipCreateWithoutAccountInput, PayslipUncheckedCreateWithoutAccountInput>
  }

  export type PayslipUpdateWithWhereUniqueWithoutAccountInput = {
    where: PayslipWhereUniqueInput
    data: XOR<PayslipUpdateWithoutAccountInput, PayslipUncheckedUpdateWithoutAccountInput>
  }

  export type PayslipUpdateManyWithWhereWithoutAccountInput = {
    where: PayslipScalarWhereInput
    data: XOR<PayslipUpdateManyMutationInput, PayslipUncheckedUpdateManyWithoutAccountInput>
  }

  export type PayslipScalarWhereInput = {
    AND?: PayslipScalarWhereInput | PayslipScalarWhereInput[]
    OR?: PayslipScalarWhereInput[]
    NOT?: PayslipScalarWhereInput | PayslipScalarWhereInput[]
    id?: StringFilter<"Payslip"> | string
    accountId?: StringFilter<"Payslip"> | string
    periodStartDate?: DateTimeFilter<"Payslip"> | Date | string
    periodEndDate?: DateTimeFilter<"Payslip"> | Date | string
    baseSalary?: IntFilter<"Payslip"> | number
    totalCommissions?: IntFilter<"Payslip"> | number
    totalDeductions?: IntFilter<"Payslip"> | number
    totalBonuses?: IntFilter<"Payslip"> | number
    netPay?: IntFilter<"Payslip"> | number
    status?: EnumPayslipStatusFilter<"Payslip"> | $Enums.PayslipStatus
    releasedDate?: DateTimeNullableFilter<"Payslip"> | Date | string | null
    generatedAt?: DateTimeFilter<"Payslip"> | Date | string
  }

  export type PayslipRequestUpsertWithWhereUniqueWithoutAccountInput = {
    where: PayslipRequestWhereUniqueInput
    update: XOR<PayslipRequestUpdateWithoutAccountInput, PayslipRequestUncheckedUpdateWithoutAccountInput>
    create: XOR<PayslipRequestCreateWithoutAccountInput, PayslipRequestUncheckedCreateWithoutAccountInput>
  }

  export type PayslipRequestUpdateWithWhereUniqueWithoutAccountInput = {
    where: PayslipRequestWhereUniqueInput
    data: XOR<PayslipRequestUpdateWithoutAccountInput, PayslipRequestUncheckedUpdateWithoutAccountInput>
  }

  export type PayslipRequestUpdateManyWithWhereWithoutAccountInput = {
    where: PayslipRequestScalarWhereInput
    data: XOR<PayslipRequestUpdateManyMutationInput, PayslipRequestUncheckedUpdateManyWithoutAccountInput>
  }

  export type PayslipRequestScalarWhereInput = {
    AND?: PayslipRequestScalarWhereInput | PayslipRequestScalarWhereInput[]
    OR?: PayslipRequestScalarWhereInput[]
    NOT?: PayslipRequestScalarWhereInput | PayslipRequestScalarWhereInput[]
    id?: StringFilter<"PayslipRequest"> | string
    accountId?: StringFilter<"PayslipRequest"> | string
    requestTimestamp?: DateTimeFilter<"PayslipRequest"> | Date | string
    periodStartDate?: DateTimeFilter<"PayslipRequest"> | Date | string
    periodEndDate?: DateTimeFilter<"PayslipRequest"> | Date | string
    status?: EnumPayslipRequestStatusFilter<"PayslipRequest"> | $Enums.PayslipRequestStatus
    notes?: StringNullableFilter<"PayslipRequest"> | string | null
    processedById?: StringNullableFilter<"PayslipRequest"> | string | null
    processedTimestamp?: DateTimeNullableFilter<"PayslipRequest"> | Date | string | null
    relatedPayslipId?: StringNullableFilter<"PayslipRequest"> | string | null
  }

  export type PayslipRequestUpsertWithWhereUniqueWithoutProcessedByInput = {
    where: PayslipRequestWhereUniqueInput
    update: XOR<PayslipRequestUpdateWithoutProcessedByInput, PayslipRequestUncheckedUpdateWithoutProcessedByInput>
    create: XOR<PayslipRequestCreateWithoutProcessedByInput, PayslipRequestUncheckedCreateWithoutProcessedByInput>
  }

  export type PayslipRequestUpdateWithWhereUniqueWithoutProcessedByInput = {
    where: PayslipRequestWhereUniqueInput
    data: XOR<PayslipRequestUpdateWithoutProcessedByInput, PayslipRequestUncheckedUpdateWithoutProcessedByInput>
  }

  export type PayslipRequestUpdateManyWithWhereWithoutProcessedByInput = {
    where: PayslipRequestScalarWhereInput
    data: XOR<PayslipRequestUpdateManyMutationInput, PayslipRequestUncheckedUpdateManyWithoutProcessedByInput>
  }

  export type ManualSaleUpsertWithWhereUniqueWithoutRecordedByInput = {
    where: ManualSaleWhereUniqueInput
    update: XOR<ManualSaleUpdateWithoutRecordedByInput, ManualSaleUncheckedUpdateWithoutRecordedByInput>
    create: XOR<ManualSaleCreateWithoutRecordedByInput, ManualSaleUncheckedCreateWithoutRecordedByInput>
  }

  export type ManualSaleUpdateWithWhereUniqueWithoutRecordedByInput = {
    where: ManualSaleWhereUniqueInput
    data: XOR<ManualSaleUpdateWithoutRecordedByInput, ManualSaleUncheckedUpdateWithoutRecordedByInput>
  }

  export type ManualSaleUpdateManyWithWhereWithoutRecordedByInput = {
    where: ManualSaleScalarWhereInput
    data: XOR<ManualSaleUpdateManyMutationInput, ManualSaleUncheckedUpdateManyWithoutRecordedByInput>
  }

  export type ExpenseUpsertWithWhereUniqueWithoutRecordedByInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutRecordedByInput, ExpenseUncheckedUpdateWithoutRecordedByInput>
    create: XOR<ExpenseCreateWithoutRecordedByInput, ExpenseUncheckedCreateWithoutRecordedByInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutRecordedByInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutRecordedByInput, ExpenseUncheckedUpdateWithoutRecordedByInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutRecordedByInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutRecordedByInput>
  }

  export type BranchCreateWithoutServicesInput = {
    id?: string
    title: string
    code: string
    totalSales?: number
    accounts?: AccountCreateNestedManyWithoutBranchInput
    manualSales?: ManualSaleCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    Transaction?: TransactionCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutServicesInput = {
    id?: string
    title: string
    code: string
    totalSales?: number
    accounts?: AccountUncheckedCreateNestedManyWithoutBranchInput
    manualSales?: ManualSaleUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutServicesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutServicesInput, BranchUncheckedCreateWithoutServicesInput>
  }

  export type AvailedServiceCreateWithoutServiceInput = {
    id?: string
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetTitle?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutAvailedServicesInput
    originatingSet?: ServiceSetCreateNestedOneWithoutAvailedServiceInput
    checkedBy?: AccountCreateNestedOneWithoutServicesCheckedInput
    servedBy?: AccountCreateNestedOneWithoutServicesServedInput
    recommendedAppointment?: RecommendedAppointmentCreateNestedOneWithoutOriginatingAvailedServiceInput
  }

  export type AvailedServiceUncheckedCreateWithoutServiceInput = {
    id?: string
    transactionId: string
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetId?: string | null
    originatingSetTitle?: string | null
    checkedById?: string | null
    servedById?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recommendedAppointment?: RecommendedAppointmentUncheckedCreateNestedOneWithoutOriginatingAvailedServiceInput
  }

  export type AvailedServiceCreateOrConnectWithoutServiceInput = {
    where: AvailedServiceWhereUniqueInput
    create: XOR<AvailedServiceCreateWithoutServiceInput, AvailedServiceUncheckedCreateWithoutServiceInput>
  }

  export type AvailedServiceCreateManyServiceInputEnvelope = {
    data: AvailedServiceCreateManyServiceInput | AvailedServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceSetCreateWithoutServicesInput = {
    id?: string
    title: string
    price: number
    giftCertificates?: GiftCertificateCreateNestedManyWithoutServiceSetsInput
    AvailedService?: AvailedServiceCreateNestedManyWithoutOriginatingSetInput
  }

  export type ServiceSetUncheckedCreateWithoutServicesInput = {
    id?: string
    title: string
    price: number
    giftCertificates?: GiftCertificateUncheckedCreateNestedManyWithoutServiceSetsInput
    AvailedService?: AvailedServiceUncheckedCreateNestedManyWithoutOriginatingSetInput
  }

  export type ServiceSetCreateOrConnectWithoutServicesInput = {
    where: ServiceSetWhereUniqueInput
    create: XOR<ServiceSetCreateWithoutServicesInput, ServiceSetUncheckedCreateWithoutServicesInput>
  }

  export type GiftCertificateCreateWithoutServicesInput = {
    id?: string
    code: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    recipientName?: string | null
    recipientEmail?: string | null
    usedAt?: Date | string | null
    purchaserCustomer?: CustomerCreateNestedOneWithoutPurchasedGiftCertificatesInput
    serviceSets?: ServiceSetCreateNestedManyWithoutGiftCertificatesInput
    transactions?: TransactionCreateNestedManyWithoutGiftCertificateUsedInput
  }

  export type GiftCertificateUncheckedCreateWithoutServicesInput = {
    id?: string
    code: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    purchaserCustomerId?: string | null
    recipientName?: string | null
    recipientEmail?: string | null
    usedAt?: Date | string | null
    serviceSets?: ServiceSetUncheckedCreateNestedManyWithoutGiftCertificatesInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutGiftCertificateUsedInput
  }

  export type GiftCertificateCreateOrConnectWithoutServicesInput = {
    where: GiftCertificateWhereUniqueInput
    create: XOR<GiftCertificateCreateWithoutServicesInput, GiftCertificateUncheckedCreateWithoutServicesInput>
  }

  export type DiscountRuleCreateWithoutServicesInput = {
    id?: string
    description?: string | null
    discountType: $Enums.DiscountType
    discountValue: number
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    applyToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountRuleUncheckedCreateWithoutServicesInput = {
    id?: string
    description?: string | null
    discountType: $Enums.DiscountType
    discountValue: number
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    applyToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountRuleCreateOrConnectWithoutServicesInput = {
    where: DiscountRuleWhereUniqueInput
    create: XOR<DiscountRuleCreateWithoutServicesInput, DiscountRuleUncheckedCreateWithoutServicesInput>
  }

  export type RecommendedAppointmentCreateWithoutOriginatingServiceInput = {
    id?: string
    recommendedDate: Date | string
    status?: $Enums.RecommendedAppointmentStatus
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: Date | string | null
    reminder2DaySentAt?: Date | string | null
    reminder1DaySentAt?: Date | string | null
    reminderTodaySentAt?: Date | string | null
    reminder1DayAfterSentAt?: Date | string | null
    reminder7DaySentAt?: Date | string | null
    reminder7DayAfterSentAt?: Date | string | null
    reminder14DayAfterSentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutRecommendedAppointmentsInput
    originatingTransaction?: TransactionCreateNestedOneWithoutOriginatingRecommendationsInput
    originatingAvailedService: AvailedServiceCreateNestedOneWithoutRecommendedAppointmentInput
    attendedTransaction?: TransactionCreateNestedOneWithoutAttendedAppointmentInput
  }

  export type RecommendedAppointmentUncheckedCreateWithoutOriginatingServiceInput = {
    id?: string
    customerId: string
    recommendedDate: Date | string
    originatingTransactionId?: string | null
    originatingAvailedServiceId: string
    status?: $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: string | null
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: Date | string | null
    reminder2DaySentAt?: Date | string | null
    reminder1DaySentAt?: Date | string | null
    reminderTodaySentAt?: Date | string | null
    reminder1DayAfterSentAt?: Date | string | null
    reminder7DaySentAt?: Date | string | null
    reminder7DayAfterSentAt?: Date | string | null
    reminder14DayAfterSentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecommendedAppointmentCreateOrConnectWithoutOriginatingServiceInput = {
    where: RecommendedAppointmentWhereUniqueInput
    create: XOR<RecommendedAppointmentCreateWithoutOriginatingServiceInput, RecommendedAppointmentUncheckedCreateWithoutOriginatingServiceInput>
  }

  export type RecommendedAppointmentCreateManyOriginatingServiceInputEnvelope = {
    data: RecommendedAppointmentCreateManyOriginatingServiceInput | RecommendedAppointmentCreateManyOriginatingServiceInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutServicesInput = {
    update: XOR<BranchUpdateWithoutServicesInput, BranchUncheckedUpdateWithoutServicesInput>
    create: XOR<BranchCreateWithoutServicesInput, BranchUncheckedCreateWithoutServicesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutServicesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutServicesInput, BranchUncheckedUpdateWithoutServicesInput>
  }

  export type BranchUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUpdateManyWithoutBranchNestedInput
    manualSales?: ManualSaleUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    Transaction?: TransactionUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUncheckedUpdateManyWithoutBranchNestedInput
    manualSales?: ManualSaleUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type AvailedServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: AvailedServiceWhereUniqueInput
    update: XOR<AvailedServiceUpdateWithoutServiceInput, AvailedServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<AvailedServiceCreateWithoutServiceInput, AvailedServiceUncheckedCreateWithoutServiceInput>
  }

  export type AvailedServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: AvailedServiceWhereUniqueInput
    data: XOR<AvailedServiceUpdateWithoutServiceInput, AvailedServiceUncheckedUpdateWithoutServiceInput>
  }

  export type AvailedServiceUpdateManyWithWhereWithoutServiceInput = {
    where: AvailedServiceScalarWhereInput
    data: XOR<AvailedServiceUpdateManyMutationInput, AvailedServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceSetUpsertWithWhereUniqueWithoutServicesInput = {
    where: ServiceSetWhereUniqueInput
    update: XOR<ServiceSetUpdateWithoutServicesInput, ServiceSetUncheckedUpdateWithoutServicesInput>
    create: XOR<ServiceSetCreateWithoutServicesInput, ServiceSetUncheckedCreateWithoutServicesInput>
  }

  export type ServiceSetUpdateWithWhereUniqueWithoutServicesInput = {
    where: ServiceSetWhereUniqueInput
    data: XOR<ServiceSetUpdateWithoutServicesInput, ServiceSetUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceSetUpdateManyWithWhereWithoutServicesInput = {
    where: ServiceSetScalarWhereInput
    data: XOR<ServiceSetUpdateManyMutationInput, ServiceSetUncheckedUpdateManyWithoutServicesInput>
  }

  export type ServiceSetScalarWhereInput = {
    AND?: ServiceSetScalarWhereInput | ServiceSetScalarWhereInput[]
    OR?: ServiceSetScalarWhereInput[]
    NOT?: ServiceSetScalarWhereInput | ServiceSetScalarWhereInput[]
    id?: StringFilter<"ServiceSet"> | string
    title?: StringFilter<"ServiceSet"> | string
    price?: IntFilter<"ServiceSet"> | number
  }

  export type GiftCertificateUpsertWithWhereUniqueWithoutServicesInput = {
    where: GiftCertificateWhereUniqueInput
    update: XOR<GiftCertificateUpdateWithoutServicesInput, GiftCertificateUncheckedUpdateWithoutServicesInput>
    create: XOR<GiftCertificateCreateWithoutServicesInput, GiftCertificateUncheckedCreateWithoutServicesInput>
  }

  export type GiftCertificateUpdateWithWhereUniqueWithoutServicesInput = {
    where: GiftCertificateWhereUniqueInput
    data: XOR<GiftCertificateUpdateWithoutServicesInput, GiftCertificateUncheckedUpdateWithoutServicesInput>
  }

  export type GiftCertificateUpdateManyWithWhereWithoutServicesInput = {
    where: GiftCertificateScalarWhereInput
    data: XOR<GiftCertificateUpdateManyMutationInput, GiftCertificateUncheckedUpdateManyWithoutServicesInput>
  }

  export type GiftCertificateScalarWhereInput = {
    AND?: GiftCertificateScalarWhereInput | GiftCertificateScalarWhereInput[]
    OR?: GiftCertificateScalarWhereInput[]
    NOT?: GiftCertificateScalarWhereInput | GiftCertificateScalarWhereInput[]
    id?: StringFilter<"GiftCertificate"> | string
    code?: StringFilter<"GiftCertificate"> | string
    issuedAt?: DateTimeFilter<"GiftCertificate"> | Date | string
    expiresAt?: DateTimeNullableFilter<"GiftCertificate"> | Date | string | null
    purchaserCustomerId?: StringNullableFilter<"GiftCertificate"> | string | null
    recipientName?: StringNullableFilter<"GiftCertificate"> | string | null
    recipientEmail?: StringNullableFilter<"GiftCertificate"> | string | null
    usedAt?: DateTimeNullableFilter<"GiftCertificate"> | Date | string | null
  }

  export type DiscountRuleUpsertWithWhereUniqueWithoutServicesInput = {
    where: DiscountRuleWhereUniqueInput
    update: XOR<DiscountRuleUpdateWithoutServicesInput, DiscountRuleUncheckedUpdateWithoutServicesInput>
    create: XOR<DiscountRuleCreateWithoutServicesInput, DiscountRuleUncheckedCreateWithoutServicesInput>
  }

  export type DiscountRuleUpdateWithWhereUniqueWithoutServicesInput = {
    where: DiscountRuleWhereUniqueInput
    data: XOR<DiscountRuleUpdateWithoutServicesInput, DiscountRuleUncheckedUpdateWithoutServicesInput>
  }

  export type DiscountRuleUpdateManyWithWhereWithoutServicesInput = {
    where: DiscountRuleScalarWhereInput
    data: XOR<DiscountRuleUpdateManyMutationInput, DiscountRuleUncheckedUpdateManyWithoutServicesInput>
  }

  export type DiscountRuleScalarWhereInput = {
    AND?: DiscountRuleScalarWhereInput | DiscountRuleScalarWhereInput[]
    OR?: DiscountRuleScalarWhereInput[]
    NOT?: DiscountRuleScalarWhereInput | DiscountRuleScalarWhereInput[]
    id?: StringFilter<"DiscountRule"> | string
    description?: StringNullableFilter<"DiscountRule"> | string | null
    discountType?: EnumDiscountTypeFilter<"DiscountRule"> | $Enums.DiscountType
    discountValue?: FloatFilter<"DiscountRule"> | number
    startDate?: DateTimeFilter<"DiscountRule"> | Date | string
    endDate?: DateTimeFilter<"DiscountRule"> | Date | string
    isActive?: BoolFilter<"DiscountRule"> | boolean
    applyToAll?: BoolFilter<"DiscountRule"> | boolean
    createdAt?: DateTimeFilter<"DiscountRule"> | Date | string
    updatedAt?: DateTimeFilter<"DiscountRule"> | Date | string
  }

  export type RecommendedAppointmentUpsertWithWhereUniqueWithoutOriginatingServiceInput = {
    where: RecommendedAppointmentWhereUniqueInput
    update: XOR<RecommendedAppointmentUpdateWithoutOriginatingServiceInput, RecommendedAppointmentUncheckedUpdateWithoutOriginatingServiceInput>
    create: XOR<RecommendedAppointmentCreateWithoutOriginatingServiceInput, RecommendedAppointmentUncheckedCreateWithoutOriginatingServiceInput>
  }

  export type RecommendedAppointmentUpdateWithWhereUniqueWithoutOriginatingServiceInput = {
    where: RecommendedAppointmentWhereUniqueInput
    data: XOR<RecommendedAppointmentUpdateWithoutOriginatingServiceInput, RecommendedAppointmentUncheckedUpdateWithoutOriginatingServiceInput>
  }

  export type RecommendedAppointmentUpdateManyWithWhereWithoutOriginatingServiceInput = {
    where: RecommendedAppointmentScalarWhereInput
    data: XOR<RecommendedAppointmentUpdateManyMutationInput, RecommendedAppointmentUncheckedUpdateManyWithoutOriginatingServiceInput>
  }

  export type RecommendedAppointmentScalarWhereInput = {
    AND?: RecommendedAppointmentScalarWhereInput | RecommendedAppointmentScalarWhereInput[]
    OR?: RecommendedAppointmentScalarWhereInput[]
    NOT?: RecommendedAppointmentScalarWhereInput | RecommendedAppointmentScalarWhereInput[]
    id?: StringFilter<"RecommendedAppointment"> | string
    customerId?: StringFilter<"RecommendedAppointment"> | string
    recommendedDate?: DateTimeFilter<"RecommendedAppointment"> | Date | string
    originatingTransactionId?: StringNullableFilter<"RecommendedAppointment"> | string | null
    originatingAvailedServiceId?: StringFilter<"RecommendedAppointment"> | string
    originatingServiceId?: StringFilter<"RecommendedAppointment"> | string
    status?: EnumRecommendedAppointmentStatusFilter<"RecommendedAppointment"> | $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: StringNullableFilter<"RecommendedAppointment"> | string | null
    suppressNextFollowUpGeneration?: BoolFilter<"RecommendedAppointment"> | boolean
    reminder3DaySentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminder2DaySentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminder1DaySentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminderTodaySentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminder1DayAfterSentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminder7DaySentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminder7DayAfterSentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    reminder14DayAfterSentAt?: DateTimeNullableFilter<"RecommendedAppointment"> | Date | string | null
    createdAt?: DateTimeFilter<"RecommendedAppointment"> | Date | string
    updatedAt?: DateTimeFilter<"RecommendedAppointment"> | Date | string
  }

  export type ServiceCreateWithoutServiceSetsInput = {
    id?: string
    title: string
    description?: string | null
    price?: number
    totalSales?: number
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: number | null
    followUpPolicy?: $Enums.FollowUpPolicy
    branch: BranchCreateNestedOneWithoutServicesInput
    AvailedService?: AvailedServiceCreateNestedManyWithoutServiceInput
    giftCertificates?: GiftCertificateCreateNestedManyWithoutServicesInput
    discountRules?: DiscountRuleCreateNestedManyWithoutServicesInput
    recommendedAppointments?: RecommendedAppointmentCreateNestedManyWithoutOriginatingServiceInput
  }

  export type ServiceUncheckedCreateWithoutServiceSetsInput = {
    id?: string
    title: string
    description?: string | null
    price?: number
    branchId: string
    totalSales?: number
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: number | null
    followUpPolicy?: $Enums.FollowUpPolicy
    AvailedService?: AvailedServiceUncheckedCreateNestedManyWithoutServiceInput
    giftCertificates?: GiftCertificateUncheckedCreateNestedManyWithoutServicesInput
    discountRules?: DiscountRuleUncheckedCreateNestedManyWithoutServicesInput
    recommendedAppointments?: RecommendedAppointmentUncheckedCreateNestedManyWithoutOriginatingServiceInput
  }

  export type ServiceCreateOrConnectWithoutServiceSetsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutServiceSetsInput, ServiceUncheckedCreateWithoutServiceSetsInput>
  }

  export type GiftCertificateCreateWithoutServiceSetsInput = {
    id?: string
    code: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    recipientName?: string | null
    recipientEmail?: string | null
    usedAt?: Date | string | null
    purchaserCustomer?: CustomerCreateNestedOneWithoutPurchasedGiftCertificatesInput
    services?: ServiceCreateNestedManyWithoutGiftCertificatesInput
    transactions?: TransactionCreateNestedManyWithoutGiftCertificateUsedInput
  }

  export type GiftCertificateUncheckedCreateWithoutServiceSetsInput = {
    id?: string
    code: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    purchaserCustomerId?: string | null
    recipientName?: string | null
    recipientEmail?: string | null
    usedAt?: Date | string | null
    services?: ServiceUncheckedCreateNestedManyWithoutGiftCertificatesInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutGiftCertificateUsedInput
  }

  export type GiftCertificateCreateOrConnectWithoutServiceSetsInput = {
    where: GiftCertificateWhereUniqueInput
    create: XOR<GiftCertificateCreateWithoutServiceSetsInput, GiftCertificateUncheckedCreateWithoutServiceSetsInput>
  }

  export type AvailedServiceCreateWithoutOriginatingSetInput = {
    id?: string
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetTitle?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutAvailedServicesInput
    service?: ServiceCreateNestedOneWithoutAvailedServiceInput
    checkedBy?: AccountCreateNestedOneWithoutServicesCheckedInput
    servedBy?: AccountCreateNestedOneWithoutServicesServedInput
    recommendedAppointment?: RecommendedAppointmentCreateNestedOneWithoutOriginatingAvailedServiceInput
  }

  export type AvailedServiceUncheckedCreateWithoutOriginatingSetInput = {
    id?: string
    transactionId: string
    serviceId?: string | null
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetTitle?: string | null
    checkedById?: string | null
    servedById?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recommendedAppointment?: RecommendedAppointmentUncheckedCreateNestedOneWithoutOriginatingAvailedServiceInput
  }

  export type AvailedServiceCreateOrConnectWithoutOriginatingSetInput = {
    where: AvailedServiceWhereUniqueInput
    create: XOR<AvailedServiceCreateWithoutOriginatingSetInput, AvailedServiceUncheckedCreateWithoutOriginatingSetInput>
  }

  export type AvailedServiceCreateManyOriginatingSetInputEnvelope = {
    data: AvailedServiceCreateManyOriginatingSetInput | AvailedServiceCreateManyOriginatingSetInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithWhereUniqueWithoutServiceSetsInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutServiceSetsInput, ServiceUncheckedUpdateWithoutServiceSetsInput>
    create: XOR<ServiceCreateWithoutServiceSetsInput, ServiceUncheckedCreateWithoutServiceSetsInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutServiceSetsInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutServiceSetsInput, ServiceUncheckedUpdateWithoutServiceSetsInput>
  }

  export type ServiceUpdateManyWithWhereWithoutServiceSetsInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutServiceSetsInput>
  }

  export type GiftCertificateUpsertWithWhereUniqueWithoutServiceSetsInput = {
    where: GiftCertificateWhereUniqueInput
    update: XOR<GiftCertificateUpdateWithoutServiceSetsInput, GiftCertificateUncheckedUpdateWithoutServiceSetsInput>
    create: XOR<GiftCertificateCreateWithoutServiceSetsInput, GiftCertificateUncheckedCreateWithoutServiceSetsInput>
  }

  export type GiftCertificateUpdateWithWhereUniqueWithoutServiceSetsInput = {
    where: GiftCertificateWhereUniqueInput
    data: XOR<GiftCertificateUpdateWithoutServiceSetsInput, GiftCertificateUncheckedUpdateWithoutServiceSetsInput>
  }

  export type GiftCertificateUpdateManyWithWhereWithoutServiceSetsInput = {
    where: GiftCertificateScalarWhereInput
    data: XOR<GiftCertificateUpdateManyMutationInput, GiftCertificateUncheckedUpdateManyWithoutServiceSetsInput>
  }

  export type AvailedServiceUpsertWithWhereUniqueWithoutOriginatingSetInput = {
    where: AvailedServiceWhereUniqueInput
    update: XOR<AvailedServiceUpdateWithoutOriginatingSetInput, AvailedServiceUncheckedUpdateWithoutOriginatingSetInput>
    create: XOR<AvailedServiceCreateWithoutOriginatingSetInput, AvailedServiceUncheckedCreateWithoutOriginatingSetInput>
  }

  export type AvailedServiceUpdateWithWhereUniqueWithoutOriginatingSetInput = {
    where: AvailedServiceWhereUniqueInput
    data: XOR<AvailedServiceUpdateWithoutOriginatingSetInput, AvailedServiceUncheckedUpdateWithoutOriginatingSetInput>
  }

  export type AvailedServiceUpdateManyWithWhereWithoutOriginatingSetInput = {
    where: AvailedServiceScalarWhereInput
    data: XOR<AvailedServiceUpdateManyMutationInput, AvailedServiceUncheckedUpdateManyWithoutOriginatingSetInput>
  }

  export type RecommendedAppointmentCreateWithoutCustomerInput = {
    id?: string
    recommendedDate: Date | string
    status?: $Enums.RecommendedAppointmentStatus
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: Date | string | null
    reminder2DaySentAt?: Date | string | null
    reminder1DaySentAt?: Date | string | null
    reminderTodaySentAt?: Date | string | null
    reminder1DayAfterSentAt?: Date | string | null
    reminder7DaySentAt?: Date | string | null
    reminder7DayAfterSentAt?: Date | string | null
    reminder14DayAfterSentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originatingTransaction?: TransactionCreateNestedOneWithoutOriginatingRecommendationsInput
    originatingAvailedService: AvailedServiceCreateNestedOneWithoutRecommendedAppointmentInput
    originatingService: ServiceCreateNestedOneWithoutRecommendedAppointmentsInput
    attendedTransaction?: TransactionCreateNestedOneWithoutAttendedAppointmentInput
  }

  export type RecommendedAppointmentUncheckedCreateWithoutCustomerInput = {
    id?: string
    recommendedDate: Date | string
    originatingTransactionId?: string | null
    originatingAvailedServiceId: string
    originatingServiceId: string
    status?: $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: string | null
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: Date | string | null
    reminder2DaySentAt?: Date | string | null
    reminder1DaySentAt?: Date | string | null
    reminderTodaySentAt?: Date | string | null
    reminder1DayAfterSentAt?: Date | string | null
    reminder7DaySentAt?: Date | string | null
    reminder7DayAfterSentAt?: Date | string | null
    reminder14DayAfterSentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecommendedAppointmentCreateOrConnectWithoutCustomerInput = {
    where: RecommendedAppointmentWhereUniqueInput
    create: XOR<RecommendedAppointmentCreateWithoutCustomerInput, RecommendedAppointmentUncheckedCreateWithoutCustomerInput>
  }

  export type RecommendedAppointmentCreateManyCustomerInputEnvelope = {
    data: RecommendedAppointmentCreateManyCustomerInput | RecommendedAppointmentCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutCustomerInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    bookingReminderSentAt?: Date | string | null
    availedServices?: AvailedServiceCreateNestedManyWithoutTransactionInput
    voucherUsed?: VoucherCreateNestedOneWithoutTransactionInput
    branch?: BranchCreateNestedOneWithoutTransactionInput
    giftCertificateUsed?: GiftCertificateCreateNestedOneWithoutTransactionsInput
    originatingRecommendations?: RecommendedAppointmentCreateNestedManyWithoutOriginatingTransactionInput
    attendedAppointment?: RecommendedAppointmentCreateNestedOneWithoutAttendedTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCustomerInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    voucherId?: string | null
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    branchId?: string | null
    bookingReminderSentAt?: Date | string | null
    giftCertificateId?: string | null
    availedServices?: AvailedServiceUncheckedCreateNestedManyWithoutTransactionInput
    originatingRecommendations?: RecommendedAppointmentUncheckedCreateNestedManyWithoutOriginatingTransactionInput
    attendedAppointment?: RecommendedAppointmentUncheckedCreateNestedOneWithoutAttendedTransactionInput
  }

  export type TransactionCreateOrConnectWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput>
  }

  export type TransactionCreateManyCustomerInputEnvelope = {
    data: TransactionCreateManyCustomerInput | TransactionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type GiftCertificateCreateWithoutPurchaserCustomerInput = {
    id?: string
    code: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    recipientName?: string | null
    recipientEmail?: string | null
    usedAt?: Date | string | null
    services?: ServiceCreateNestedManyWithoutGiftCertificatesInput
    serviceSets?: ServiceSetCreateNestedManyWithoutGiftCertificatesInput
    transactions?: TransactionCreateNestedManyWithoutGiftCertificateUsedInput
  }

  export type GiftCertificateUncheckedCreateWithoutPurchaserCustomerInput = {
    id?: string
    code: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    recipientName?: string | null
    recipientEmail?: string | null
    usedAt?: Date | string | null
    services?: ServiceUncheckedCreateNestedManyWithoutGiftCertificatesInput
    serviceSets?: ServiceSetUncheckedCreateNestedManyWithoutGiftCertificatesInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutGiftCertificateUsedInput
  }

  export type GiftCertificateCreateOrConnectWithoutPurchaserCustomerInput = {
    where: GiftCertificateWhereUniqueInput
    create: XOR<GiftCertificateCreateWithoutPurchaserCustomerInput, GiftCertificateUncheckedCreateWithoutPurchaserCustomerInput>
  }

  export type GiftCertificateCreateManyPurchaserCustomerInputEnvelope = {
    data: GiftCertificateCreateManyPurchaserCustomerInput | GiftCertificateCreateManyPurchaserCustomerInput[]
    skipDuplicates?: boolean
  }

  export type RecommendedAppointmentUpsertWithWhereUniqueWithoutCustomerInput = {
    where: RecommendedAppointmentWhereUniqueInput
    update: XOR<RecommendedAppointmentUpdateWithoutCustomerInput, RecommendedAppointmentUncheckedUpdateWithoutCustomerInput>
    create: XOR<RecommendedAppointmentCreateWithoutCustomerInput, RecommendedAppointmentUncheckedCreateWithoutCustomerInput>
  }

  export type RecommendedAppointmentUpdateWithWhereUniqueWithoutCustomerInput = {
    where: RecommendedAppointmentWhereUniqueInput
    data: XOR<RecommendedAppointmentUpdateWithoutCustomerInput, RecommendedAppointmentUncheckedUpdateWithoutCustomerInput>
  }

  export type RecommendedAppointmentUpdateManyWithWhereWithoutCustomerInput = {
    where: RecommendedAppointmentScalarWhereInput
    data: XOR<RecommendedAppointmentUpdateManyMutationInput, RecommendedAppointmentUncheckedUpdateManyWithoutCustomerInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCustomerInput, TransactionUncheckedUpdateWithoutCustomerInput>
    create: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCustomerInput, TransactionUncheckedUpdateWithoutCustomerInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCustomerInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type GiftCertificateUpsertWithWhereUniqueWithoutPurchaserCustomerInput = {
    where: GiftCertificateWhereUniqueInput
    update: XOR<GiftCertificateUpdateWithoutPurchaserCustomerInput, GiftCertificateUncheckedUpdateWithoutPurchaserCustomerInput>
    create: XOR<GiftCertificateCreateWithoutPurchaserCustomerInput, GiftCertificateUncheckedCreateWithoutPurchaserCustomerInput>
  }

  export type GiftCertificateUpdateWithWhereUniqueWithoutPurchaserCustomerInput = {
    where: GiftCertificateWhereUniqueInput
    data: XOR<GiftCertificateUpdateWithoutPurchaserCustomerInput, GiftCertificateUncheckedUpdateWithoutPurchaserCustomerInput>
  }

  export type GiftCertificateUpdateManyWithWhereWithoutPurchaserCustomerInput = {
    where: GiftCertificateScalarWhereInput
    data: XOR<GiftCertificateUpdateManyMutationInput, GiftCertificateUncheckedUpdateManyWithoutPurchaserCustomerInput>
  }

  export type TransactionCreateWithoutVoucherUsedInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    bookingReminderSentAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutTransactionHistoryInput
    availedServices?: AvailedServiceCreateNestedManyWithoutTransactionInput
    branch?: BranchCreateNestedOneWithoutTransactionInput
    giftCertificateUsed?: GiftCertificateCreateNestedOneWithoutTransactionsInput
    originatingRecommendations?: RecommendedAppointmentCreateNestedManyWithoutOriginatingTransactionInput
    attendedAppointment?: RecommendedAppointmentCreateNestedOneWithoutAttendedTransactionInput
  }

  export type TransactionUncheckedCreateWithoutVoucherUsedInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    customerId: string
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    branchId?: string | null
    bookingReminderSentAt?: Date | string | null
    giftCertificateId?: string | null
    availedServices?: AvailedServiceUncheckedCreateNestedManyWithoutTransactionInput
    originatingRecommendations?: RecommendedAppointmentUncheckedCreateNestedManyWithoutOriginatingTransactionInput
    attendedAppointment?: RecommendedAppointmentUncheckedCreateNestedOneWithoutAttendedTransactionInput
  }

  export type TransactionCreateOrConnectWithoutVoucherUsedInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutVoucherUsedInput, TransactionUncheckedCreateWithoutVoucherUsedInput>
  }

  export type TransactionCreateManyVoucherUsedInputEnvelope = {
    data: TransactionCreateManyVoucherUsedInput | TransactionCreateManyVoucherUsedInput[]
    skipDuplicates?: boolean
  }

  export type TransactionUpsertWithWhereUniqueWithoutVoucherUsedInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutVoucherUsedInput, TransactionUncheckedUpdateWithoutVoucherUsedInput>
    create: XOR<TransactionCreateWithoutVoucherUsedInput, TransactionUncheckedCreateWithoutVoucherUsedInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutVoucherUsedInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutVoucherUsedInput, TransactionUncheckedUpdateWithoutVoucherUsedInput>
  }

  export type TransactionUpdateManyWithWhereWithoutVoucherUsedInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutVoucherUsedInput>
  }

  export type CustomerCreateWithoutTransactionHistoryInput = {
    id?: string
    name: string
    email?: string | null
    totalPaid?: number
    nextAppointment?: Date | string | null
    recommendedAppointments?: RecommendedAppointmentCreateNestedManyWithoutCustomerInput
    purchasedGiftCertificates?: GiftCertificateCreateNestedManyWithoutPurchaserCustomerInput
  }

  export type CustomerUncheckedCreateWithoutTransactionHistoryInput = {
    id?: string
    name: string
    email?: string | null
    totalPaid?: number
    nextAppointment?: Date | string | null
    recommendedAppointments?: RecommendedAppointmentUncheckedCreateNestedManyWithoutCustomerInput
    purchasedGiftCertificates?: GiftCertificateUncheckedCreateNestedManyWithoutPurchaserCustomerInput
  }

  export type CustomerCreateOrConnectWithoutTransactionHistoryInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTransactionHistoryInput, CustomerUncheckedCreateWithoutTransactionHistoryInput>
  }

  export type AvailedServiceCreateWithoutTransactionInput = {
    id?: string
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetTitle?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutAvailedServiceInput
    originatingSet?: ServiceSetCreateNestedOneWithoutAvailedServiceInput
    checkedBy?: AccountCreateNestedOneWithoutServicesCheckedInput
    servedBy?: AccountCreateNestedOneWithoutServicesServedInput
    recommendedAppointment?: RecommendedAppointmentCreateNestedOneWithoutOriginatingAvailedServiceInput
  }

  export type AvailedServiceUncheckedCreateWithoutTransactionInput = {
    id?: string
    serviceId?: string | null
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetId?: string | null
    originatingSetTitle?: string | null
    checkedById?: string | null
    servedById?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recommendedAppointment?: RecommendedAppointmentUncheckedCreateNestedOneWithoutOriginatingAvailedServiceInput
  }

  export type AvailedServiceCreateOrConnectWithoutTransactionInput = {
    where: AvailedServiceWhereUniqueInput
    create: XOR<AvailedServiceCreateWithoutTransactionInput, AvailedServiceUncheckedCreateWithoutTransactionInput>
  }

  export type AvailedServiceCreateManyTransactionInputEnvelope = {
    data: AvailedServiceCreateManyTransactionInput | AvailedServiceCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type VoucherCreateWithoutTransactionInput = {
    id?: string
    code: string
    value: number
    usedAt?: Date | string | null
  }

  export type VoucherUncheckedCreateWithoutTransactionInput = {
    id?: string
    code: string
    value: number
    usedAt?: Date | string | null
  }

  export type VoucherCreateOrConnectWithoutTransactionInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutTransactionInput, VoucherUncheckedCreateWithoutTransactionInput>
  }

  export type BranchCreateWithoutTransactionInput = {
    id?: string
    title: string
    code: string
    totalSales?: number
    services?: ServiceCreateNestedManyWithoutBranchInput
    accounts?: AccountCreateNestedManyWithoutBranchInput
    manualSales?: ManualSaleCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutTransactionInput = {
    id?: string
    title: string
    code: string
    totalSales?: number
    services?: ServiceUncheckedCreateNestedManyWithoutBranchInput
    accounts?: AccountUncheckedCreateNestedManyWithoutBranchInput
    manualSales?: ManualSaleUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutTransactionInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutTransactionInput, BranchUncheckedCreateWithoutTransactionInput>
  }

  export type GiftCertificateCreateWithoutTransactionsInput = {
    id?: string
    code: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    recipientName?: string | null
    recipientEmail?: string | null
    usedAt?: Date | string | null
    purchaserCustomer?: CustomerCreateNestedOneWithoutPurchasedGiftCertificatesInput
    services?: ServiceCreateNestedManyWithoutGiftCertificatesInput
    serviceSets?: ServiceSetCreateNestedManyWithoutGiftCertificatesInput
  }

  export type GiftCertificateUncheckedCreateWithoutTransactionsInput = {
    id?: string
    code: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    purchaserCustomerId?: string | null
    recipientName?: string | null
    recipientEmail?: string | null
    usedAt?: Date | string | null
    services?: ServiceUncheckedCreateNestedManyWithoutGiftCertificatesInput
    serviceSets?: ServiceSetUncheckedCreateNestedManyWithoutGiftCertificatesInput
  }

  export type GiftCertificateCreateOrConnectWithoutTransactionsInput = {
    where: GiftCertificateWhereUniqueInput
    create: XOR<GiftCertificateCreateWithoutTransactionsInput, GiftCertificateUncheckedCreateWithoutTransactionsInput>
  }

  export type RecommendedAppointmentCreateWithoutOriginatingTransactionInput = {
    id?: string
    recommendedDate: Date | string
    status?: $Enums.RecommendedAppointmentStatus
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: Date | string | null
    reminder2DaySentAt?: Date | string | null
    reminder1DaySentAt?: Date | string | null
    reminderTodaySentAt?: Date | string | null
    reminder1DayAfterSentAt?: Date | string | null
    reminder7DaySentAt?: Date | string | null
    reminder7DayAfterSentAt?: Date | string | null
    reminder14DayAfterSentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutRecommendedAppointmentsInput
    originatingAvailedService: AvailedServiceCreateNestedOneWithoutRecommendedAppointmentInput
    originatingService: ServiceCreateNestedOneWithoutRecommendedAppointmentsInput
    attendedTransaction?: TransactionCreateNestedOneWithoutAttendedAppointmentInput
  }

  export type RecommendedAppointmentUncheckedCreateWithoutOriginatingTransactionInput = {
    id?: string
    customerId: string
    recommendedDate: Date | string
    originatingAvailedServiceId: string
    originatingServiceId: string
    status?: $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: string | null
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: Date | string | null
    reminder2DaySentAt?: Date | string | null
    reminder1DaySentAt?: Date | string | null
    reminderTodaySentAt?: Date | string | null
    reminder1DayAfterSentAt?: Date | string | null
    reminder7DaySentAt?: Date | string | null
    reminder7DayAfterSentAt?: Date | string | null
    reminder14DayAfterSentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecommendedAppointmentCreateOrConnectWithoutOriginatingTransactionInput = {
    where: RecommendedAppointmentWhereUniqueInput
    create: XOR<RecommendedAppointmentCreateWithoutOriginatingTransactionInput, RecommendedAppointmentUncheckedCreateWithoutOriginatingTransactionInput>
  }

  export type RecommendedAppointmentCreateManyOriginatingTransactionInputEnvelope = {
    data: RecommendedAppointmentCreateManyOriginatingTransactionInput | RecommendedAppointmentCreateManyOriginatingTransactionInput[]
    skipDuplicates?: boolean
  }

  export type RecommendedAppointmentCreateWithoutAttendedTransactionInput = {
    id?: string
    recommendedDate: Date | string
    status?: $Enums.RecommendedAppointmentStatus
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: Date | string | null
    reminder2DaySentAt?: Date | string | null
    reminder1DaySentAt?: Date | string | null
    reminderTodaySentAt?: Date | string | null
    reminder1DayAfterSentAt?: Date | string | null
    reminder7DaySentAt?: Date | string | null
    reminder7DayAfterSentAt?: Date | string | null
    reminder14DayAfterSentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutRecommendedAppointmentsInput
    originatingTransaction?: TransactionCreateNestedOneWithoutOriginatingRecommendationsInput
    originatingAvailedService: AvailedServiceCreateNestedOneWithoutRecommendedAppointmentInput
    originatingService: ServiceCreateNestedOneWithoutRecommendedAppointmentsInput
  }

  export type RecommendedAppointmentUncheckedCreateWithoutAttendedTransactionInput = {
    id?: string
    customerId: string
    recommendedDate: Date | string
    originatingTransactionId?: string | null
    originatingAvailedServiceId: string
    originatingServiceId: string
    status?: $Enums.RecommendedAppointmentStatus
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: Date | string | null
    reminder2DaySentAt?: Date | string | null
    reminder1DaySentAt?: Date | string | null
    reminderTodaySentAt?: Date | string | null
    reminder1DayAfterSentAt?: Date | string | null
    reminder7DaySentAt?: Date | string | null
    reminder7DayAfterSentAt?: Date | string | null
    reminder14DayAfterSentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecommendedAppointmentCreateOrConnectWithoutAttendedTransactionInput = {
    where: RecommendedAppointmentWhereUniqueInput
    create: XOR<RecommendedAppointmentCreateWithoutAttendedTransactionInput, RecommendedAppointmentUncheckedCreateWithoutAttendedTransactionInput>
  }

  export type CustomerUpsertWithoutTransactionHistoryInput = {
    update: XOR<CustomerUpdateWithoutTransactionHistoryInput, CustomerUncheckedUpdateWithoutTransactionHistoryInput>
    create: XOR<CustomerCreateWithoutTransactionHistoryInput, CustomerUncheckedCreateWithoutTransactionHistoryInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutTransactionHistoryInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutTransactionHistoryInput, CustomerUncheckedUpdateWithoutTransactionHistoryInput>
  }

  export type CustomerUpdateWithoutTransactionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: FloatFieldUpdateOperationsInput | number
    nextAppointment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recommendedAppointments?: RecommendedAppointmentUpdateManyWithoutCustomerNestedInput
    purchasedGiftCertificates?: GiftCertificateUpdateManyWithoutPurchaserCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTransactionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: FloatFieldUpdateOperationsInput | number
    nextAppointment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recommendedAppointments?: RecommendedAppointmentUncheckedUpdateManyWithoutCustomerNestedInput
    purchasedGiftCertificates?: GiftCertificateUncheckedUpdateManyWithoutPurchaserCustomerNestedInput
  }

  export type AvailedServiceUpsertWithWhereUniqueWithoutTransactionInput = {
    where: AvailedServiceWhereUniqueInput
    update: XOR<AvailedServiceUpdateWithoutTransactionInput, AvailedServiceUncheckedUpdateWithoutTransactionInput>
    create: XOR<AvailedServiceCreateWithoutTransactionInput, AvailedServiceUncheckedCreateWithoutTransactionInput>
  }

  export type AvailedServiceUpdateWithWhereUniqueWithoutTransactionInput = {
    where: AvailedServiceWhereUniqueInput
    data: XOR<AvailedServiceUpdateWithoutTransactionInput, AvailedServiceUncheckedUpdateWithoutTransactionInput>
  }

  export type AvailedServiceUpdateManyWithWhereWithoutTransactionInput = {
    where: AvailedServiceScalarWhereInput
    data: XOR<AvailedServiceUpdateManyMutationInput, AvailedServiceUncheckedUpdateManyWithoutTransactionInput>
  }

  export type VoucherUpsertWithoutTransactionInput = {
    update: XOR<VoucherUpdateWithoutTransactionInput, VoucherUncheckedUpdateWithoutTransactionInput>
    create: XOR<VoucherCreateWithoutTransactionInput, VoucherUncheckedCreateWithoutTransactionInput>
    where?: VoucherWhereInput
  }

  export type VoucherUpdateToOneWithWhereWithoutTransactionInput = {
    where?: VoucherWhereInput
    data: XOR<VoucherUpdateWithoutTransactionInput, VoucherUncheckedUpdateWithoutTransactionInput>
  }

  export type VoucherUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BranchUpsertWithoutTransactionInput = {
    update: XOR<BranchUpdateWithoutTransactionInput, BranchUncheckedUpdateWithoutTransactionInput>
    create: XOR<BranchCreateWithoutTransactionInput, BranchUncheckedCreateWithoutTransactionInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutTransactionInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutTransactionInput, BranchUncheckedUpdateWithoutTransactionInput>
  }

  export type BranchUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    services?: ServiceUpdateManyWithoutBranchNestedInput
    accounts?: AccountUpdateManyWithoutBranchNestedInput
    manualSales?: ManualSaleUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    services?: ServiceUncheckedUpdateManyWithoutBranchNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutBranchNestedInput
    manualSales?: ManualSaleUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type GiftCertificateUpsertWithoutTransactionsInput = {
    update: XOR<GiftCertificateUpdateWithoutTransactionsInput, GiftCertificateUncheckedUpdateWithoutTransactionsInput>
    create: XOR<GiftCertificateCreateWithoutTransactionsInput, GiftCertificateUncheckedCreateWithoutTransactionsInput>
    where?: GiftCertificateWhereInput
  }

  export type GiftCertificateUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: GiftCertificateWhereInput
    data: XOR<GiftCertificateUpdateWithoutTransactionsInput, GiftCertificateUncheckedUpdateWithoutTransactionsInput>
  }

  export type GiftCertificateUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaserCustomer?: CustomerUpdateOneWithoutPurchasedGiftCertificatesNestedInput
    services?: ServiceUpdateManyWithoutGiftCertificatesNestedInput
    serviceSets?: ServiceSetUpdateManyWithoutGiftCertificatesNestedInput
  }

  export type GiftCertificateUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaserCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: ServiceUncheckedUpdateManyWithoutGiftCertificatesNestedInput
    serviceSets?: ServiceSetUncheckedUpdateManyWithoutGiftCertificatesNestedInput
  }

  export type RecommendedAppointmentUpsertWithWhereUniqueWithoutOriginatingTransactionInput = {
    where: RecommendedAppointmentWhereUniqueInput
    update: XOR<RecommendedAppointmentUpdateWithoutOriginatingTransactionInput, RecommendedAppointmentUncheckedUpdateWithoutOriginatingTransactionInput>
    create: XOR<RecommendedAppointmentCreateWithoutOriginatingTransactionInput, RecommendedAppointmentUncheckedCreateWithoutOriginatingTransactionInput>
  }

  export type RecommendedAppointmentUpdateWithWhereUniqueWithoutOriginatingTransactionInput = {
    where: RecommendedAppointmentWhereUniqueInput
    data: XOR<RecommendedAppointmentUpdateWithoutOriginatingTransactionInput, RecommendedAppointmentUncheckedUpdateWithoutOriginatingTransactionInput>
  }

  export type RecommendedAppointmentUpdateManyWithWhereWithoutOriginatingTransactionInput = {
    where: RecommendedAppointmentScalarWhereInput
    data: XOR<RecommendedAppointmentUpdateManyMutationInput, RecommendedAppointmentUncheckedUpdateManyWithoutOriginatingTransactionInput>
  }

  export type RecommendedAppointmentUpsertWithoutAttendedTransactionInput = {
    update: XOR<RecommendedAppointmentUpdateWithoutAttendedTransactionInput, RecommendedAppointmentUncheckedUpdateWithoutAttendedTransactionInput>
    create: XOR<RecommendedAppointmentCreateWithoutAttendedTransactionInput, RecommendedAppointmentUncheckedCreateWithoutAttendedTransactionInput>
    where?: RecommendedAppointmentWhereInput
  }

  export type RecommendedAppointmentUpdateToOneWithWhereWithoutAttendedTransactionInput = {
    where?: RecommendedAppointmentWhereInput
    data: XOR<RecommendedAppointmentUpdateWithoutAttendedTransactionInput, RecommendedAppointmentUncheckedUpdateWithoutAttendedTransactionInput>
  }

  export type RecommendedAppointmentUpdateWithoutAttendedTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recommendedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRecommendedAppointmentStatusFieldUpdateOperationsInput | $Enums.RecommendedAppointmentStatus
    suppressNextFollowUpGeneration?: BoolFieldUpdateOperationsInput | boolean
    reminder3DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTodaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder14DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutRecommendedAppointmentsNestedInput
    originatingTransaction?: TransactionUpdateOneWithoutOriginatingRecommendationsNestedInput
    originatingAvailedService?: AvailedServiceUpdateOneRequiredWithoutRecommendedAppointmentNestedInput
    originatingService?: ServiceUpdateOneRequiredWithoutRecommendedAppointmentsNestedInput
  }

  export type RecommendedAppointmentUncheckedUpdateWithoutAttendedTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    recommendedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    originatingTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingAvailedServiceId?: StringFieldUpdateOperationsInput | string
    originatingServiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumRecommendedAppointmentStatusFieldUpdateOperationsInput | $Enums.RecommendedAppointmentStatus
    suppressNextFollowUpGeneration?: BoolFieldUpdateOperationsInput | boolean
    reminder3DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTodaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder14DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateWithoutAvailedServicesInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    bookingReminderSentAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutTransactionHistoryInput
    voucherUsed?: VoucherCreateNestedOneWithoutTransactionInput
    branch?: BranchCreateNestedOneWithoutTransactionInput
    giftCertificateUsed?: GiftCertificateCreateNestedOneWithoutTransactionsInput
    originatingRecommendations?: RecommendedAppointmentCreateNestedManyWithoutOriginatingTransactionInput
    attendedAppointment?: RecommendedAppointmentCreateNestedOneWithoutAttendedTransactionInput
  }

  export type TransactionUncheckedCreateWithoutAvailedServicesInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    customerId: string
    voucherId?: string | null
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    branchId?: string | null
    bookingReminderSentAt?: Date | string | null
    giftCertificateId?: string | null
    originatingRecommendations?: RecommendedAppointmentUncheckedCreateNestedManyWithoutOriginatingTransactionInput
    attendedAppointment?: RecommendedAppointmentUncheckedCreateNestedOneWithoutAttendedTransactionInput
  }

  export type TransactionCreateOrConnectWithoutAvailedServicesInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutAvailedServicesInput, TransactionUncheckedCreateWithoutAvailedServicesInput>
  }

  export type ServiceCreateWithoutAvailedServiceInput = {
    id?: string
    title: string
    description?: string | null
    price?: number
    totalSales?: number
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: number | null
    followUpPolicy?: $Enums.FollowUpPolicy
    branch: BranchCreateNestedOneWithoutServicesInput
    serviceSets?: ServiceSetCreateNestedManyWithoutServicesInput
    giftCertificates?: GiftCertificateCreateNestedManyWithoutServicesInput
    discountRules?: DiscountRuleCreateNestedManyWithoutServicesInput
    recommendedAppointments?: RecommendedAppointmentCreateNestedManyWithoutOriginatingServiceInput
  }

  export type ServiceUncheckedCreateWithoutAvailedServiceInput = {
    id?: string
    title: string
    description?: string | null
    price?: number
    branchId: string
    totalSales?: number
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: number | null
    followUpPolicy?: $Enums.FollowUpPolicy
    serviceSets?: ServiceSetUncheckedCreateNestedManyWithoutServicesInput
    giftCertificates?: GiftCertificateUncheckedCreateNestedManyWithoutServicesInput
    discountRules?: DiscountRuleUncheckedCreateNestedManyWithoutServicesInput
    recommendedAppointments?: RecommendedAppointmentUncheckedCreateNestedManyWithoutOriginatingServiceInput
  }

  export type ServiceCreateOrConnectWithoutAvailedServiceInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutAvailedServiceInput, ServiceUncheckedCreateWithoutAvailedServiceInput>
  }

  export type ServiceSetCreateWithoutAvailedServiceInput = {
    id?: string
    title: string
    price: number
    services?: ServiceCreateNestedManyWithoutServiceSetsInput
    giftCertificates?: GiftCertificateCreateNestedManyWithoutServiceSetsInput
  }

  export type ServiceSetUncheckedCreateWithoutAvailedServiceInput = {
    id?: string
    title: string
    price: number
    services?: ServiceUncheckedCreateNestedManyWithoutServiceSetsInput
    giftCertificates?: GiftCertificateUncheckedCreateNestedManyWithoutServiceSetsInput
  }

  export type ServiceSetCreateOrConnectWithoutAvailedServiceInput = {
    where: ServiceSetWhereUniqueInput
    create: XOR<ServiceSetCreateWithoutAvailedServiceInput, ServiceSetUncheckedCreateWithoutAvailedServiceInput>
  }

  export type AccountCreateWithoutServicesCheckedInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    branch?: BranchCreateNestedOneWithoutAccountsInput
    servicesServed?: AvailedServiceCreateNestedManyWithoutServedByInput
    attendances?: AttendanceCreateNestedManyWithoutAccountInput
    attendancesChecked?: AttendanceCreateNestedManyWithoutCheckedByInput
    payslips?: PayslipCreateNestedManyWithoutAccountInput
    payslipRequests?: PayslipRequestCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestCreateNestedManyWithoutProcessedByInput
    manualSales?: ManualSaleCreateNestedManyWithoutRecordedByInput
    expenses?: ExpenseCreateNestedManyWithoutRecordedByInput
  }

  export type AccountUncheckedCreateWithoutServicesCheckedInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    branchId?: string | null
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    servicesServed?: AvailedServiceUncheckedCreateNestedManyWithoutServedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutAccountInput
    attendancesChecked?: AttendanceUncheckedCreateNestedManyWithoutCheckedByInput
    payslips?: PayslipUncheckedCreateNestedManyWithoutAccountInput
    payslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutProcessedByInput
    manualSales?: ManualSaleUncheckedCreateNestedManyWithoutRecordedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type AccountCreateOrConnectWithoutServicesCheckedInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutServicesCheckedInput, AccountUncheckedCreateWithoutServicesCheckedInput>
  }

  export type AccountCreateWithoutServicesServedInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    branch?: BranchCreateNestedOneWithoutAccountsInput
    servicesChecked?: AvailedServiceCreateNestedManyWithoutCheckedByInput
    attendances?: AttendanceCreateNestedManyWithoutAccountInput
    attendancesChecked?: AttendanceCreateNestedManyWithoutCheckedByInput
    payslips?: PayslipCreateNestedManyWithoutAccountInput
    payslipRequests?: PayslipRequestCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestCreateNestedManyWithoutProcessedByInput
    manualSales?: ManualSaleCreateNestedManyWithoutRecordedByInput
    expenses?: ExpenseCreateNestedManyWithoutRecordedByInput
  }

  export type AccountUncheckedCreateWithoutServicesServedInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    branchId?: string | null
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    servicesChecked?: AvailedServiceUncheckedCreateNestedManyWithoutCheckedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutAccountInput
    attendancesChecked?: AttendanceUncheckedCreateNestedManyWithoutCheckedByInput
    payslips?: PayslipUncheckedCreateNestedManyWithoutAccountInput
    payslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutProcessedByInput
    manualSales?: ManualSaleUncheckedCreateNestedManyWithoutRecordedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type AccountCreateOrConnectWithoutServicesServedInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutServicesServedInput, AccountUncheckedCreateWithoutServicesServedInput>
  }

  export type RecommendedAppointmentCreateWithoutOriginatingAvailedServiceInput = {
    id?: string
    recommendedDate: Date | string
    status?: $Enums.RecommendedAppointmentStatus
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: Date | string | null
    reminder2DaySentAt?: Date | string | null
    reminder1DaySentAt?: Date | string | null
    reminderTodaySentAt?: Date | string | null
    reminder1DayAfterSentAt?: Date | string | null
    reminder7DaySentAt?: Date | string | null
    reminder7DayAfterSentAt?: Date | string | null
    reminder14DayAfterSentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutRecommendedAppointmentsInput
    originatingTransaction?: TransactionCreateNestedOneWithoutOriginatingRecommendationsInput
    originatingService: ServiceCreateNestedOneWithoutRecommendedAppointmentsInput
    attendedTransaction?: TransactionCreateNestedOneWithoutAttendedAppointmentInput
  }

  export type RecommendedAppointmentUncheckedCreateWithoutOriginatingAvailedServiceInput = {
    id?: string
    customerId: string
    recommendedDate: Date | string
    originatingTransactionId?: string | null
    originatingServiceId: string
    status?: $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: string | null
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: Date | string | null
    reminder2DaySentAt?: Date | string | null
    reminder1DaySentAt?: Date | string | null
    reminderTodaySentAt?: Date | string | null
    reminder1DayAfterSentAt?: Date | string | null
    reminder7DaySentAt?: Date | string | null
    reminder7DayAfterSentAt?: Date | string | null
    reminder14DayAfterSentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecommendedAppointmentCreateOrConnectWithoutOriginatingAvailedServiceInput = {
    where: RecommendedAppointmentWhereUniqueInput
    create: XOR<RecommendedAppointmentCreateWithoutOriginatingAvailedServiceInput, RecommendedAppointmentUncheckedCreateWithoutOriginatingAvailedServiceInput>
  }

  export type TransactionUpsertWithoutAvailedServicesInput = {
    update: XOR<TransactionUpdateWithoutAvailedServicesInput, TransactionUncheckedUpdateWithoutAvailedServicesInput>
    create: XOR<TransactionCreateWithoutAvailedServicesInput, TransactionUncheckedCreateWithoutAvailedServicesInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutAvailedServicesInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutAvailedServicesInput, TransactionUncheckedUpdateWithoutAvailedServicesInput>
  }

  export type TransactionUpdateWithoutAvailedServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutTransactionHistoryNestedInput
    voucherUsed?: VoucherUpdateOneWithoutTransactionNestedInput
    branch?: BranchUpdateOneWithoutTransactionNestedInput
    giftCertificateUsed?: GiftCertificateUpdateOneWithoutTransactionsNestedInput
    originatingRecommendations?: RecommendedAppointmentUpdateManyWithoutOriginatingTransactionNestedInput
    attendedAppointment?: RecommendedAppointmentUpdateOneWithoutAttendedTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutAvailedServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    giftCertificateId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingRecommendations?: RecommendedAppointmentUncheckedUpdateManyWithoutOriginatingTransactionNestedInput
    attendedAppointment?: RecommendedAppointmentUncheckedUpdateOneWithoutAttendedTransactionNestedInput
  }

  export type ServiceUpsertWithoutAvailedServiceInput = {
    update: XOR<ServiceUpdateWithoutAvailedServiceInput, ServiceUncheckedUpdateWithoutAvailedServiceInput>
    create: XOR<ServiceCreateWithoutAvailedServiceInput, ServiceUncheckedCreateWithoutAvailedServiceInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutAvailedServiceInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutAvailedServiceInput, ServiceUncheckedUpdateWithoutAvailedServiceInput>
  }

  export type ServiceUpdateWithoutAvailedServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
    branch?: BranchUpdateOneRequiredWithoutServicesNestedInput
    serviceSets?: ServiceSetUpdateManyWithoutServicesNestedInput
    giftCertificates?: GiftCertificateUpdateManyWithoutServicesNestedInput
    discountRules?: DiscountRuleUpdateManyWithoutServicesNestedInput
    recommendedAppointments?: RecommendedAppointmentUpdateManyWithoutOriginatingServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutAvailedServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    branchId?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
    serviceSets?: ServiceSetUncheckedUpdateManyWithoutServicesNestedInput
    giftCertificates?: GiftCertificateUncheckedUpdateManyWithoutServicesNestedInput
    discountRules?: DiscountRuleUncheckedUpdateManyWithoutServicesNestedInput
    recommendedAppointments?: RecommendedAppointmentUncheckedUpdateManyWithoutOriginatingServiceNestedInput
  }

  export type ServiceSetUpsertWithoutAvailedServiceInput = {
    update: XOR<ServiceSetUpdateWithoutAvailedServiceInput, ServiceSetUncheckedUpdateWithoutAvailedServiceInput>
    create: XOR<ServiceSetCreateWithoutAvailedServiceInput, ServiceSetUncheckedCreateWithoutAvailedServiceInput>
    where?: ServiceSetWhereInput
  }

  export type ServiceSetUpdateToOneWithWhereWithoutAvailedServiceInput = {
    where?: ServiceSetWhereInput
    data: XOR<ServiceSetUpdateWithoutAvailedServiceInput, ServiceSetUncheckedUpdateWithoutAvailedServiceInput>
  }

  export type ServiceSetUpdateWithoutAvailedServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    services?: ServiceUpdateManyWithoutServiceSetsNestedInput
    giftCertificates?: GiftCertificateUpdateManyWithoutServiceSetsNestedInput
  }

  export type ServiceSetUncheckedUpdateWithoutAvailedServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    services?: ServiceUncheckedUpdateManyWithoutServiceSetsNestedInput
    giftCertificates?: GiftCertificateUncheckedUpdateManyWithoutServiceSetsNestedInput
  }

  export type AccountUpsertWithoutServicesCheckedInput = {
    update: XOR<AccountUpdateWithoutServicesCheckedInput, AccountUncheckedUpdateWithoutServicesCheckedInput>
    create: XOR<AccountCreateWithoutServicesCheckedInput, AccountUncheckedCreateWithoutServicesCheckedInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutServicesCheckedInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutServicesCheckedInput, AccountUncheckedUpdateWithoutServicesCheckedInput>
  }

  export type AccountUpdateWithoutServicesCheckedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    branch?: BranchUpdateOneWithoutAccountsNestedInput
    servicesServed?: AvailedServiceUpdateManyWithoutServedByNestedInput
    attendances?: AttendanceUpdateManyWithoutAccountNestedInput
    attendancesChecked?: AttendanceUpdateManyWithoutCheckedByNestedInput
    payslips?: PayslipUpdateManyWithoutAccountNestedInput
    payslipRequests?: PayslipRequestUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUpdateManyWithoutProcessedByNestedInput
    manualSales?: ManualSaleUpdateManyWithoutRecordedByNestedInput
    expenses?: ExpenseUpdateManyWithoutRecordedByNestedInput
  }

  export type AccountUncheckedUpdateWithoutServicesCheckedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    servicesServed?: AvailedServiceUncheckedUpdateManyWithoutServedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutAccountNestedInput
    attendancesChecked?: AttendanceUncheckedUpdateManyWithoutCheckedByNestedInput
    payslips?: PayslipUncheckedUpdateManyWithoutAccountNestedInput
    payslipRequests?: PayslipRequestUncheckedUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    manualSales?: ManualSaleUncheckedUpdateManyWithoutRecordedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type AccountUpsertWithoutServicesServedInput = {
    update: XOR<AccountUpdateWithoutServicesServedInput, AccountUncheckedUpdateWithoutServicesServedInput>
    create: XOR<AccountCreateWithoutServicesServedInput, AccountUncheckedCreateWithoutServicesServedInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutServicesServedInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutServicesServedInput, AccountUncheckedUpdateWithoutServicesServedInput>
  }

  export type AccountUpdateWithoutServicesServedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    branch?: BranchUpdateOneWithoutAccountsNestedInput
    servicesChecked?: AvailedServiceUpdateManyWithoutCheckedByNestedInput
    attendances?: AttendanceUpdateManyWithoutAccountNestedInput
    attendancesChecked?: AttendanceUpdateManyWithoutCheckedByNestedInput
    payslips?: PayslipUpdateManyWithoutAccountNestedInput
    payslipRequests?: PayslipRequestUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUpdateManyWithoutProcessedByNestedInput
    manualSales?: ManualSaleUpdateManyWithoutRecordedByNestedInput
    expenses?: ExpenseUpdateManyWithoutRecordedByNestedInput
  }

  export type AccountUncheckedUpdateWithoutServicesServedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    servicesChecked?: AvailedServiceUncheckedUpdateManyWithoutCheckedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutAccountNestedInput
    attendancesChecked?: AttendanceUncheckedUpdateManyWithoutCheckedByNestedInput
    payslips?: PayslipUncheckedUpdateManyWithoutAccountNestedInput
    payslipRequests?: PayslipRequestUncheckedUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    manualSales?: ManualSaleUncheckedUpdateManyWithoutRecordedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type RecommendedAppointmentUpsertWithoutOriginatingAvailedServiceInput = {
    update: XOR<RecommendedAppointmentUpdateWithoutOriginatingAvailedServiceInput, RecommendedAppointmentUncheckedUpdateWithoutOriginatingAvailedServiceInput>
    create: XOR<RecommendedAppointmentCreateWithoutOriginatingAvailedServiceInput, RecommendedAppointmentUncheckedCreateWithoutOriginatingAvailedServiceInput>
    where?: RecommendedAppointmentWhereInput
  }

  export type RecommendedAppointmentUpdateToOneWithWhereWithoutOriginatingAvailedServiceInput = {
    where?: RecommendedAppointmentWhereInput
    data: XOR<RecommendedAppointmentUpdateWithoutOriginatingAvailedServiceInput, RecommendedAppointmentUncheckedUpdateWithoutOriginatingAvailedServiceInput>
  }

  export type RecommendedAppointmentUpdateWithoutOriginatingAvailedServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    recommendedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRecommendedAppointmentStatusFieldUpdateOperationsInput | $Enums.RecommendedAppointmentStatus
    suppressNextFollowUpGeneration?: BoolFieldUpdateOperationsInput | boolean
    reminder3DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTodaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder14DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutRecommendedAppointmentsNestedInput
    originatingTransaction?: TransactionUpdateOneWithoutOriginatingRecommendationsNestedInput
    originatingService?: ServiceUpdateOneRequiredWithoutRecommendedAppointmentsNestedInput
    attendedTransaction?: TransactionUpdateOneWithoutAttendedAppointmentNestedInput
  }

  export type RecommendedAppointmentUncheckedUpdateWithoutOriginatingAvailedServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    recommendedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    originatingTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingServiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumRecommendedAppointmentStatusFieldUpdateOperationsInput | $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    suppressNextFollowUpGeneration?: BoolFieldUpdateOperationsInput | boolean
    reminder3DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTodaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder14DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateWithoutPurchasedGiftCertificatesInput = {
    id?: string
    name: string
    email?: string | null
    totalPaid?: number
    nextAppointment?: Date | string | null
    recommendedAppointments?: RecommendedAppointmentCreateNestedManyWithoutCustomerInput
    transactionHistory?: TransactionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPurchasedGiftCertificatesInput = {
    id?: string
    name: string
    email?: string | null
    totalPaid?: number
    nextAppointment?: Date | string | null
    recommendedAppointments?: RecommendedAppointmentUncheckedCreateNestedManyWithoutCustomerInput
    transactionHistory?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPurchasedGiftCertificatesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPurchasedGiftCertificatesInput, CustomerUncheckedCreateWithoutPurchasedGiftCertificatesInput>
  }

  export type ServiceCreateWithoutGiftCertificatesInput = {
    id?: string
    title: string
    description?: string | null
    price?: number
    totalSales?: number
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: number | null
    followUpPolicy?: $Enums.FollowUpPolicy
    branch: BranchCreateNestedOneWithoutServicesInput
    AvailedService?: AvailedServiceCreateNestedManyWithoutServiceInput
    serviceSets?: ServiceSetCreateNestedManyWithoutServicesInput
    discountRules?: DiscountRuleCreateNestedManyWithoutServicesInput
    recommendedAppointments?: RecommendedAppointmentCreateNestedManyWithoutOriginatingServiceInput
  }

  export type ServiceUncheckedCreateWithoutGiftCertificatesInput = {
    id?: string
    title: string
    description?: string | null
    price?: number
    branchId: string
    totalSales?: number
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: number | null
    followUpPolicy?: $Enums.FollowUpPolicy
    AvailedService?: AvailedServiceUncheckedCreateNestedManyWithoutServiceInput
    serviceSets?: ServiceSetUncheckedCreateNestedManyWithoutServicesInput
    discountRules?: DiscountRuleUncheckedCreateNestedManyWithoutServicesInput
    recommendedAppointments?: RecommendedAppointmentUncheckedCreateNestedManyWithoutOriginatingServiceInput
  }

  export type ServiceCreateOrConnectWithoutGiftCertificatesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutGiftCertificatesInput, ServiceUncheckedCreateWithoutGiftCertificatesInput>
  }

  export type ServiceSetCreateWithoutGiftCertificatesInput = {
    id?: string
    title: string
    price: number
    services?: ServiceCreateNestedManyWithoutServiceSetsInput
    AvailedService?: AvailedServiceCreateNestedManyWithoutOriginatingSetInput
  }

  export type ServiceSetUncheckedCreateWithoutGiftCertificatesInput = {
    id?: string
    title: string
    price: number
    services?: ServiceUncheckedCreateNestedManyWithoutServiceSetsInput
    AvailedService?: AvailedServiceUncheckedCreateNestedManyWithoutOriginatingSetInput
  }

  export type ServiceSetCreateOrConnectWithoutGiftCertificatesInput = {
    where: ServiceSetWhereUniqueInput
    create: XOR<ServiceSetCreateWithoutGiftCertificatesInput, ServiceSetUncheckedCreateWithoutGiftCertificatesInput>
  }

  export type TransactionCreateWithoutGiftCertificateUsedInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    bookingReminderSentAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutTransactionHistoryInput
    availedServices?: AvailedServiceCreateNestedManyWithoutTransactionInput
    voucherUsed?: VoucherCreateNestedOneWithoutTransactionInput
    branch?: BranchCreateNestedOneWithoutTransactionInput
    originatingRecommendations?: RecommendedAppointmentCreateNestedManyWithoutOriginatingTransactionInput
    attendedAppointment?: RecommendedAppointmentCreateNestedOneWithoutAttendedTransactionInput
  }

  export type TransactionUncheckedCreateWithoutGiftCertificateUsedInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    customerId: string
    voucherId?: string | null
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    branchId?: string | null
    bookingReminderSentAt?: Date | string | null
    availedServices?: AvailedServiceUncheckedCreateNestedManyWithoutTransactionInput
    originatingRecommendations?: RecommendedAppointmentUncheckedCreateNestedManyWithoutOriginatingTransactionInput
    attendedAppointment?: RecommendedAppointmentUncheckedCreateNestedOneWithoutAttendedTransactionInput
  }

  export type TransactionCreateOrConnectWithoutGiftCertificateUsedInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutGiftCertificateUsedInput, TransactionUncheckedCreateWithoutGiftCertificateUsedInput>
  }

  export type TransactionCreateManyGiftCertificateUsedInputEnvelope = {
    data: TransactionCreateManyGiftCertificateUsedInput | TransactionCreateManyGiftCertificateUsedInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutPurchasedGiftCertificatesInput = {
    update: XOR<CustomerUpdateWithoutPurchasedGiftCertificatesInput, CustomerUncheckedUpdateWithoutPurchasedGiftCertificatesInput>
    create: XOR<CustomerCreateWithoutPurchasedGiftCertificatesInput, CustomerUncheckedCreateWithoutPurchasedGiftCertificatesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPurchasedGiftCertificatesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPurchasedGiftCertificatesInput, CustomerUncheckedUpdateWithoutPurchasedGiftCertificatesInput>
  }

  export type CustomerUpdateWithoutPurchasedGiftCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: FloatFieldUpdateOperationsInput | number
    nextAppointment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recommendedAppointments?: RecommendedAppointmentUpdateManyWithoutCustomerNestedInput
    transactionHistory?: TransactionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPurchasedGiftCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: FloatFieldUpdateOperationsInput | number
    nextAppointment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recommendedAppointments?: RecommendedAppointmentUncheckedUpdateManyWithoutCustomerNestedInput
    transactionHistory?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ServiceUpsertWithWhereUniqueWithoutGiftCertificatesInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutGiftCertificatesInput, ServiceUncheckedUpdateWithoutGiftCertificatesInput>
    create: XOR<ServiceCreateWithoutGiftCertificatesInput, ServiceUncheckedCreateWithoutGiftCertificatesInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutGiftCertificatesInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutGiftCertificatesInput, ServiceUncheckedUpdateWithoutGiftCertificatesInput>
  }

  export type ServiceUpdateManyWithWhereWithoutGiftCertificatesInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutGiftCertificatesInput>
  }

  export type ServiceSetUpsertWithWhereUniqueWithoutGiftCertificatesInput = {
    where: ServiceSetWhereUniqueInput
    update: XOR<ServiceSetUpdateWithoutGiftCertificatesInput, ServiceSetUncheckedUpdateWithoutGiftCertificatesInput>
    create: XOR<ServiceSetCreateWithoutGiftCertificatesInput, ServiceSetUncheckedCreateWithoutGiftCertificatesInput>
  }

  export type ServiceSetUpdateWithWhereUniqueWithoutGiftCertificatesInput = {
    where: ServiceSetWhereUniqueInput
    data: XOR<ServiceSetUpdateWithoutGiftCertificatesInput, ServiceSetUncheckedUpdateWithoutGiftCertificatesInput>
  }

  export type ServiceSetUpdateManyWithWhereWithoutGiftCertificatesInput = {
    where: ServiceSetScalarWhereInput
    data: XOR<ServiceSetUpdateManyMutationInput, ServiceSetUncheckedUpdateManyWithoutGiftCertificatesInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutGiftCertificateUsedInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutGiftCertificateUsedInput, TransactionUncheckedUpdateWithoutGiftCertificateUsedInput>
    create: XOR<TransactionCreateWithoutGiftCertificateUsedInput, TransactionUncheckedCreateWithoutGiftCertificateUsedInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutGiftCertificateUsedInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutGiftCertificateUsedInput, TransactionUncheckedUpdateWithoutGiftCertificateUsedInput>
  }

  export type TransactionUpdateManyWithWhereWithoutGiftCertificateUsedInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutGiftCertificateUsedInput>
  }

  export type AccountCreateWithoutManualSalesInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    branch?: BranchCreateNestedOneWithoutAccountsInput
    servicesServed?: AvailedServiceCreateNestedManyWithoutServedByInput
    servicesChecked?: AvailedServiceCreateNestedManyWithoutCheckedByInput
    attendances?: AttendanceCreateNestedManyWithoutAccountInput
    attendancesChecked?: AttendanceCreateNestedManyWithoutCheckedByInput
    payslips?: PayslipCreateNestedManyWithoutAccountInput
    payslipRequests?: PayslipRequestCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestCreateNestedManyWithoutProcessedByInput
    expenses?: ExpenseCreateNestedManyWithoutRecordedByInput
  }

  export type AccountUncheckedCreateWithoutManualSalesInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    branchId?: string | null
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    servicesServed?: AvailedServiceUncheckedCreateNestedManyWithoutServedByInput
    servicesChecked?: AvailedServiceUncheckedCreateNestedManyWithoutCheckedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutAccountInput
    attendancesChecked?: AttendanceUncheckedCreateNestedManyWithoutCheckedByInput
    payslips?: PayslipUncheckedCreateNestedManyWithoutAccountInput
    payslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutProcessedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type AccountCreateOrConnectWithoutManualSalesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutManualSalesInput, AccountUncheckedCreateWithoutManualSalesInput>
  }

  export type BranchCreateWithoutManualSalesInput = {
    id?: string
    title: string
    code: string
    totalSales?: number
    services?: ServiceCreateNestedManyWithoutBranchInput
    accounts?: AccountCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    Transaction?: TransactionCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutManualSalesInput = {
    id?: string
    title: string
    code: string
    totalSales?: number
    services?: ServiceUncheckedCreateNestedManyWithoutBranchInput
    accounts?: AccountUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutManualSalesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutManualSalesInput, BranchUncheckedCreateWithoutManualSalesInput>
  }

  export type AccountUpsertWithoutManualSalesInput = {
    update: XOR<AccountUpdateWithoutManualSalesInput, AccountUncheckedUpdateWithoutManualSalesInput>
    create: XOR<AccountCreateWithoutManualSalesInput, AccountUncheckedCreateWithoutManualSalesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutManualSalesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutManualSalesInput, AccountUncheckedUpdateWithoutManualSalesInput>
  }

  export type AccountUpdateWithoutManualSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    branch?: BranchUpdateOneWithoutAccountsNestedInput
    servicesServed?: AvailedServiceUpdateManyWithoutServedByNestedInput
    servicesChecked?: AvailedServiceUpdateManyWithoutCheckedByNestedInput
    attendances?: AttendanceUpdateManyWithoutAccountNestedInput
    attendancesChecked?: AttendanceUpdateManyWithoutCheckedByNestedInput
    payslips?: PayslipUpdateManyWithoutAccountNestedInput
    payslipRequests?: PayslipRequestUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUpdateManyWithoutProcessedByNestedInput
    expenses?: ExpenseUpdateManyWithoutRecordedByNestedInput
  }

  export type AccountUncheckedUpdateWithoutManualSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    servicesServed?: AvailedServiceUncheckedUpdateManyWithoutServedByNestedInput
    servicesChecked?: AvailedServiceUncheckedUpdateManyWithoutCheckedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutAccountNestedInput
    attendancesChecked?: AttendanceUncheckedUpdateManyWithoutCheckedByNestedInput
    payslips?: PayslipUncheckedUpdateManyWithoutAccountNestedInput
    payslipRequests?: PayslipRequestUncheckedUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type BranchUpsertWithoutManualSalesInput = {
    update: XOR<BranchUpdateWithoutManualSalesInput, BranchUncheckedUpdateWithoutManualSalesInput>
    create: XOR<BranchCreateWithoutManualSalesInput, BranchUncheckedCreateWithoutManualSalesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutManualSalesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutManualSalesInput, BranchUncheckedUpdateWithoutManualSalesInput>
  }

  export type BranchUpdateWithoutManualSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    services?: ServiceUpdateManyWithoutBranchNestedInput
    accounts?: AccountUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    Transaction?: TransactionUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutManualSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    services?: ServiceUncheckedUpdateManyWithoutBranchNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type AccountCreateWithoutExpensesInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    branch?: BranchCreateNestedOneWithoutAccountsInput
    servicesServed?: AvailedServiceCreateNestedManyWithoutServedByInput
    servicesChecked?: AvailedServiceCreateNestedManyWithoutCheckedByInput
    attendances?: AttendanceCreateNestedManyWithoutAccountInput
    attendancesChecked?: AttendanceCreateNestedManyWithoutCheckedByInput
    payslips?: PayslipCreateNestedManyWithoutAccountInput
    payslipRequests?: PayslipRequestCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestCreateNestedManyWithoutProcessedByInput
    manualSales?: ManualSaleCreateNestedManyWithoutRecordedByInput
  }

  export type AccountUncheckedCreateWithoutExpensesInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    branchId?: string | null
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
    servicesServed?: AvailedServiceUncheckedCreateNestedManyWithoutServedByInput
    servicesChecked?: AvailedServiceUncheckedCreateNestedManyWithoutCheckedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutAccountInput
    attendancesChecked?: AttendanceUncheckedCreateNestedManyWithoutCheckedByInput
    payslips?: PayslipUncheckedCreateNestedManyWithoutAccountInput
    payslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutAccountInput
    managedPayslipRequests?: PayslipRequestUncheckedCreateNestedManyWithoutProcessedByInput
    manualSales?: ManualSaleUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type AccountCreateOrConnectWithoutExpensesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutExpensesInput, AccountUncheckedCreateWithoutExpensesInput>
  }

  export type BranchCreateWithoutExpensesInput = {
    id?: string
    title: string
    code: string
    totalSales?: number
    services?: ServiceCreateNestedManyWithoutBranchInput
    accounts?: AccountCreateNestedManyWithoutBranchInput
    manualSales?: ManualSaleCreateNestedManyWithoutBranchInput
    Transaction?: TransactionCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutExpensesInput = {
    id?: string
    title: string
    code: string
    totalSales?: number
    services?: ServiceUncheckedCreateNestedManyWithoutBranchInput
    accounts?: AccountUncheckedCreateNestedManyWithoutBranchInput
    manualSales?: ManualSaleUncheckedCreateNestedManyWithoutBranchInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutExpensesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutExpensesInput, BranchUncheckedCreateWithoutExpensesInput>
  }

  export type AccountUpsertWithoutExpensesInput = {
    update: XOR<AccountUpdateWithoutExpensesInput, AccountUncheckedUpdateWithoutExpensesInput>
    create: XOR<AccountCreateWithoutExpensesInput, AccountUncheckedCreateWithoutExpensesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutExpensesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutExpensesInput, AccountUncheckedUpdateWithoutExpensesInput>
  }

  export type AccountUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    branch?: BranchUpdateOneWithoutAccountsNestedInput
    servicesServed?: AvailedServiceUpdateManyWithoutServedByNestedInput
    servicesChecked?: AvailedServiceUpdateManyWithoutCheckedByNestedInput
    attendances?: AttendanceUpdateManyWithoutAccountNestedInput
    attendancesChecked?: AttendanceUpdateManyWithoutCheckedByNestedInput
    payslips?: PayslipUpdateManyWithoutAccountNestedInput
    payslipRequests?: PayslipRequestUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUpdateManyWithoutProcessedByNestedInput
    manualSales?: ManualSaleUpdateManyWithoutRecordedByNestedInput
  }

  export type AccountUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    servicesServed?: AvailedServiceUncheckedUpdateManyWithoutServedByNestedInput
    servicesChecked?: AvailedServiceUncheckedUpdateManyWithoutCheckedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutAccountNestedInput
    attendancesChecked?: AttendanceUncheckedUpdateManyWithoutCheckedByNestedInput
    payslips?: PayslipUncheckedUpdateManyWithoutAccountNestedInput
    payslipRequests?: PayslipRequestUncheckedUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    manualSales?: ManualSaleUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type BranchUpsertWithoutExpensesInput = {
    update: XOR<BranchUpdateWithoutExpensesInput, BranchUncheckedUpdateWithoutExpensesInput>
    create: XOR<BranchCreateWithoutExpensesInput, BranchUncheckedCreateWithoutExpensesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutExpensesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutExpensesInput, BranchUncheckedUpdateWithoutExpensesInput>
  }

  export type BranchUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    services?: ServiceUpdateManyWithoutBranchNestedInput
    accounts?: AccountUpdateManyWithoutBranchNestedInput
    manualSales?: ManualSaleUpdateManyWithoutBranchNestedInput
    Transaction?: TransactionUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    services?: ServiceUncheckedUpdateManyWithoutBranchNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutBranchNestedInput
    manualSales?: ManualSaleUncheckedUpdateManyWithoutBranchNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type ServiceUpdateWithoutDiscountRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
    branch?: BranchUpdateOneRequiredWithoutServicesNestedInput
    AvailedService?: AvailedServiceUpdateManyWithoutServiceNestedInput
    serviceSets?: ServiceSetUpdateManyWithoutServicesNestedInput
    giftCertificates?: GiftCertificateUpdateManyWithoutServicesNestedInput
    recommendedAppointments?: RecommendedAppointmentUpdateManyWithoutOriginatingServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutDiscountRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    branchId?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
    AvailedService?: AvailedServiceUncheckedUpdateManyWithoutServiceNestedInput
    serviceSets?: ServiceSetUncheckedUpdateManyWithoutServicesNestedInput
    giftCertificates?: GiftCertificateUncheckedUpdateManyWithoutServicesNestedInput
    recommendedAppointments?: RecommendedAppointmentUncheckedUpdateManyWithoutOriginatingServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutDiscountRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    branchId?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
  }

  export type ServiceCreateManyBranchInput = {
    id?: string
    title: string
    description?: string | null
    price?: number
    totalSales?: number
    recommendFollowUp?: boolean
    recommendedFollowUpDays?: number | null
    followUpPolicy?: $Enums.FollowUpPolicy
  }

  export type AccountCreateManyBranchInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: AccountCreateroleInput | $Enums.Role[]
    salary?: number
    dailyRate?: number
    canRequestPayslip?: boolean
    mustChangePassword?: boolean
  }

  export type ManualSaleCreateManyBranchInput = {
    id?: string
    date: Date | string
    amount: number
    paymentMethod?: $Enums.PaymentMethod | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedById: string
  }

  export type ExpenseCreateManyBranchInput = {
    id?: string
    date: Date | string
    amount: number
    category: $Enums.ExpenseCategory
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedById: string
  }

  export type TransactionCreateManyBranchInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    customerId: string
    voucherId?: string | null
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    bookingReminderSentAt?: Date | string | null
    giftCertificateId?: string | null
  }

  export type ServiceUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
    AvailedService?: AvailedServiceUpdateManyWithoutServiceNestedInput
    serviceSets?: ServiceSetUpdateManyWithoutServicesNestedInput
    giftCertificates?: GiftCertificateUpdateManyWithoutServicesNestedInput
    discountRules?: DiscountRuleUpdateManyWithoutServicesNestedInput
    recommendedAppointments?: RecommendedAppointmentUpdateManyWithoutOriginatingServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
    AvailedService?: AvailedServiceUncheckedUpdateManyWithoutServiceNestedInput
    serviceSets?: ServiceSetUncheckedUpdateManyWithoutServicesNestedInput
    giftCertificates?: GiftCertificateUncheckedUpdateManyWithoutServicesNestedInput
    discountRules?: DiscountRuleUncheckedUpdateManyWithoutServicesNestedInput
    recommendedAppointments?: RecommendedAppointmentUncheckedUpdateManyWithoutOriginatingServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
  }

  export type AccountUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    servicesServed?: AvailedServiceUpdateManyWithoutServedByNestedInput
    servicesChecked?: AvailedServiceUpdateManyWithoutCheckedByNestedInput
    attendances?: AttendanceUpdateManyWithoutAccountNestedInput
    attendancesChecked?: AttendanceUpdateManyWithoutCheckedByNestedInput
    payslips?: PayslipUpdateManyWithoutAccountNestedInput
    payslipRequests?: PayslipRequestUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUpdateManyWithoutProcessedByNestedInput
    manualSales?: ManualSaleUpdateManyWithoutRecordedByNestedInput
    expenses?: ExpenseUpdateManyWithoutRecordedByNestedInput
  }

  export type AccountUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    servicesServed?: AvailedServiceUncheckedUpdateManyWithoutServedByNestedInput
    servicesChecked?: AvailedServiceUncheckedUpdateManyWithoutCheckedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutAccountNestedInput
    attendancesChecked?: AttendanceUncheckedUpdateManyWithoutCheckedByNestedInput
    payslips?: PayslipUncheckedUpdateManyWithoutAccountNestedInput
    payslipRequests?: PayslipRequestUncheckedUpdateManyWithoutAccountNestedInput
    managedPayslipRequests?: PayslipRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    manualSales?: ManualSaleUncheckedUpdateManyWithoutRecordedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: AccountUpdateroleInput | $Enums.Role[]
    salary?: IntFieldUpdateOperationsInput | number
    dailyRate?: IntFieldUpdateOperationsInput | number
    canRequestPayslip?: BoolFieldUpdateOperationsInput | boolean
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ManualSaleUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: AccountUpdateOneRequiredWithoutManualSalesNestedInput
  }

  export type ManualSaleUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedById?: StringFieldUpdateOperationsInput | string
  }

  export type ManualSaleUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedById?: StringFieldUpdateOperationsInput | string
  }

  export type ExpenseUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: AccountUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedById?: StringFieldUpdateOperationsInput | string
  }

  export type ExpenseUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedById?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutTransactionHistoryNestedInput
    availedServices?: AvailedServiceUpdateManyWithoutTransactionNestedInput
    voucherUsed?: VoucherUpdateOneWithoutTransactionNestedInput
    giftCertificateUsed?: GiftCertificateUpdateOneWithoutTransactionsNestedInput
    originatingRecommendations?: RecommendedAppointmentUpdateManyWithoutOriginatingTransactionNestedInput
    attendedAppointment?: RecommendedAppointmentUpdateOneWithoutAttendedTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    giftCertificateId?: NullableStringFieldUpdateOperationsInput | string | null
    availedServices?: AvailedServiceUncheckedUpdateManyWithoutTransactionNestedInput
    originatingRecommendations?: RecommendedAppointmentUncheckedUpdateManyWithoutOriginatingTransactionNestedInput
    attendedAppointment?: RecommendedAppointmentUncheckedUpdateOneWithoutAttendedTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    giftCertificateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AvailedServiceCreateManyServedByInput = {
    id?: string
    transactionId: string
    serviceId?: string | null
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetId?: string | null
    originatingSetTitle?: string | null
    checkedById?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailedServiceCreateManyCheckedByInput = {
    id?: string
    transactionId: string
    serviceId?: string | null
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetId?: string | null
    originatingSetTitle?: string | null
    servedById?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateManyAccountInput = {
    id?: string
    date: Date | string
    isPresent?: boolean
    notes?: string | null
    checkedById: string
    checkedAt?: Date | string
  }

  export type AttendanceCreateManyCheckedByInput = {
    id?: string
    date: Date | string
    accountId: string
    isPresent?: boolean
    notes?: string | null
    checkedAt?: Date | string
  }

  export type PayslipCreateManyAccountInput = {
    id?: string
    periodStartDate: Date | string
    periodEndDate: Date | string
    baseSalary: number
    totalCommissions: number
    totalDeductions?: number
    totalBonuses?: number
    netPay: number
    status?: $Enums.PayslipStatus
    releasedDate?: Date | string | null
    generatedAt?: Date | string
  }

  export type PayslipRequestCreateManyAccountInput = {
    id?: string
    requestTimestamp?: Date | string
    periodStartDate: Date | string
    periodEndDate: Date | string
    status?: $Enums.PayslipRequestStatus
    notes?: string | null
    processedById?: string | null
    processedTimestamp?: Date | string | null
    relatedPayslipId?: string | null
  }

  export type PayslipRequestCreateManyProcessedByInput = {
    id?: string
    accountId: string
    requestTimestamp?: Date | string
    periodStartDate: Date | string
    periodEndDate: Date | string
    status?: $Enums.PayslipRequestStatus
    notes?: string | null
    processedTimestamp?: Date | string | null
    relatedPayslipId?: string | null
  }

  export type ManualSaleCreateManyRecordedByInput = {
    id?: string
    date: Date | string
    amount: number
    paymentMethod?: $Enums.PaymentMethod | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId?: string | null
  }

  export type ExpenseCreateManyRecordedByInput = {
    id?: string
    date: Date | string
    amount: number
    category: $Enums.ExpenseCategory
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId?: string | null
  }

  export type AvailedServiceUpdateWithoutServedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutAvailedServicesNestedInput
    service?: ServiceUpdateOneWithoutAvailedServiceNestedInput
    originatingSet?: ServiceSetUpdateOneWithoutAvailedServiceNestedInput
    checkedBy?: AccountUpdateOneWithoutServicesCheckedNestedInput
    recommendedAppointment?: RecommendedAppointmentUpdateOneWithoutOriginatingAvailedServiceNestedInput
  }

  export type AvailedServiceUncheckedUpdateWithoutServedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    checkedById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recommendedAppointment?: RecommendedAppointmentUncheckedUpdateOneWithoutOriginatingAvailedServiceNestedInput
  }

  export type AvailedServiceUncheckedUpdateManyWithoutServedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    checkedById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailedServiceUpdateWithoutCheckedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutAvailedServicesNestedInput
    service?: ServiceUpdateOneWithoutAvailedServiceNestedInput
    originatingSet?: ServiceSetUpdateOneWithoutAvailedServiceNestedInput
    servedBy?: AccountUpdateOneWithoutServicesServedNestedInput
    recommendedAppointment?: RecommendedAppointmentUpdateOneWithoutOriginatingAvailedServiceNestedInput
  }

  export type AvailedServiceUncheckedUpdateWithoutCheckedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    servedById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recommendedAppointment?: RecommendedAppointmentUncheckedUpdateOneWithoutOriginatingAvailedServiceNestedInput
  }

  export type AvailedServiceUncheckedUpdateManyWithoutCheckedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    servedById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPresent?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkedBy?: AccountUpdateOneRequiredWithoutAttendancesCheckedNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPresent?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkedById?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPresent?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkedById?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutCheckedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPresent?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutCheckedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    isPresent?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutCheckedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    isPresent?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayslipUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    baseSalary?: IntFieldUpdateOperationsInput | number
    totalCommissions?: IntFieldUpdateOperationsInput | number
    totalDeductions?: IntFieldUpdateOperationsInput | number
    totalBonuses?: IntFieldUpdateOperationsInput | number
    netPay?: IntFieldUpdateOperationsInput | number
    status?: EnumPayslipStatusFieldUpdateOperationsInput | $Enums.PayslipStatus
    releasedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payslipRequest?: PayslipRequestUpdateOneWithoutRelatedPayslipNestedInput
  }

  export type PayslipUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    baseSalary?: IntFieldUpdateOperationsInput | number
    totalCommissions?: IntFieldUpdateOperationsInput | number
    totalDeductions?: IntFieldUpdateOperationsInput | number
    totalBonuses?: IntFieldUpdateOperationsInput | number
    netPay?: IntFieldUpdateOperationsInput | number
    status?: EnumPayslipStatusFieldUpdateOperationsInput | $Enums.PayslipStatus
    releasedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payslipRequest?: PayslipRequestUncheckedUpdateOneWithoutRelatedPayslipNestedInput
  }

  export type PayslipUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    baseSalary?: IntFieldUpdateOperationsInput | number
    totalCommissions?: IntFieldUpdateOperationsInput | number
    totalDeductions?: IntFieldUpdateOperationsInput | number
    totalBonuses?: IntFieldUpdateOperationsInput | number
    netPay?: IntFieldUpdateOperationsInput | number
    status?: EnumPayslipStatusFieldUpdateOperationsInput | $Enums.PayslipStatus
    releasedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayslipRequestUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayslipRequestStatusFieldUpdateOperationsInput | $Enums.PayslipRequestStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: AccountUpdateOneWithoutManagedPayslipRequestsNestedInput
    relatedPayslip?: PayslipUpdateOneWithoutPayslipRequestNestedInput
  }

  export type PayslipRequestUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayslipRequestStatusFieldUpdateOperationsInput | $Enums.PayslipRequestStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relatedPayslipId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PayslipRequestUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayslipRequestStatusFieldUpdateOperationsInput | $Enums.PayslipRequestStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relatedPayslipId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PayslipRequestUpdateWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayslipRequestStatusFieldUpdateOperationsInput | $Enums.PayslipRequestStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUpdateOneRequiredWithoutPayslipRequestsNestedInput
    relatedPayslip?: PayslipUpdateOneWithoutPayslipRequestNestedInput
  }

  export type PayslipRequestUncheckedUpdateWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayslipRequestStatusFieldUpdateOperationsInput | $Enums.PayslipRequestStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relatedPayslipId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PayslipRequestUncheckedUpdateManyWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayslipRequestStatusFieldUpdateOperationsInput | $Enums.PayslipRequestStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relatedPayslipId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ManualSaleUpdateWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutManualSalesNestedInput
  }

  export type ManualSaleUncheckedUpdateWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ManualSaleUncheckedUpdateManyWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseUpdateWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseUncheckedUpdateManyWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AvailedServiceCreateManyServiceInput = {
    id?: string
    transactionId: string
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetId?: string | null
    originatingSetTitle?: string | null
    checkedById?: string | null
    servedById?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecommendedAppointmentCreateManyOriginatingServiceInput = {
    id?: string
    customerId: string
    recommendedDate: Date | string
    originatingTransactionId?: string | null
    originatingAvailedServiceId: string
    status?: $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: string | null
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: Date | string | null
    reminder2DaySentAt?: Date | string | null
    reminder1DaySentAt?: Date | string | null
    reminderTodaySentAt?: Date | string | null
    reminder1DayAfterSentAt?: Date | string | null
    reminder7DaySentAt?: Date | string | null
    reminder7DayAfterSentAt?: Date | string | null
    reminder14DayAfterSentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailedServiceUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutAvailedServicesNestedInput
    originatingSet?: ServiceSetUpdateOneWithoutAvailedServiceNestedInput
    checkedBy?: AccountUpdateOneWithoutServicesCheckedNestedInput
    servedBy?: AccountUpdateOneWithoutServicesServedNestedInput
    recommendedAppointment?: RecommendedAppointmentUpdateOneWithoutOriginatingAvailedServiceNestedInput
  }

  export type AvailedServiceUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    checkedById?: NullableStringFieldUpdateOperationsInput | string | null
    servedById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recommendedAppointment?: RecommendedAppointmentUncheckedUpdateOneWithoutOriginatingAvailedServiceNestedInput
  }

  export type AvailedServiceUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    checkedById?: NullableStringFieldUpdateOperationsInput | string | null
    servedById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceSetUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    giftCertificates?: GiftCertificateUpdateManyWithoutServiceSetsNestedInput
    AvailedService?: AvailedServiceUpdateManyWithoutOriginatingSetNestedInput
  }

  export type ServiceSetUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    giftCertificates?: GiftCertificateUncheckedUpdateManyWithoutServiceSetsNestedInput
    AvailedService?: AvailedServiceUncheckedUpdateManyWithoutOriginatingSetNestedInput
  }

  export type ServiceSetUncheckedUpdateManyWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type GiftCertificateUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaserCustomer?: CustomerUpdateOneWithoutPurchasedGiftCertificatesNestedInput
    serviceSets?: ServiceSetUpdateManyWithoutGiftCertificatesNestedInput
    transactions?: TransactionUpdateManyWithoutGiftCertificateUsedNestedInput
  }

  export type GiftCertificateUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaserCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceSets?: ServiceSetUncheckedUpdateManyWithoutGiftCertificatesNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutGiftCertificateUsedNestedInput
  }

  export type GiftCertificateUncheckedUpdateManyWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaserCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiscountRuleUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    applyToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountRuleUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    applyToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountRuleUncheckedUpdateManyWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    applyToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendedAppointmentUpdateWithoutOriginatingServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    recommendedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRecommendedAppointmentStatusFieldUpdateOperationsInput | $Enums.RecommendedAppointmentStatus
    suppressNextFollowUpGeneration?: BoolFieldUpdateOperationsInput | boolean
    reminder3DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTodaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder14DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutRecommendedAppointmentsNestedInput
    originatingTransaction?: TransactionUpdateOneWithoutOriginatingRecommendationsNestedInput
    originatingAvailedService?: AvailedServiceUpdateOneRequiredWithoutRecommendedAppointmentNestedInput
    attendedTransaction?: TransactionUpdateOneWithoutAttendedAppointmentNestedInput
  }

  export type RecommendedAppointmentUncheckedUpdateWithoutOriginatingServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    recommendedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    originatingTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingAvailedServiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumRecommendedAppointmentStatusFieldUpdateOperationsInput | $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    suppressNextFollowUpGeneration?: BoolFieldUpdateOperationsInput | boolean
    reminder3DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTodaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder14DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendedAppointmentUncheckedUpdateManyWithoutOriginatingServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    recommendedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    originatingTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingAvailedServiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumRecommendedAppointmentStatusFieldUpdateOperationsInput | $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    suppressNextFollowUpGeneration?: BoolFieldUpdateOperationsInput | boolean
    reminder3DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTodaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder14DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailedServiceCreateManyOriginatingSetInput = {
    id?: string
    transactionId: string
    serviceId?: string | null
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetTitle?: string | null
    checkedById?: string | null
    servedById?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateWithoutServiceSetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
    branch?: BranchUpdateOneRequiredWithoutServicesNestedInput
    AvailedService?: AvailedServiceUpdateManyWithoutServiceNestedInput
    giftCertificates?: GiftCertificateUpdateManyWithoutServicesNestedInput
    discountRules?: DiscountRuleUpdateManyWithoutServicesNestedInput
    recommendedAppointments?: RecommendedAppointmentUpdateManyWithoutOriginatingServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutServiceSetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    branchId?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
    AvailedService?: AvailedServiceUncheckedUpdateManyWithoutServiceNestedInput
    giftCertificates?: GiftCertificateUncheckedUpdateManyWithoutServicesNestedInput
    discountRules?: DiscountRuleUncheckedUpdateManyWithoutServicesNestedInput
    recommendedAppointments?: RecommendedAppointmentUncheckedUpdateManyWithoutOriginatingServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutServiceSetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    branchId?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
  }

  export type GiftCertificateUpdateWithoutServiceSetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaserCustomer?: CustomerUpdateOneWithoutPurchasedGiftCertificatesNestedInput
    services?: ServiceUpdateManyWithoutGiftCertificatesNestedInput
    transactions?: TransactionUpdateManyWithoutGiftCertificateUsedNestedInput
  }

  export type GiftCertificateUncheckedUpdateWithoutServiceSetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaserCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: ServiceUncheckedUpdateManyWithoutGiftCertificatesNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutGiftCertificateUsedNestedInput
  }

  export type GiftCertificateUncheckedUpdateManyWithoutServiceSetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaserCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AvailedServiceUpdateWithoutOriginatingSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutAvailedServicesNestedInput
    service?: ServiceUpdateOneWithoutAvailedServiceNestedInput
    checkedBy?: AccountUpdateOneWithoutServicesCheckedNestedInput
    servedBy?: AccountUpdateOneWithoutServicesServedNestedInput
    recommendedAppointment?: RecommendedAppointmentUpdateOneWithoutOriginatingAvailedServiceNestedInput
  }

  export type AvailedServiceUncheckedUpdateWithoutOriginatingSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    checkedById?: NullableStringFieldUpdateOperationsInput | string | null
    servedById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recommendedAppointment?: RecommendedAppointmentUncheckedUpdateOneWithoutOriginatingAvailedServiceNestedInput
  }

  export type AvailedServiceUncheckedUpdateManyWithoutOriginatingSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    checkedById?: NullableStringFieldUpdateOperationsInput | string | null
    servedById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendedAppointmentCreateManyCustomerInput = {
    id?: string
    recommendedDate: Date | string
    originatingTransactionId?: string | null
    originatingAvailedServiceId: string
    originatingServiceId: string
    status?: $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: string | null
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: Date | string | null
    reminder2DaySentAt?: Date | string | null
    reminder1DaySentAt?: Date | string | null
    reminderTodaySentAt?: Date | string | null
    reminder1DayAfterSentAt?: Date | string | null
    reminder7DaySentAt?: Date | string | null
    reminder7DayAfterSentAt?: Date | string | null
    reminder14DayAfterSentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyCustomerInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    voucherId?: string | null
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    branchId?: string | null
    bookingReminderSentAt?: Date | string | null
    giftCertificateId?: string | null
  }

  export type GiftCertificateCreateManyPurchaserCustomerInput = {
    id?: string
    code: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    recipientName?: string | null
    recipientEmail?: string | null
    usedAt?: Date | string | null
  }

  export type RecommendedAppointmentUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    recommendedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRecommendedAppointmentStatusFieldUpdateOperationsInput | $Enums.RecommendedAppointmentStatus
    suppressNextFollowUpGeneration?: BoolFieldUpdateOperationsInput | boolean
    reminder3DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTodaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder14DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originatingTransaction?: TransactionUpdateOneWithoutOriginatingRecommendationsNestedInput
    originatingAvailedService?: AvailedServiceUpdateOneRequiredWithoutRecommendedAppointmentNestedInput
    originatingService?: ServiceUpdateOneRequiredWithoutRecommendedAppointmentsNestedInput
    attendedTransaction?: TransactionUpdateOneWithoutAttendedAppointmentNestedInput
  }

  export type RecommendedAppointmentUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    recommendedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    originatingTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingAvailedServiceId?: StringFieldUpdateOperationsInput | string
    originatingServiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumRecommendedAppointmentStatusFieldUpdateOperationsInput | $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    suppressNextFollowUpGeneration?: BoolFieldUpdateOperationsInput | boolean
    reminder3DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTodaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder14DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendedAppointmentUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    recommendedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    originatingTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingAvailedServiceId?: StringFieldUpdateOperationsInput | string
    originatingServiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumRecommendedAppointmentStatusFieldUpdateOperationsInput | $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    suppressNextFollowUpGeneration?: BoolFieldUpdateOperationsInput | boolean
    reminder3DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTodaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder14DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availedServices?: AvailedServiceUpdateManyWithoutTransactionNestedInput
    voucherUsed?: VoucherUpdateOneWithoutTransactionNestedInput
    branch?: BranchUpdateOneWithoutTransactionNestedInput
    giftCertificateUsed?: GiftCertificateUpdateOneWithoutTransactionsNestedInput
    originatingRecommendations?: RecommendedAppointmentUpdateManyWithoutOriginatingTransactionNestedInput
    attendedAppointment?: RecommendedAppointmentUpdateOneWithoutAttendedTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    giftCertificateId?: NullableStringFieldUpdateOperationsInput | string | null
    availedServices?: AvailedServiceUncheckedUpdateManyWithoutTransactionNestedInput
    originatingRecommendations?: RecommendedAppointmentUncheckedUpdateManyWithoutOriginatingTransactionNestedInput
    attendedAppointment?: RecommendedAppointmentUncheckedUpdateOneWithoutAttendedTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    giftCertificateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GiftCertificateUpdateWithoutPurchaserCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: ServiceUpdateManyWithoutGiftCertificatesNestedInput
    serviceSets?: ServiceSetUpdateManyWithoutGiftCertificatesNestedInput
    transactions?: TransactionUpdateManyWithoutGiftCertificateUsedNestedInput
  }

  export type GiftCertificateUncheckedUpdateWithoutPurchaserCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: ServiceUncheckedUpdateManyWithoutGiftCertificatesNestedInput
    serviceSets?: ServiceSetUncheckedUpdateManyWithoutGiftCertificatesNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutGiftCertificateUsedNestedInput
  }

  export type GiftCertificateUncheckedUpdateManyWithoutPurchaserCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionCreateManyVoucherUsedInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    customerId: string
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    branchId?: string | null
    bookingReminderSentAt?: Date | string | null
    giftCertificateId?: string | null
  }

  export type TransactionUpdateWithoutVoucherUsedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutTransactionHistoryNestedInput
    availedServices?: AvailedServiceUpdateManyWithoutTransactionNestedInput
    branch?: BranchUpdateOneWithoutTransactionNestedInput
    giftCertificateUsed?: GiftCertificateUpdateOneWithoutTransactionsNestedInput
    originatingRecommendations?: RecommendedAppointmentUpdateManyWithoutOriginatingTransactionNestedInput
    attendedAppointment?: RecommendedAppointmentUpdateOneWithoutAttendedTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutVoucherUsedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    giftCertificateId?: NullableStringFieldUpdateOperationsInput | string | null
    availedServices?: AvailedServiceUncheckedUpdateManyWithoutTransactionNestedInput
    originatingRecommendations?: RecommendedAppointmentUncheckedUpdateManyWithoutOriginatingTransactionNestedInput
    attendedAppointment?: RecommendedAppointmentUncheckedUpdateOneWithoutAttendedTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutVoucherUsedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    giftCertificateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AvailedServiceCreateManyTransactionInput = {
    id?: string
    serviceId?: string | null
    quantity?: number
    price: number
    commissionValue?: number
    originatingSetId?: string | null
    originatingSetTitle?: string | null
    checkedById?: string | null
    servedById?: string | null
    serviceSetId?: string | null
    status?: $Enums.Status
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecommendedAppointmentCreateManyOriginatingTransactionInput = {
    id?: string
    customerId: string
    recommendedDate: Date | string
    originatingAvailedServiceId: string
    originatingServiceId: string
    status?: $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: string | null
    suppressNextFollowUpGeneration?: boolean
    reminder3DaySentAt?: Date | string | null
    reminder2DaySentAt?: Date | string | null
    reminder1DaySentAt?: Date | string | null
    reminderTodaySentAt?: Date | string | null
    reminder1DayAfterSentAt?: Date | string | null
    reminder7DaySentAt?: Date | string | null
    reminder7DayAfterSentAt?: Date | string | null
    reminder14DayAfterSentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailedServiceUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutAvailedServiceNestedInput
    originatingSet?: ServiceSetUpdateOneWithoutAvailedServiceNestedInput
    checkedBy?: AccountUpdateOneWithoutServicesCheckedNestedInput
    servedBy?: AccountUpdateOneWithoutServicesServedNestedInput
    recommendedAppointment?: RecommendedAppointmentUpdateOneWithoutOriginatingAvailedServiceNestedInput
  }

  export type AvailedServiceUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    checkedById?: NullableStringFieldUpdateOperationsInput | string | null
    servedById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recommendedAppointment?: RecommendedAppointmentUncheckedUpdateOneWithoutOriginatingAvailedServiceNestedInput
  }

  export type AvailedServiceUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    commissionValue?: IntFieldUpdateOperationsInput | number
    originatingSetId?: NullableStringFieldUpdateOperationsInput | string | null
    originatingSetTitle?: NullableStringFieldUpdateOperationsInput | string | null
    checkedById?: NullableStringFieldUpdateOperationsInput | string | null
    servedById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceSetId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendedAppointmentUpdateWithoutOriginatingTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recommendedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRecommendedAppointmentStatusFieldUpdateOperationsInput | $Enums.RecommendedAppointmentStatus
    suppressNextFollowUpGeneration?: BoolFieldUpdateOperationsInput | boolean
    reminder3DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTodaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder14DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutRecommendedAppointmentsNestedInput
    originatingAvailedService?: AvailedServiceUpdateOneRequiredWithoutRecommendedAppointmentNestedInput
    originatingService?: ServiceUpdateOneRequiredWithoutRecommendedAppointmentsNestedInput
    attendedTransaction?: TransactionUpdateOneWithoutAttendedAppointmentNestedInput
  }

  export type RecommendedAppointmentUncheckedUpdateWithoutOriginatingTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    recommendedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    originatingAvailedServiceId?: StringFieldUpdateOperationsInput | string
    originatingServiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumRecommendedAppointmentStatusFieldUpdateOperationsInput | $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    suppressNextFollowUpGeneration?: BoolFieldUpdateOperationsInput | boolean
    reminder3DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTodaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder14DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendedAppointmentUncheckedUpdateManyWithoutOriginatingTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    recommendedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    originatingAvailedServiceId?: StringFieldUpdateOperationsInput | string
    originatingServiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumRecommendedAppointmentStatusFieldUpdateOperationsInput | $Enums.RecommendedAppointmentStatus
    attendedTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    suppressNextFollowUpGeneration?: BoolFieldUpdateOperationsInput | boolean
    reminder3DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTodaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DaySentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder7DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder14DayAfterSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyGiftCertificateUsedInput = {
    id?: string
    createdAt?: Date | string
    bookedFor?: Date | string
    customerId: string
    voucherId?: string | null
    discount?: number
    paymentMethod?: $Enums.PaymentMethod | null
    grandTotal: number
    status?: $Enums.Status
    branchId?: string | null
    bookingReminderSentAt?: Date | string | null
  }

  export type ServiceUpdateWithoutGiftCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
    branch?: BranchUpdateOneRequiredWithoutServicesNestedInput
    AvailedService?: AvailedServiceUpdateManyWithoutServiceNestedInput
    serviceSets?: ServiceSetUpdateManyWithoutServicesNestedInput
    discountRules?: DiscountRuleUpdateManyWithoutServicesNestedInput
    recommendedAppointments?: RecommendedAppointmentUpdateManyWithoutOriginatingServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutGiftCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    branchId?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
    AvailedService?: AvailedServiceUncheckedUpdateManyWithoutServiceNestedInput
    serviceSets?: ServiceSetUncheckedUpdateManyWithoutServicesNestedInput
    discountRules?: DiscountRuleUncheckedUpdateManyWithoutServicesNestedInput
    recommendedAppointments?: RecommendedAppointmentUncheckedUpdateManyWithoutOriginatingServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutGiftCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    branchId?: StringFieldUpdateOperationsInput | string
    totalSales?: IntFieldUpdateOperationsInput | number
    recommendFollowUp?: BoolFieldUpdateOperationsInput | boolean
    recommendedFollowUpDays?: NullableIntFieldUpdateOperationsInput | number | null
    followUpPolicy?: EnumFollowUpPolicyFieldUpdateOperationsInput | $Enums.FollowUpPolicy
  }

  export type ServiceSetUpdateWithoutGiftCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    services?: ServiceUpdateManyWithoutServiceSetsNestedInput
    AvailedService?: AvailedServiceUpdateManyWithoutOriginatingSetNestedInput
  }

  export type ServiceSetUncheckedUpdateWithoutGiftCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    services?: ServiceUncheckedUpdateManyWithoutServiceSetsNestedInput
    AvailedService?: AvailedServiceUncheckedUpdateManyWithoutOriginatingSetNestedInput
  }

  export type ServiceSetUncheckedUpdateManyWithoutGiftCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionUpdateWithoutGiftCertificateUsedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutTransactionHistoryNestedInput
    availedServices?: AvailedServiceUpdateManyWithoutTransactionNestedInput
    voucherUsed?: VoucherUpdateOneWithoutTransactionNestedInput
    branch?: BranchUpdateOneWithoutTransactionNestedInput
    originatingRecommendations?: RecommendedAppointmentUpdateManyWithoutOriginatingTransactionNestedInput
    attendedAppointment?: RecommendedAppointmentUpdateOneWithoutAttendedTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutGiftCertificateUsedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availedServices?: AvailedServiceUncheckedUpdateManyWithoutTransactionNestedInput
    originatingRecommendations?: RecommendedAppointmentUncheckedUpdateManyWithoutOriginatingTransactionNestedInput
    attendedAppointment?: RecommendedAppointmentUncheckedUpdateOneWithoutAttendedTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutGiftCertificateUsedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}